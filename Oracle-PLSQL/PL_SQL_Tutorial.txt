Part 4: Anchored Datatype (%TYPE) in PL/SQL By Manish Sharma RebellionRider

Anchored data types are those data types which you assign to a variable based on a database object.
Syntax: 
	variable_name typed-attribute %TYPE

Example:
	v_fname student.first_name%TYPE;
	

Part 5: PL/SQL Constants in Oracle Database

You can declare constants only in declaration section of your pl/sql block.

Syntax:
	constant_name CONSTANT datatype (dw) := value;		//You must initialize your constant at the time of its creation in declaration section.

Example:
	v_pi CONSTANT NUMBER(7,6) := 3.141592;
	
Two attributes of PL/SQL constants - DEFAULT and NOT NULL
DEFAULT - We can use default keyword instead of assignment operator to initialize the constant in PL/SQL. 
	vi_pi CONSTANT NUMBER(7,6) DEFAULT 3.141592;
	
NOT NULL - Using this attribute we can impose NOT NULL constraint while declaring constant. This will prevent from assigning NULL values to your constants or 
			variables.
			vi_pi CONSTANT NUMBER(7,6) NOT NULL DEFAULT 3.141592;
	

	
Part tutorial 6: Bind Variable in PL/SQL 

There are two type of variable in Oracle database.
	- User Variables 
	- Bind Variables /Host Variables
	
Unlike user variables which can only be declared inside the declaration section of the PL/SQL block you can declare bind variable anywhere in the host environment.
Bind variable in Oracle database can be defined as the variables that we create in SQL * PLUS and the reference in PL/SQL. 

Declare a bind variable - We can declare a bind variable using Variable command.
		VARIABLE v_bind VARCHAR2(10);

Initializing bind variable - We can initialize the bind variable using execute command.
		VARIABLE v_bind VARCHAR2(10);
		EXEC: v_bind := 'Aniket';		--We can also use - EXECUTE: v_bind := 'Aniket';
		
	Another way of initializing is by explicitly writing execution section of PL/SQL block.
		VARIABLE v_bind VARCHAR2(10);
		BEGIN
			:v_bind := 'Aniket';	
		END;
		/
		
Display the bind variable value - 
	i. Using DBMS_OUTPUT package - 
		SET SERVER OUTPUT ON
		VARIABLE v_bind VARCHAR2(10);
		BEGIN
			:v_bind := 'Aniket';
			DBMS_OUTPUT.PUT_LINE(:v_bind);		-- To execute this we need execution section of PL/SQL block
		END;
		/

	ii. Using PRINT command - 
			We can write this command in host environment rather than inside any PL/SQL block or section.
			PRINT :v_bind;
			
	iii. Using AUTOPRINT ON -
			SET AUTOPRINT ON;
			VARIABLE v_bind VARCHAR2(10);
			EXEC: v_bind := 'Aniket';			-- When this statement is executed (i.e. statement initializing bind variable), due to 'SET AUTOPRINT ON' oracle 
												-- will automatically print the value of bind variable.
			
Other Uses of Variable Command -

	Declaring the bind variable is the first use of this variable command there are few other uses of it also. Let’s see what those are:
	
	1. List all the bind variable declared in the session.
		Yes using Variable command you can display the list of all the bind variables you have declared in the session. To display the list of all the bind 
		variables you simply have to write the keyword variable and execute. Doing so will return list of all the bind variables. 
		Let’s see.
		VARIABLE; 
		Execute the above command and that will show you the list of all the bind variables that you have declared in your session.

	2. To see the definition of bind variable.
		Variable command can also show you the definition of any bind variable created in the session. By definition I mean the data type and data width of the 
		variable. To see the definition of the bind variable you have to write the keyword VARIABLE followed by the name of the bind variable in question.
		Let’s do an example and see the definition of this bind variable v_Bind2.
		Variable v_bind2; 
		Execution of above command will show you the definition of bind variable v_bind2. 

		
		
Part 7 - Introduction of Conditional Control Statements in PL/SQL

Statements which allow you to control the execution flow of the program depending on a condition. In other words the statements in the program are not necessarily 
executed in a sequence rather one or other group of statements are executed depending on the evaluation of a condition.

In Oracle PL/SQL we have two types of conditional control statements which are -
	- IF statements and
	- CASE statements

Both these statements can be further divided into different forms. For example IF statements has 3 different forms - 
	- IF THEN
	- IF THEN ELSE
	- IF THEN ELSEIF

And CASE statement has 2 different forms such as - 
	- SIMPLE CASE
	- SEARCHED CASE

Simple Case Expression - 
	Using Case expression you can achieve the IF-THEN-ELSE logic in Oracle SQL that too without invoking any kind of SQL procedures. 

	CASE expression can do all the work of a DECODE expression. Several books recommend using CASE over DECODE because 
	CASE expressions are easier to read in comparison to DECODE expression and 
	CASE expression is ANSI-compliant and forms part of the SQL/92 standard.
	In Oracle there are two types of CASE expressions - 
	- Simple case expressions
	- Searched case expressions

	Simple Case Expression - 
	As the name suggests it is the simplest version of CASE expression in other words we can say that it is a flexible and easiest version of DECODE expression. 

	The syntax of “Simple Case Expression” is 
	CASE search_expression
		WHEN   input_expression 1   THEN   output_result 1
		WHEN   input_expression 2   THEN   output_result 2
		...
		WHEN   input_expression N   THEN   output_result N
		ELSE    Else_result
	END 


Points to remember 
	- The data type of all the input expressions must match with the data type of search expression. Means data type of search expression and input expression
		must be the same.
	- The datatype of all the output results must match with Else result means the data type of output result along with else result must be the same.
	- The maximum number of arguments in a CASE expression is 255. All expressions count toward this limit, including the initial expression of a simple CASE 
		expression and the optional ELSE expression. Each WHEN ... THEN pair counts as two arguments. To avoid exceeding this limit, you can nest CASE expressions 
		so that the output_result itself is a CASE expression. 

Query 1: Column Name as Search Expression.
	SELECT first_name,department_id,
		(CASE    department_id
			WHEN    10    THEN    'Administration'
			WHEN    20    THEN    'Marketing'
			WHEN    30    THEN    'Purchasing'
			WHEN    40    THEN    'Shipping'
			WHEN    50    THEN    'Shipping'
			ELSE    'Sorry'
		END)    Departments
	FROM    employees
	WHERE    department_id    BETWEEN 10 AND 50
	ORDER BY 2; 
	

Query 2: String as Search Expression.
In case you specify a string instead of a column name as a search expression then oracle will find the first best fit match and then return the corresponding 
result value. 

	SELECT
		CASE 'Dog'
			WHEN    'Cat'    THEN    '1 Flase'
			WHEN    'Dog'    THEN    '2 True'
			WHEN    'Cow'    THEN    '3 False'
			WHEN    'Dog'    THEN    '4 True'
			ELSE    'Sorry'
		END
	FROM dual;
	
Here in this simple case, the search expression is ‘Dog’ along with 4 When-and-Then pairs. The input expression of 2nd and 4th pair is a string “Dog” which is a 
perfect match for our search expression but on executing this query, oracle engine will return the result value from the first best match which in our case is the 
2nd pair.


Search Case Expression:

Syntax is similar to Simple Case Expression:

	CASE 						-- Unlike simple case expression we don't have any search_expression folled by CASE 
		WHEN condition1 THEN result1	-- Here we have conditions instead of expression, followed by when keyword.
		WHEN condition2 THEN result2
		...
		WHEN conditionN THEN resultN
		ELSE else_result
	END

Example - 

SELECT * FROM superheros;
O/P = 
	First_Name  Last_Name
	Bruce 		Wayne
	Tony 		Stark
	Clark		Kent
	Peter 		Parker
	

Select first_name, last_name, 
	(Case	
		WHEN first_name = 'Tony' AND last_name = 'Stark' THEN 'Ironman'
		WHEN first_name = 'Bruce' AND last_name = 'Wayne' THEN 'Batman'
		WHEN first_name = 'Clark' AND last_name = 'Kent' THEN 'Superman'
		WHEN first_name = 'Peter' AND last_name = 'Parker' THEN 'Spiderman'
		ELSE 'Sorry'
	END) as superheros
FROM superheros;

(Can use search case expression when we want to use logical operators in search_expression)
	

Example - 
 
SELECT first_name, salary,
	(Case	
		WHEN salary <= 9000 THEN 'Case 1'
		WHEN last_name = 'King' AND manager_id IS NULL THEN 'Case 2'
		WHEN salary BETWEEN 10000 AND 13500 THEN 'Case 3'
		WHEN salary IN (14000, 17000, 24000) THEN 'Case 4'
		ELSE 'Sorry'
	END) As Result
FROM employees
WHERE salary >= 8500;


Part 8 - IF_THEN Condition.

IF condition THEN
	Statement1;
	…
	Statement N;
END IF;


Example- 
	DECLARE 
		v_website VARCHAR2(30) := 'RebellionRider.com';
		v_author VARCHAR2(30) := 'Manish';
	BEGIN
		IF v_website ='RebellionRider.com' AND v_author= 'Manish' THEN
			DBMS_OUTPUT.PUT_LINE('Everything is Awesome :)');
		END IF;
		DBMS_OUTPUT.PUT_LINE('Give this Video a Thumbs Up');
	END;
	/

Part 9 - IF_THE_ELSE

IF condition THEN
	Statement 1;
ELSE
	Statement 2;
END IF;
	Statement 3



SEt SERVEROUTPUT ON;
DECLARE
	v_num NUMBER := &enter_a_number; 		--If you execute this block in SQL PLUS then it will ask for user input.
BEGIN
	IF MOD (v_num, 2) = 0 THEN
		DBMS_OUTPUT.PUT_LINE (v_num || ' Is Even'); 
	ELSE
		DBMS_OUTPUT.PUT_LINE (v_num ||' is odd'); 
	END IF; 
	DBMS_OUTPUT.PUT_LINE ('IF THEN ELSE Construct complete '); 
END; 


Part 10 - IF-THEN-ELSIF

Syntax - 
	IF CONDITION 1 THEN
		STATEMENT 1;
	ELSIF CONDITION 2 THEN
		STATEMENT 2;
	ELSIF CONDITION 3 THEN
		STATEMENT 3;
		...
	ELSE
		STATEMENT N;
	END IF; 

Example- 
	DECLARE
		v_Place VARCHAR2(30) := '&Enter Place';
	BEGIN
		IF v_Place = 'Metropolis' THEN
			DBMS_OUTPUT.PUT_LINE('This City Is Protected By Superman'); 
		ELSIF v_Place = 'Gotham' THEN
			DBMS_OUTPUT.PUT_LINE('This City is Protected By Batman');
		ELSIF v_Place = 'Amazon' THEN
			DBMS_OUTPUT.PUT_LINE('This City is protected by Wonder Woman');
		ELSE
			DBMS_OUTPUT.PUT_LINE('Please Call Avengers');
		END IF;
		DBMS_OUTPUT.PUT_LINE('Thanks For Contacting us');
	END;
	/

	
	
Part 11 - Simple Loop

Types of Loops in Oracle PL/SQL
There are 4 types of Loops in Oracle PL/SQL -
	- Simple Loop
	- While Loop
	- Numeric For Loop and
	- Cursor For loop 


Simple Loop - 
	Simple loop is the most basic loop in Oracle PL/SQL

Syntax - 
	LOOP
		Statement 1;
		Statement 2;
		…
		Statement 3;
	END LOOP;

We don't have exist condition which will terminate the loop. In this case Oracle PL/SQL gives us two clauses to terminate the loop - 
	- Exit 
	- Exit When

Example 2 Terminate Loop with EXIT - 
	DECLARE 
		v_counter NUMBER :=0;
		v_result NUMBER;
	BEGIN
		LOOP
			v_counter := v_counter+1;
			v_result := 19*v_counter;
			DBMS_OUTPUT.PUT_LINE('19'||' x '||v_counter||' = '|| v_result); 
			
			IF v_counter >=10 THEN
				EXIT;
			END IF;

		END LOOP;
	END;

Example 3 Terminate the Loop with EXIT WHEN Clause - 

Second way of terminating the loop is by using EXIT WHEN clause. Using this clause you can replace this whole IF THEN block with a simple single statement.

	DECLARE 
		v_counter NUMBER :=0;
		v_result NUMBER;
	BEGIN
		LOOP
			v_counter := v_counter+1;
			v_result := 19*v_counter;
			DBMS_OUTPUT.PUT_LINE('19'||' x '||v_counter||' = '|| v_result); 

			EXIT WHEN i_counter>=10;

		END LOOP;
	END;


Part 12 - While loop

This loop is best usable when number of iterations to be performed are unknown. [ Click Here To Tweet This]

Syntax - 

	WHILE condition LOOP
		Statement 1;
		Statemen 2;
		…
		Statement 3;
	END LOOP;


Example 1 -

	DECLARE
		v_counter NUMBER :=1;
		v_result NUMBER ;
	BEGIN
		WHILE v_counter <= 10 
		LOOP
			v_result := 9 *v_counter;
			DBMS_OUTPUT.PUT_LINE('9'||' x '||v_counter||' = '||v_result);
			v_counter := v_counter+1;
		END LOOP;
		DBMS_OUTPUT.PUT_LINE('out');
	END;
	/

Program to Print multiplication table of 19 using Boolean Expression In While Loop - 

	DECLARE
		v_test BOOLEAN := TRUE;
		v_counter NUMBER :=1;
		v_result NUMBER;
	BEGIN
		WHILE v_test LOOP
			v_result := 19 * v_counter;
			DBMS_OUTPUT.PUT_LINE('19'||' x '||v_counter||' = '||v_result);
			-- Loop Termination Code
			IF v_counter =10 THEN
				v_test := FALSE;
			END IF;
			v_counter := v_counter +1;
		END LOOP;
		DBMS_OUTPUT.PUT_LINE('Outside the loop');
	END;
	/


Part 13 - Numeric FOR LOOP

In PL/SQL we have two types of FOR loops:
	- Numeric FOR loop
	- Cursor FOR loop.

FOR loop allows you to execute the block of statements repeatedly for a fixed number of time whereas WHILE loop is better suited when the number of iterations 
are unknown.

Examples of Numeric FOR Loop In Oracle PL/SQL -

Example 1: FOR loop 
	
	SET SERVEROUTPUT ON;
	BEGIN
		FOR v_counter IN 1..10 LOOP
			DBMS_OUTPUT.PUT_LINE(v_counter);
		END LOOP;
	END;
	
Here we only have the execution section and inside that we have our FOR loop which will print the value of v_counter variable from 1 to 10.
Have you noticed that we didn’t declare the v_counter variable anywhere in the program? Even we don’t have the declaration section here in this code. 
This is because variable v_counter is an implicit index integer variable which gets declared automatically with the definition of FOR loop. 
Moreover the variable v_counter will increment by 1 with each iteration automatically by FOR loop construct thus you do not need to write update 
statement (v_counter := v_counter +1) explicitly. As a matter of fact if you will try to write the update statement in the “FOR loop” then you will get an error.

Example 2: FOR Loop with IN REVERSE keyword.
	BEGIN
		FOR v_counter IN REVERSE 1..10 LOOP
			DBMS_OUTPUT.PUT_LINE(v_counter);
		END LOOP;
	END;
	/

	
	
Part 14 - Introduction to triggers

Triggers are named PL/SQL blocks which are stored in the database or we can also say that they are specialized stored programs which execute implicitly when a 
triggering event occurs which means we cannot call and execute them directly instead they only get triggered by events in the database.

Events Which Fires the Triggers : 
	These events can be anything such as :
	1. A DML Statement. For example Update, Insert or Delete, executing on any table of your database. You can program your trigger to execute either BEFORE or 
		AFTER executing your DML statement. For example you can create a trigger which will get fired Before the Update statement. Or you can create a trigger which 
		will get triggered after the execution of your INSERT DML statement. 
	2. Next type of triggering statement can be a DDL Statement such as CREATE or ALTER. These triggers can also be executed either BEFORE or AFTER the execution 
		of your DDL statement. These triggers are generally used by DBAs for auditing purposes and they really come in handy when you want to keep an eye on the various 
		changes on your schema such as who created the object or which user. Just like some cool spy tricks.
	3. A system event. Yes, you can create a trigger on a system event and by system event I mean shut down or startup of your database.
	4. Another type of triggering event can be User Eventssuch as log off or log on onto your database. You can create a trigger which will either execute before or
		after the event and record the information such as time of event occur, the username who created it.

Types of Triggers : 
	There are 5 types of triggers in oracle database in which 3 of them are based on the triggering event which are discussed in the previous section.		

	1. Data Manipulation Language Triggers or DML triggers :
		As the name suggests these are the triggers which depend on DML statements such as Update, Insert or Delete and they get fired either before or after them. 
		Using DML trigger you can control the behavior of your DML statements. You can audit, check, replace or save values before they are changed. 
		Automatic Increment of your Numeric primary key is one of the most frequent tasks of these types of triggers.

	2. Data Definition Language Triggers or DDL triggers.
		Again as the name suggests these are the type of triggers which are created over DDL statements such as CREATE or ALTER and get fired either before or 
		after execution of your DDL statements. Using this type of trigger you can monitor the behavior and force rules on your DDL statements.

	3. System or Database Event triggers.
		Third type of triggers is system or database triggers. These are the type of triggers which come into action when some system event occurs such as 
		database log on or log off. You can use these triggers for auditing purposes for example keeping an eye on information of system access like say who 
		connects with your database and when. Most of the time System or Database Event triggers work as Swiss Knife for DBAs and help them in increasing the 
		security of the data. 

	4. Instead-of Trigger
		This is a type of trigger which enables you to stop and redirect the performance of a DML statement. Often this type of trigger helps you in managing 
		the way you write to non-updatable views. You can also see the application of business rules by INSTEAD OF triggers where they insert, update or delete 
		rows directly in tables that are defining updatable views. Alternatively, sometimes the INSTEAD OF triggers are also seen inserting, updating or deleting 
		rows in designated tables that are otherwise unrelated to the view.

	5. Compound triggers
		These are multi-tasking triggers that act as both statement as well as row-level triggers when the data is inserted, updated or deleted from a table. 
		You can capture information at four timing points using this trigger: 
		(a) before the firing statement; 
		(b) prior to change of each row from the firing statement; 
		(c) post each row changes from the firing statement; 
		(d) after the firing statement. 
		
	All these types of triggers can be used to audit, check, save and replace the values even before they are changed right when there is a need to take 
	action at the statement as well as row event levels.

	
Syntax - 

	CREATE [OR REPLACE] TRIGGER Ttrigger_name
	{BEFORE|AFTER} Triggering_event ON table_name
	[FOR EACH ROW]									-- This is row trigger, fires once for each row which is inserted/updated/deleted.
	[FOLLOWS another_trigger_name]					-- Allows us to specify the order in which trigger should fire, in case of multiple triggers. 
	[ENABLE/DISABLE]
	[WHEN condition]								--Condition which needs to be true in order the trigger to be fired.
	DECLARE
		declaration statements
	BEGIN
		executable statements
	EXCEPTION
		exception-handling statements
	END;
	

Uses of triggers: 
	- Using triggers we can enforce business rules that can’t be defined by using integrity constants.
	- Using triggers we can gain strong control over the security.
	- We can also collect statistical information on the table access.
	- We can automatically generate values for derived columns such as auto increment numeric primary key.
	- Using triggers you can prevent invalid transaction.


Restriction on Triggers: 
	- Maximum size of the trigger body must not exceed 32,760 bytes because triggers’ bodies are stored in LONG datatypes columns.
	- A trigger may not issue transaction control statements or TCL statements such as COMMIT, ROLLBACK or SAVEPOINT. All operations performed when the trigger fires, become part of a transaction. Therefore whenever this transaction is rolled back or committed it leads to the respective rolling back or committing of the operations performed. 
	- Any function or procedure called by a trigger may not issue a transactional control statement unless it contains an autonomous transaction.
	- Declaring LONG or LONG RAW variable is not permissible in the body of the trigger.	
	

Part 15 - DML Triggers.

INSERT, UPDATE, DELETE All in One DML Trigger Using IF-THEN-ELSIF : 

	CREATE OR REPLACE TRIGGER tr_superheroes
	BEFORE INSERT OR DELETE OR UPDATE ON superheroes
	FOR EACH ROW
	ENABLE
	DECLARE
		v_user VARCHAR2(15);
	BEGIN
	SELECT 
		user INTO v_user FROM dual;
	IF INSERTING THEN
		DBMS_OUTPUT.PUT_LINE('one line inserted by '||v_user);
	ELSIF DELETING THEN
		DBMS_OUTPUT.PUT_LINE('one line Deleted by '||v_user);
	ELSIF UPDATING THEN
		DBMS_OUTPUT.PUT_LINE('one line Updated by '||v_user);
	END IF;
	END;
	/	
	

Part 16 - Table Auditing using DML Trigger.
	
Table Auditing : 
Table auditing means keeping a track of all the dml activities performed on a specific table of the database for example which user Inserted, updated or deleted 
a row from the table and when. It is like spying on the users who are messing your table’s data. 

CREATE TABLE superheroes (
	sh_name VARCHAR2 (15)
);

CREATE TABLE sh_audit(
	new_name varchar2(30),
	old_name varchar2(30),
	user_name varchar2(30),
	entry_date varchar2(30),
	operation varchar2(30)
); 


CREATE OR REPLACE TRIGGER superheroes_audit
BEFORE INSERT OR DELETE OR UPDATE ON superheroes
FOR EACH ROW
ENABLE
	DECLARE
		v_user  varchar2 (30);
		v_date  varchar2(30);
	BEGIN
		SELECT user, TO_CHAR(sysdate, 'DD/MON/YYYY HH24:MI:SS') INTO v_user, v_date FROM dual;

		IF INSERTING THEN
			INSERT INTO sh_audit (new_name,old_name, user_name, entry_date, operation)
			VALUES(:NEW.SH_NAME, Null , v_user, v_date, 'Insert');

		ELSIF DELETING THEN
			INSERT INTO sh_audit (new_name,old_name, user_name, entry_date, operation)
			VALUES(NULL,:OLD.SH_NAME, v_user, v_date, 'Delete');

		ELSIF UPDATING THEN
			INSERT INTO sh_audit (new_name,old_name, user_name, entry_date, operation)
			VALUES(:NEW.SH_NAME, :OLD.SH_NAME, v_user, v_date,'Update');
		END IF;
	END;
	/ 

Pseudo Record ‘: NEW’, allows you to access a row currently being processed. In other words, when a row is being inserted or updated into the superheroes table. 
Whereas Pseudo Record ‘: OLD’ allows you to access a row which is already being either Updated or Deleted from the superheroes table. 


Restriction on Pseudo Record: 
	- For an INSERT trigger, OLD contain no values, and NEW contain the new values.
	- For an UPDATE trigger, OLD contain the old values, and NEW contain the new values.
	- For a DELETE trigger, OLD contain the old values, and NEW contain no values.


Part 17 - Synchronized backup copy of a table || Synchronized table backup using DML triggers.

By synchronized backup copy I mean the backup table gets automatically populated or updated with the main table simultaneously.

Create Table As :

	When writing an oracle app or sometime for testing purposes we are required to create a copy of a table. There can be several ways of accomplishing this task such 
	as – 
		- You can manually see the structure of the table using DESC command and then write a create table DML statement and create the table. 
		- You can use the Export and Import utility for creating the copy and many more.

	I say, why bear the pain of doing all these hard work and waste your precious time when you have a simple and easy-to-use tool at hand.
	Yep, you heard it right, oracle provides a simple way/command of creating a copy of a table either with the data or without the data. It is called “Create Table As” command.
	“Create Table As” is a DDL command which lets you create an exact copy of a table of your database with or without the data.


	E.g. 1: How to copy both the structure and data of a table.
	Suppose you want to make an exact copy of employees table of HR schema and by exact copy I mean copying the whole structure along with the data of employees table.
	Copying the exact structure and data of the employees table can be done by writing a very simple Create table statement. That statement will be - 

		CREATE TABLE employees_copy
		AS 
		SELECT * FROM employees;
	Successful execution of the above command will create the employees_copy which will be having the same structure and data as of the Employees table of HR schema.

	E.g. 2. How to copy specific columns of a table along with their data.
	Now suppose you want to copy only first_name, last_name or email columns with data of employees table in this case CREATE TABLE statement will be.

		CREATE TABLE employees_copy
		AS 
		SELECT first_name, last_name, email FROM employees;
	Successful execution of the above command will create the table employees_copy this time with only column first_name, last_name and email and the data.

	E.g. 3. How to copy only structure of the table without the data.
	Sometimes you might be required to copy only the structure of the table sans the data. In this case what you can do is copy the whole table as shown in above examples and then truncate it later but this will need two operations or two different commands to execute for a single task: Such a waste of time & resources when you can accomplish the same just by writing a simple “Create Table As command”.
	The Create Table command will remain the same as shown in above examples. You just need to add a where clause which will never set to be true or always false for example where clause such as ‘Cats’ = ‘Dog’ or 0=1. Let’s see how

		CREATE TABLE employees_copy
		AS 
		SELECT first_name, last_name, email FROM employees WHERE 1=0;
		
		
CREATE TABLE superheroes_backup 
AS
SELECT * FROM superheroes WHERE 1=2;

Next we have to write the trigger which will insert, update or delete the rows from the backup table when someone does the same with our main table.

	CREATE or REPLACE trigger Sh_Backup
	BEFORE INSERT OR DELETE OR UPDATE ON superheroes
	FOR EACH ROW
	ENABLE 
	BEGIN
		IF INSERTING THEN
			INSERT INTO superheroes_backup (SH_NAME) VALUES (:NEW.SH_NAME);
		ELSIF DELETING THEN
			DELETE FROM superheroes_backup WHERE SH_NAME =:old.sh_name;
		ELSIF UPDATING THEN
			UPDATE superheroes_backup
			SET SH_NAME =:new.sh_name WHERE SH_NAME =:old.sh_name;
		END IF;
	END;
	/ 


Part 18 - Schema and Database auditing.

DDL Trigger for Schema Auditing:
First you need to log on to the database using the schema which you want to audit. For example suppose you want to create the DDL trigger to audit the HR schema 
then log on to your database using the HR schema.

Using DDL triggers you can track changes to the database. We can keep on eye such as tables, triggers, index ,etc is created, altered or dropped. 

CREATE TABLE schema_audit
(
	ddl_date 	DATE,
	ddl_user 	VARCHAR2(15),
	object_created 	VARCHAR2(15),
	object_name 	VARCHAR2(15),
	ddl_operation 	VARCHAR2(15)
);	
	
	
CREATE OR REPLACE TRIGGER hr_audit_tr 
AFTER DDL ON SCHEMA			-- This will fire for all DDL. Suppose we want to fire this only for TRUNCATE DDL then replace it with - AFTER TRUNCATE ON SCHEMA
	BEGIN
	INSERT INTO schema_audit VALUES 
	(
		sysdate,
		sys_context('USERENV','CURRENT_USER'),			-- USERENV is oracle namespace of associated with current session.
		ora_dict_obj_type, 								
		ora_dict_obj_name,
		ora_sysevent
	);
	END;
	/	
	
DDL Trigger for Database Auditing:
Similar to the schema auditing with some minor changes in the above trigger you can audit your database too. But for that first you need to logon to the database 
using either SYS user or SYSTEM user. 	
	
After doing that you have to create the above shown table under the same user so that your trigger can dump the auditing data without any read and write errors. 

CREATE OR REPLACE TRIGGER db_audit_tr
AFTER DDL ON DATABASE
BEGIN
	INSERT INTO schema_audit VALUES 
	(
		sysdate,
		sys_context('USERENV','CURRENT_USER'),
		ora_dict_obj_type, 
		ora_dict_obj_name,
		ora_sysevent
	);
END;
/

If you notice the second line of this code carefully then you will find that we have replaced the keyword Schema with the keyword Database which indicates that 
this trigger will work for the whole database and will perform the underlying work. 
To create a trigger on database we require ADMINISTER DATABASE TRIGGER system privilege. All the administrative users such as sys or system already has these 
privileges by default that is the reason we created this database auditing DDL trigger using these users. Though you can create the same trigger with any user by 
granting the same privileges to them but that is not advisable because of your database security reasons.	
	
	

Part 19: Schema Level Database Logon Trigger 	
	
Database event triggers come into action when some system events occurs such as -
- database log on
- log off
- start up 
- shut down

Database event triggers can be created to monitor the system event activities of either a specific 
- user or
- a whole database

Schema Level Database Logon Trigger: 

Database event triggers also known as system event triggers come into action when some system event occurs such as database log on, log off, start up or shut down.
These types of triggers are majorly used for monitoring activity of the system events and have been proved quite a powerful tool for a DBA. 

Types of Database Event Triggers:
	- Schema Level Event Triggers
	- Database Level Event Triggers

Schema level event triggers can work on some specific schemas while the database event triggers have database wide scope. In other words database event triggers can 
be created to monitor the system event activities of either a specific user/schema or the whole database.

Object/System Privileges:
Schema level event triggers can be created by any user of your database who has CREATE TRIGGER system privilege while the database event trigger can only be 
created by privileged user such as SYS or SYSTEM who has ‘Administrative Database Trigger’ System Privileges.

Syntax
CREATE OR REPLACE TRIGGER trigger_name
BEFORE | AFTER database_event ON database/schema
	BEGIN
		L/SQL Code
	END;
/
	
Example. Schema Level Event Trigger: 
Suppose user HR is a control freak and wants to monitor its every log on and log off activity. In this case what HR can do is, create event triggers on Log on 
and log off database event in its own schema. 

Step 1: Connect to the database 
	Connect to the database using the user/schema in which you want to create the trigger. For the demonstration I will connect using my HR user.

	C:/> Conn hr/hr 

Step 2: Create a Table
	Next you will need a table to store the logon and logoff data. 

	CREATE TABLE hr_evnt_audit
	(
		event_type VARCHAR2(30),
		logon_date DATE,
		logon_time VARCHAR2(15),
		logof_date DATE,
		logof_time VARCHAR2(15)
	); 

Step3: Write the trigger Logon Schema Event Trigger.
	Now you are connected to the database using the desired user and also have the table ready to store the data. The only thing which is left is the trigger.
	This trigger will fire every time HR user logs on to the database and respective values will be stored into the table which we just created in the step 2.

	CREATE OR REPLACE TRIGGER hr_lgon_audit
	AFTER LOGON ON SCHEMA
	BEGIN
		INSERT INTO hr_evnt_audit VALUES(
			ora_sysevent,
			sysdate,
			TO_CHAR(sysdate, 'hh24:mi:ss'),
			NULL,
			NULL
		);
		COMMIT;
	END;
	/ 	
	

Part 20 - Database event 'Log Off' 
In this tutorial we will learn how to write: 
	- Schema Level Logoff System Event Trigger and
	- Database Level Logoff System Event Trigger

For this tutorial, knowledge of System/Database Event trigger is required which we have already discussed in the previous tutorial.

Unlike logon database event trigger which fires after a valid logon attempt by a user on the database, logoff triggers execute before the user logs off from the 
database. Logoff trigger can be proved as a versatile tool for a DBA as well as for a database user.

Schema Level Logoff System Event Trigger: 

	As I explained in the previous tutorial that a schema level trigger is one which worked only for a specific schema in which it is created or designed to work for. 
	Any user of the database who has “Create Trigger” system privilege can design and create this trigger. 

	Example: How To Create Schema Level Logoff event Trigger In Oracle PL/SQL
	Let’s write a trigger to audit the logoff 

	Step 1: Logon to the database
	Logon to the database using any user such as HR, SH, OE or any other you want.

		C:\> SQLPLUS hr/hr 

	Read here: how to connect to the database With Sample User (e.g. HR) using SQL Developer 

	Step 2: Create a table. 
	Create a table to dump the data generated by your schema level logoff trigger. 

		CREATE TABLE hr_evnt_audit
		(
			event_type VARCHAR2(30),
			logon_date DATE,
			logon_time VARCHAR2(15),
			logof_date DATE,
			logof_time VARCHAR2(15)
		);

	Step 3: Write the trigger.
	Below written trigger will execute every time user HR logs off from the database.

		CREATE OR REPLACE TRIGGER log_off_audit
		BEFORE LOGOFF ON SCHEMA
		BEGIN
			INSERT INTO hr_evnt_audit VALUES
			(
				ora_sysevent,
				NULL,
				NULL,
				SYSDATE,
				TO_CHAR(sysdate, 'hh24:mi:ss')
			);
			COMMIT;
		END;
		/ 

	On successful compilation this trigger will fire every time the user, using which it was created, logs off from the database and that user in our case is HR. 

	As I said above that this trigger is bound to work only for the user in which it is created. What if we want to keep track of all the logoff activities of all 
	the users of the database? In such a scenario we can write a database level system event trigger.

Database Level System/Database Event Trigger:

	An often asked question in the interview is what are the differences between Schema Level and Database Level system Event triggers? There can be variety of answers 
	for this question but major differences are as follows -
		As the name suggests Database event trigger fires for the entire database or you can say that it fires for all the schemas created under the database in which 
		these triggers are created which is unlike Schema Level System Event trigger which runs for a specific schema only. 

		Also database level system event trigger can only be created by high privileged users such as sys or system or any user who has ADMINISTER DATABASE TRIGGER system 
		privilege where Schema level system event trigger can be created by any user of the database on its own schema which has Create Trigger System Privilege.

	Example: How To Create Database Level Logoff event Trigger In Oracle PL/SQL
	Creation process of Database Level Logoff Event Trigger is pretty similar to the trigger which we just saw except for a few minute changes.

	Step 1: Logon to the database 
	As only the user with ADMINISTER DATABASE TRIGGER system privilege can create a database level event trigger thus we need to make sure that this time we should 
	log on to the database using one of these users.

	C:\> SQLPLUS / as SYSDBA 

	Step 2: Create a Table
	Again in order to store the audit data we need to create a table where this trigger will journal the entries of all the users. The structure of the table will be 
	pretty similar to the above one except one extra column for storing the username with the help of which we can clearly identify the details and avoid the confusion.

		CREATE TABLE db_evnt_audit
		(
			User_name VARCHAR2(15),
			event_type VARCHAR2(30),
			logon_date DATE,
			logon_time VARCHAR2(15),
			logof_date DATE,
			logof_time VARCHAR2(15)
		);

	Step 3: Write the Database Level logoff system event trigger.
	Following Trigger will keep an eye on the logoff activity of the user of the database.

		CREATE OR REPLACE TRIGGER db_lgof_audit
		BEFORE LOGOFF ON DATABASE
		BEGIN
		INSERT INTO db_evnt_audit 
		VALUES
		(
			user,
			ora_sysevent,
			NULL,
			NULL,
			SYSDATE,
			TO_CHAR(sysdate, 'hh24:mi:ss')
		);
		END;
		/

	Code is very similar to the previous one except that this time this trigger will execute for all the users of the database. This we are making sure by using the 
	keyword DATABASE instead of SCHEMA in the second line of the trigger unlike the previous trigger.
		
	
Part 21 : Startup and Shutdown Database event trigger

Startup Trigger :
	Startup triggers execute during the startup process of the database. In order to create a database event trigger for shutdown and startup events 
	we either need to logon to the database as a user with DBA privileges such as sys or we must possess the ADMINISTER DATABASE TRIGGER system privilege.

Examples :

	Step1: Logon to the database
	In order to create a trigger on Startup Database Event first we will have to logon to our database using the user SYS with DBA privileges.

	Step 2: Create a Table 
	To store the data generated by the execution of trigger we will require a table. 

	CREATE TABLE startup_audit 
	(
		Event_type VARCHAR2(15),
		event_date DATE,
		event_time VARCHAR2(15)
	);

	Step 3: Create the database Event Startup Trigger
	In this step we will create a trigger which will execute every time the database in which it is created starts up.

	CREATE OR REPLACE TRIGGER startup_audit
	AFTER STARTUP ON DATABASE
	BEGIN
		INSERT INTO startup_audit VALUES
		(
			ora_sysevent,
			SYSDATE,
			TO_CHAR(sysdate, 'hh24:mm:ss')
		);
	END;
	/ 

	On successful execution this trigger will insert a row of data each time database starts up.

Shutdown Triggers:
	SHUTDOWN triggers execute before database shutdown processing is performed. Similar to the startup trigger, only a user with DBA role or ADMINISTER DATABASE 
	TRIGGER system privilege can create a shutdown trigger.

Example :
	First 2 steps of creating a database event shutdown triggers are same as that of the startup trigger which we saw above.

	CREATE OR REPLACE TRIGGER tr_shutdown_audit
	BEFORE SHUTDOWN ON DATABASE
	BEGIN
		INSERT INTO startup_audit VALUES
		(
			ora_sysevent,
			SYSDATE,
			TO_CHAR(sysdate, 'hh24:mm:ss')
		);
	END;
	/

	Table used in this trigger is the same one which we created during the coding of the Startup trigger above.

SHUTDOWN triggers execute only when the database is shut down using NORMAL or IMMEDIATE mode. They do not execute when the database is shut down using ABORT mode 
or when the database crashes.

You can also use shutdown database event triggers for gathering your database system statistics. Here is an example - 

	CREATE OR REPLACE TRIGGER before_shutdown
	BEFORE SHUTDOWN ON DATABASE
	BEGIN
		gather_system_stats;
	END;
	/
	

Part 22: Instead of Insert trigger.

Instead Of Trigger : 
	Instead-of triggers in oracle database provide a way of modifying views that cannot be modified directly through the DML statements. By using Instead-of 
	triggers, you can perform Insert, Update, Delete and Merge operations on a view in oracle database.

Restriction on Instead-of View :
	Instead-of triggers can control Insert, Delete, Update and Merge operations of the View, not the table. Yes you heard it right, you can write an instead-of 
	trigger on Views only and not on tables in Oracle database. That is the restriction that you have to comply with. Along with this you even have to comply 
	with every general restriction that is imposed on all types of triggers. We have discussed those in the Introduction of triggers section.

Uses of Instead-of trigger :
	Since an Instead-of trigger can only be used with views therefore we can use them to make a non-updatable view updatable as well as to override the default 
	behavior of views that are updatable. 

Syntax of instead-of trigger :
	CREATE [OR REPLACE] TRIGGER trigger_name
	INSTEAD OF operation
	ON view_name
	FOR EACH ROW
	BEGIN
			---Your SQL Code—
	END;
	/ 

So you asked…
When does an Instead-of trigger fires – Before or After the triggering event?
	If you noticed carefully then you’ll see that we do not have either BEFORE or AFTER clause in the syntax. This is because unlike other triggers, instead-of
	trigger executes neither BEFORE nor AFTER but instead of a triggering event. That is why we do not need to specify either BEFORE or AFTER clause.

Examples :
Instead-of Insert Trigger:
	Instead-of trigger can be best demonstrated using a View joining two or more tables. Thus in this example I will create two simple tables and will then create 
	a view over them. After that I will create an Instead of trigger for Insert operation on this view.

	Step1: Create Tables - 
	Table 1- trainer
		CREATE TABLE trainer
		( 
			full_name VARCHAR2(20)
		);
	
	Table 2- Subject - 
		CREATE TABLE subject
		( 
			subject_name VARCHAR2(15)
		);

	Insert dummy data into the above tables - 
		INSERT INTO trainer VALUES ('Manish Sharma');
		INSERT INTO subject VALUES ('Oracle');

	Step 2: Create View - 
		In this step I will create a view which will show you the combined result of the data from the two tables above.

		CREATE VIEW vw_rebellionrider AS
		SELECT full_name, subject_name FROM trainer, subject;
	
		This is a non-updatable view which you can confirm by executing any DML statement over it. Error as a result of DML operation on this view will be your 
		confirmation.

	Step 3: Create Instead-of Insert Trigger - 
		Next I will create an Instead-of Insert trigger over the view vw_rebellionrider that we created in step 2. 

		CREATE OR REPLACE TRIGGER tr_Io_Insert
		INSTEAD OF INSERT ON vw_rebellionrider
		FOR EACH ROW
		BEGIN
			INSERT INTO trainer (full_name) VALUES (:new.full_name);
			INSERT INTO subject (subject_name) VALUES (:new.subject_name);
		END;
		/ 

	On successful execution, this trigger will insert a new row of data into both the underlying tables of the view vw_rebellionrider. You can confirm that by 
	executing an insert DML over the view.
	
	Insert into vm_RebellionRider values('Manish', 'Java');
	

Part 23 - Instead of Update trigger.

Instead-oF UPDATE Trigger : 
	Similar to Instead-of Insert trigger, Instead-of Update trigger overrides default behavior of Update DML operation executed on the view. Execution of Update 
	DML on a complex view is restricted because of the involvement of multiple tables over which your view is created. To override this restriction we can take 
	the help of Instead-Of Update trigger.

Instead-Of Update Trigger : 
	Instead-of update trigger will override the default behavior of your update operation when you execute the update statement and will let you update the data 
	of the underlying tables over which your view is created.

Instead-Of Update trigger Examples :
	Tables (Trainer and Subject) and View (VW_RebellionRider) used in this example are the same as the ones we created in the previous tutorial. 

	CREATE OR REPLACE TRIGGER io_update
	INSTEAD OF UPDATE ON vw_rebellionrider
	FOR EACH ROW
	BEGIN
		UPDATE trainer SET FULL_NAME = :new.full_name 
		WHERE FULL_NAME = :old.full_name;

		UPDATE subject SET subject_NAME = :new.subject_name 
		WHERE subject_NAME = :old.subject_name;
	END;
	/

	On successful execution this trigger will let you execute an Update DML on the view. 
	
		Update vm_RebellionRider set full_name = 'Tony Stark' where subject_name = 'Java';

		
Part 24 - Instead of Delete Trigger.		

Main purpose of Instead of triggers are to update the views which are non-updatable. 

In case of a Complex View which you have created on multiple tables, it is advisable to use Instead-of trigger so as to support the insert, delete and update
that reference the data in multiple tables.	

Instead-oF DELETE Trigger :
	Similar to other instead-of triggers which we have seen in previous tutorial, using INSTEAD-OF DELETE we can override the standard action of Delete DML on a 
	view. 

Instead-of Delete trigger Example:
	In this example I will again use the View VW_RebellionRider which we created earlier and have consistently used in this Instead-of trigger series so far.

Needless to say that executing DELETE DML on this view will return an error because of its non-updatable nature. Thus the only way to perform DELETE DML on 
this view is by using an Instead of trigger. Let’s quickly create one - 

	CREATE OR REPLACE TRIGGER io_delete
	INSTEAD OF DELETE ON vw_RebellionRider
	FOR EACH ROW
	BEGIN
		DELETE FROM trainer WHERE FULL_NAME = :old.FULL_NAME;
		DELETE FROM subject WHERE SUBJECT_NAME= :old.SUBJECT_NAME;
	END;
	/
On successful execution this trigger will allow you to execute DELETE DML on the view. 



Part 25 - Uninstall Oracle 11g From Windows 10 64 Bit Manually

http://www.rebellionrider.com/oracle-sql-concepts/how-to-uninstall-oracle-database-11g-from-windows-10-by-manish-sharma.htm#.W861NvZuJPZ



Part 26 - Database Cursors

PL/SQL Cursors in Oracle Database :

What is Database Cursor?
	Cursor is a pointer to a memory area called context area. This context area is a memory region inside the Process Global Area or PGA assigned to hold the 
	information about the processing of a SELECT statement or DML Statement such as INSERT, DELETE, UPDATE or MERGE.

A quick tip:
	Refrain from saying that cursor is a pointer to the data stored in the database. Saying this in your interview will definitely put you in an indefinite queue 
	of candidates who never receive a call back. Because cursor is the pointer to the memory area called context area not to the data of the database. 

What is the Context Area?
	The context area is a special memory region inside the Process Global Area or PGA which helps oracle server in processing an SQL statement by holding the 
	important information about that statement.

	This information includes:
	- Rows returned by a query.
	- Number of rows processed by a query.
	- A pointer to the parsed query in the shared pool.
	- Using cursor you can control the context area as it is a pointer to the same.

A quick tip:
	Parsing an SQL statement is the term used for the process that includes the transferring of information to the server, whereby the SQL statement is evaluated 
	as being valid. 

Advantages of Cursors
	There are two main advantages of a cursor:
	- Cursor is names thus you can reference it in your program whenever you want.
	- Cursor allows you to fetch and process rows returned by a SELECT statement by a row at a time.

Types of cursors in oracle database:
	There are two types of cursors in oracle database:
	- Implicit cursor
	- Explicit cursor

Implicit Cursors in Oracle Database : 
	As the name suggests these are the cursors which are automatically created by the oracle server every time an SQL DML statement is executed. User cannot 
	control the behavior of these cursors. Oracle server creates an implicit cursor in the background for any PL/SQL block which executes an SQL statement as long 
	as an explicit cursor does not exist for that SQL statement. 

	Oracle server associates a cursor with every DML statement. Each of the Update & Delete statements has cursors which are responsible to identify those set of 
	rows that are affected by the operation. Also the implicit cursor fulfills the need of a place for an Insert statement to receive the data that is to be 
	inserted into the database. 

	Info Byte:
	The Most recently opened cursor is called SQL Cursor. 

Explicit Cursor in oracle database : 
	In contrast to implicit cursors, we have explicit cursors. Explicit cursors are user defined cursors which means user has to create these cursors for any 
	statement which returns more than one row of data. Unlike implicit cursor user has full control of explicit cursor. An explicit cursor can be generated only 
	by naming the cursor in the declaration section of the PL/SQL block.

Advantages of Explicit Cursor:
	- Since Explicit cursors are user defined hence they give you more programmatic control on your program.
	- Explicit cursors are more efficient as compared to implicit cursors as in latters case it is hard to track data errors. 

Steps for creating an Explicit Cursor : 
	To create an explicit cursor you need to follow 4 steps. These 4 steps are:
	- Declare
	- Open
	- Fetch
	- Close

	In case of implicit cursors oracle server performs all these steps automatically for you.

	Info Byte:
	Unless the complete cycle of declaring, opening, fetching and closing has been performed, you can’t use a cursor. 

	Declare: How To Declare a Database Cursor?
		Declaring a cursor means initializing a cursor into memory. You define explicit cursor in declaration section of your PL/SQL block and associate it 
		with the SELECT statement.

	Syntax:
		CURSOR cursor_name IS select_statement; 

	Open: How to Open a Database Cursor?
		Whenever oracle server comes across an ‘Open Cursor’ Statement the following four steps take place automatically - 
		- All the variables including bind variables in the WHERE clause of a SELECT statement are examined.
		- Based on the values of the variables, the active set is determined, and the PL/SQL engine executes the query for that cursor. Variables are examined 
			at cursor open time.
		- The PL/SQL engine identifies the active set of data.
		- The active set pointer sets to the first row.

		Active set: Rows from all the involved tables that meet the WHERE clause criteria. 
	
	Syntax :
		OPEN cursor_name; 

	Fetch: How to retrieve data from cursor?
		The process of retrieving the data from the cursor is called fetching. Once the cursor is declared and opened then you can retrieve the data from it. 
		
	Syntax :
		FETCH cursor_name INTO PL/SQL variable;
		Or 
		FETCH cursor_name INTO PL/SQL record;

	What happens when you execute fetch command of a cursor?
		The use of a FETCH command is to retrieve one row at a time from the active set. This is usually done inside a loop. The values of each row in the 
		active set can then be stored in the corresponding variables or PL/SQL record one at a time, performing operations on each one successively.
		After completion of each FETCH, the active set pointer is moved forward to the next row. Therefore, each FETCH returns successive rows of the active set, 
		until the entire set is returned. The last FETCH does not assign values to the output variables as they still contain their previous values.

	Close: How To Close a Database Cursor?
		Once you are done working with your cursor it’s advisable to close it. As soon as the server comes across the closing statement of a cursor it will 
		relinquish all the resources associated with it.

	Syntax : 
		CLOSE cursor_name; 

	Info Byte:
		You can no longer fetch from a cursor once it’s closed. Similarly it is impossible to close a cursor once it is already closed. Either of these actions 
		will result in an Oracle error. 

Here is the basic programming structure of the cursor in oracle database - 

	DECLARE
		CURSOR cursor_name IS select_statement; 
	BEGIN
		OPEN cursor_name;
		FETCH cursor_name INTO PL/SQL variable [PL/SQL record]; 
		CLOSE cursor_name; 
	END;
	/


Cursor Attributes - 
	Oracle provides six attributes which work in correlation with cursors. These attributes are: 
	1. %FOUND
	2. %NOTFOUND
	3. %ISOPEN
	4. %ROWCOUNT 
	5. %BULK_ROWCOUNT
	6. %BULK_EXCEPTIONS

	First three attributes ‘Found’, ‘NotFound’ and ‘IsOpen’ are Boolean attributes whereas the last one ‘RowCount’ is a numeric attribute.

	1. %Found
		Cursor attribute ‘Found’ is a Boolean attribute which returns TRUE if the previous FETCH command returned a row otherwise it returns FALSE.

	2. %NotFound
		‘Not Found’ cursor attribute is also a Boolean attribute which returns TRUE only when previous FETCH command of the cursor did not return a row 
		otherwise this attribute will return FALSE.

	3. %IsOpen
		Again ‘Is Open’ Cursor attribute is a Boolean attribute which you can use to check whether your cursor is open or not. It returns TRUE if the cursor is 
		open otherwise it returns FALSE. 

	4. %RowCount
		Row count cursor attribute is a numeric attribute which means it returns a numeric value as a result and that value will be the number of records fetched 
		from a cursor at that point in time.

	5. %BULK_ROWCOUNT
		'Bulk RowCount' cursor attribute Returns the number of records modified by the FORALL statement for each collection element.

	6. %BULK_EXCEPTIONS
		Similar to 'Bulk RowCount' the 'Bulk EXCEPTIONS' cursor attribute Returns exception information for rows modified by the FORALL statement for each 
		collection element.



Part 27 - Create Explicit Cursor In Oracle Database

Cursor is a pointer to a memory area called context area.
As we have already learnt that whenever we execute a DML statement, the oracle server creates an implicit cursor in the background. As these cursors are created 
by oracle server itself thus user does not have much programmatic control on them. In case if you want to control your own DMLs then you need to write an explicit 
cursor. 

So let’s quickly see how you can create your own database cursor in oracle database - 

	SET SERVEROUTPUT ON;
	DECLARE
		v_name VARCHAR2(30);
		--Declare Cursor 
		CURSOR  cur_RebellionRider  IS 
		SELECT  first_name  FROM  EMPLOYEES 
		WHERE  employee_id  <  105;
	BEGIN
		OPEN cur_RebellionRider; 
		LOOP 
			FETCH cur_RebellionRider INTO v_name; 
			DBMS_OUTPUT.PUT_LINE (v_name); 
			EXIT WHEN cur_RebellionRider%NOTFOUND; 
		END LOOP;--Simple Loop End
		CLOSE cur_RebellionRider;
	END;
	/ 		
			

Part 28 - Parameterized Cursor In Oracle Database

No doubt that explicit cursor has certain advantages over implicit cursor and can increase the efficiency of DML statements by giving more programmatic controls 
in user’s hands. Now let’s take a step ahead and learn how to create a parameterized explicit cursor a.k.a. cursor parameter.

What is Parameterized cursor?
	Unlike simple explicit cursor, parameterized cursors accept values as parameter. You specify the list of parameters separated by comma (,) while declaring 
	the cursor and supply the corresponding argument for each parameter in the list while opening the cursor.

Definition:
	Cursor parameter can be appropriately defined as an explicit cursor that accepts arguments from the user in the form of parameter. 

Syntax of Parameterized Cursor in Oracle Database : 
	CURSOR cur _ name (parameter list) IS SELECT statement; 

	Syntax of declaring a cursor parameter is pretty similar to that of the simple cursor except the addition of parameters enclosed in the parenthesis. 

	OPEN cur _ name (argument list) 
	
	You have to provide corresponding arguments for each parameter that are specified during the declaration. Rest of the steps are the same as that of the 
	simple cursor. 


There are few things which you have to take care of while specifying the parameters in your explicit cursor - 
- In case of multiple parameters, always separate parameters and the corresponding arguments in the list from each other using comma (,).
- You can specify as many parameters as you need just make sure to include an argument in parameter list for each parameter when you open the cursor. 
- While specifying a parameter during the declaration of the explicit cursor only specify the data type not the data width.

Some Wonderful Advantages of Parameterized Cursors - 
- Makes the cursor more reusable
- You can use a parameter and then pass different values to the WHERE clause each time a cursor is opened instead of hardcoding a value into the WHERE clause of 
	a query to select particular information. 
- Avoids scoping problems
- When you pass parameters instead of hardcoding the values, the result set for that cursor is not tied to a specific variable in a program or block. 
	Therefore in case your program has nested blocks, you can define the cursor at a higher-level (enclosing) block and use it in any of the sub-blocks with 
	variables defined in those local blocks. 

When do we need a parameterized cursor?
You must be wondering when we need a cursor with parameters in our PL/SQL. The simplest answer is whenever you need to use your cursor in more than one place with 
different values for the same WHERE clause of your SELECT statement. 

Example of Parameterized cursor - 
	
	SET SERVEROUTPUT ON;
	DECLARE
		v_name VARCHAR2 (30);
		--Declare Cursor 
		CURSOR p_cur_RebellionRider (var_e_id VARCHAR2) IS 
		SELECT first_name FROM EMPLOYEES 
		WHERE employee_id < var_e_id;
	BEGIN
		OPEN p_cur_RebellionRider (105); 
	LOOP 
		FETCH p_cur_RebellionRider INTO v_name; 
		EXIT WHEN p_cur_RebellionRider%NOTFOUND; 
		DBMS_OUTPUT.PUT_LINE(v_name ); 
	END LOOP;
	CLOSE p_cur_RebellionRider;
	END;
	/


Part 29 - Parameterized Cursor With Default Value In Oracle Database

Every cursor parameter has some restrictions which we have to comply with for example we have to specify the argument for each parameter when we open the cursor 
otherwise we get a PLS 00306 error.
To overcome this restriction, we have the option called default value. Default value is the value which you assign to the parameter of your cursor during the 
declaration of the cursor. 

Example 1 of Cursor Parameter with Default Value :

	SET SERVEROUTPUT ON;
	DECLARE
		v_name VARCHAR2(30);
		v_eid NUMBER(10);
		CURSOR cur_RebellionRider(var_e_id NUMBER := 190 )
		IS
		SELECT first_name, employee_id FROM employees 
		WHERE employee_id > var_e_id; 
	BEGIN
		OPEN cur_rebellionrider;
		LOOP
			FETCH cur_rebellionrider INTO v_name, v_eid; 
			EXIT WHEN cur_rebellionrider%NOTFOUND;
			DBMS_OUTPUT.PUT_LINE(v_name ||' '||v_eid); 
		END LOOP;
		CLOSE cur_rebellionrider;
	END;

As you can see in the above code I assigned a value (which is 190) using assignment operator to the parameter var_e_id in the cursor declaration and nothing while 
opening the cursor. Upon the execution this PL/SQL block will show you the first name and employee id of all the employees who have employee id greater than 190. 

Default Value Is Not a Substitute Value : 
	Default value is not a substitute value for the parameter of your cursor. It comes into action only when the user does not specify the argument for the 
	parameter while opening the cursor. In case user has supplied the argument for the parameter in OPEN CURSOR statement then the compiler will show the result 
	according to that parameter and not according to the Default value.

Example 2 of Cursor Parameter with Default Value : 

	DECLARE
		v_name VARCHAR2(30);
		v_eid NUMBER(10);
		CURSOR cur_RebellionRider(var_e_id NUMBER := 190 )
		IS
		SELECT first_name, employee_id FROM employees 
		WHERE employee_id > var_e_id; 
	BEGIN
		OPEN cur_rebellionrider (200);
		LOOP
			FETCH cur_rebellionrider INTO v_name, v_eid; 
			EXIT WHEN cur_rebellionrider%NOTFOUND;
			DBMS_OUTPUT.PUT_LINE(v_name ||' '||v_eid); 
		END LOOP;
		CLOSE cur_rebellionrider;
	END;

If you compare the result of both the codes demonstrated in the above examples you will see the difference because the result returned by Example 1 is according 
to the default value (which is 190) which you specified during the declaration while the result returned by Example 2 will be according to the argument 
(which is 200) you have specified in the OPEN cursor statement.

Use of Default Value in Cursor Parameter :
	Specifying the default value for the parameter of your cursor can increase the efficiency of your app or code by minimizing the chances of PLS 00306 error.
	
	
Part 30 - Cursor For Loop In Oracle Database

As the name suggests Cursor For Loop is a type of For loop provided by oracle PL/SQL which makes working with cursors in oracle database a lot easier by executing 
OPEN, FETCH & CLOSE Cursor statements implicitly in the background for you.

Definition:
	Cursor for Loop Is an Extension of the Numeric For Loop provided by Oracle PL/SQL which works on specified cursors and performs OPEN, FETCH & CLOSE cursor 
	statements implicitly in the background. 

Syntax of Cursor For Loop :

	FOR loop_index IN cursor_name 
	LOOP
		Statements…
	END LOOP;

Example 1: Cursor For Loop With Simple Explicit Cursor :

	SET SERVEROUTPUT ON;
	DECLARE
		CURSOR cur_RebellionRider IS 
		SELECT first_name, last_name FROM employees
		WHERE employee_id >200;
	BEGIN
		FOR L_IDX IN cur_RebellionRider
		LOOP
			DBMS_OUTPUT.PUT_LINE(L_IDX.first_name||' '||L_IDX.last_name);
		END LOOP;
	END;
	/

Example 2: Cursor For Loop With Inline Cursor :
	You can pass the cursor definition directly into the Cursor For Loop. The code for that is:

	SET SERVEROUTPUT ON;
	BEGIN
		FOR L_IDX IN (SELECT first_name, last_name FROM employees
		WHERE employee_id >200)
		LOOP
			DBMS_OUTPUT.PUT_LINE (L_IDX.first_name||' '||L_IDX.last_name);
		END LOOP;
	END;
	/

As you can see in the above code, instead of declaring a cursor into a separate declaration section of PL/SQL block we can write the Cursor’s SELECT DML statement 
right inside the loop statement after IN keyword.

Just remember:
- Directly write the SELECT statement without specifying the cursor name into the loop statement.
- Enclose the SELECT statement into parenthesis. 
- Do not terminate the SELECT statement with a semicolon (;)

How many times will Cursor For Loop execute?
Unlike Numeric For Loop with Cursor For Loop we don’t have minimum or maximum range which will decide the number of execution. So how many times will this loop 
execute?
This loop will execute for each row returned by the specified cursor and it will terminate either when there is no row to return or there is an occurrence of 
an exception.
	
	
Part 31 - Cursor For Loop With Parameterized Cursor.

Example1. Cursor For Loop With Parameterized Cursor : 

	SET SERVEROUTPUT ON;
	DECLARE
		CURSOR cur_RebellionRider( var_e_id NUMBER) IS 
		SELECT first_name, employee_id FROM employees
		WHERE employee_id > var_e_id;
	BEGIN
		FOR l_idx IN cur_RebellionRider(200)
		LOOP
			DBMS_OUTPUT.PUT_LINE(l_idx.employee_id||' '||l_idx.first_name);
		END LOOP;
	END;

You can pass the values for the parameters of your cursor just by simply writing the argument right after the name of your cursor in loop statement as shown in 
the above example. Always remember to enclose the arguments inside the parenthesis.	
	
	
	
Part 32 - Records In Oracle Database 

What is a Record in Oracle Database?
	Records are composite data structures made up of different components called fields. These fields can have different data types. This means that you can store 
	data of different data types in a single record variable. Similar to the way we define columns in a row of a table. 

Definition - 
	A record is a group of related data items stored in fields, each with its own name and datatype. 

Types of Record datatype in Oracle database - 
In Oracle PL/SQL we have three types of Record datatype :
- Table Based Record 
- Cursor Based Record, and 
- User Defined Record.

How to declare a Record Datatype in Oracle Database. (%ROWTYPE attribute.) - 
	Similar to %TYPE which is for declaring an anchored datatype variable, Oracle PL/SQL provides us an attribute %ROWTYPE for declaring a variable with record 
	datatype. 

Syntax of Record Datatype :
	Table Based Record - 

	Variable_ name table_name%ROWTYPE; 
	
	Variable Name: A user defined name given to the variable. You have to specify the name of the variable which could be anything. But you have to follow the 
		oracle guidelines for variable name.

	Table Name: Table name will be the name of the table over which the record datatype is created. This table will serve as the base table for the record. 
	Also the Oracle Server will then create corresponding fields in the record that will have the same name as that of a column in the table.

	%ROWTYPE: Attribute which indicates the compiler that the variable which is declared is of Record Type.

	Cursor based Record - 
	
	Variable_ name cursor_name%ROWTYPE; 
	
The syntax of cursor based record is pretty similar to the one which we just saw. You just have to specify the name of the cursor in place of table name, 
rest of the things remain same.

How to access data stored is Record Type Variable -
	Whenever you create a record based on a table, oracle server will create fields corresponding to each column of the table and all those fields have the same 
	name as a column in the table. That makes referencing or accessing data from the record much easier. Here is how you access data from record variable.

	Record_variable_name.column_name_of_the_table; 
	
	Using dot (.) notation you can access the data stored into the field of the record.	
	
	

Part 33 - Table based record type variable.

In the previous tutorial we learnt that the record datatype variables are composite data structures made up of different components called fields that have the 
same name and data types as that of the columns of a table using which you created that record. There we saw that there are three types of record variables 
available in Oracle Database. In this tutorial we will concentrate on the first type of record variable which is “Table Based Record Datatypes” Variables.

What are Table Based Record Datatype Variables?
	As the name suggests Table Based Record Datatype Variables are variable of record datatype created over a table of your database. 

	Whenever you declare a record type variable oracle engine will declare a composite data structure with fields corresponding to each column of the specified table. 
	For example if we have a record variable created using Employees table then that variable has 11 fields corresponding to 11 columns of the employees table. 
	Also all these fields have the same name, data type and data width as that of the columns of the table. 

How to Declare a Table Based Record Datatype Variables in Oracle Database?
	The declaration of a table based record datatype variables is very similar to the declaration of simple user variables. 

For example - 

	SET SERVEROUTPUT ON;
	DECLARE
		v_emp employees%ROWTYPE;

	That is the declaration section of an anonymous PL/SQL block where we declared a record type variable with the name v_emp. V_emp record variable is based on 
	employees table of the HR sample user. As this record variable is based on “employee” table of HR sample user thus it will have 11 fields corresponding to the 
	11 columns of the employees table.

How to Initialize Record Datatype Variables in Oracle Database?
	In Oracle Database a record data type variable can be initialized by multiple ways similar to the simple user variables which we have seen in PL/SQL tutorial 2. 
	However in this tutorial we will focus on the three most common ways of initializing a Record type variable. These are:
		- By fetching data from all the columns of a row of a table into the record variable using SELECT-INTO statement.
		- By fetching data from selected columns of the table into the record variable using SELECT-INTO statement. 
		- By directly assigning the value into the record variable using assignment operator.
	In this tutorial we will focus on the first way of initializing database records which is by Fetching data from all the columns of a row of a table.

Initialize Record Variable by Fetching Data from All the Columns (SELECT-INTO Statement) : 
	We already know that whenever you declare a record type variable oracle engine will declare a composite data structure with fields corresponding to each column 
	of the specified table. We can initialize all these fields by fetching the data from all the columns of a row of the table using SELECT-INTO statement.

	SELECT * INTO v_emp FROM employees
	WHERE employee_id = 100; 

	As we are talking about fetching data from all the columns thus we are using the SELECT asterisk (*) statement and storing the data into our record variable 
	V_EMP. 

Take a note here that a table based record variable can hold data of a single row at a time, thus you have to make sure that the SELECT-INTO statement returns the 
data from one row only and for that you can filter the data using WHERE clause, as we did in the above statement.

Till so far we have learnt how to Declare and Initialize a database record type variable, next we will see how to access data from the record data type variable 
in Oracle Database.

How to access data from the record datatype variables in Oracle Database?
	In order to access the data stored into a record variable we use the dot (.) notation. In which we first write the name of our record variable followed by a 
	dot (.) and then the name of the field (or the name of the column) as both fields of a Table based Record Type variable and the column of the table over which 
	the record variable is declared share the same name whose data we want to retrieve.

	DBMS_OUTPUT.PUT_LINE (v_emp.first_name ||' '||v_emp.salary); 

	Now that we have learnt how to Declare and Initialize table based record type variables in Oracle Database. Now let’s put together all these pieces into a 
	single PL/SQL block

Example: Table based record type variable initialization with SELECT asterisk (*) statement. 
	SET SERVEROUTPUT ON;
	DECLARE
		v_emp employees%ROWTYPE;
	BEGIN
		SELECT * INTO v_emp FROM employees
		WHERE employee_id = 100;
		DBMS_OUTPUT.PUT_LINE (v_emp.first_name ||' '||v_emp.salary);
		DBMS_OUTPUT.PUT_LINE(v_emp.hire_date);
	END;
	/ 
	

Part 34 - How to Initialize Table Based Record Type Variables 

In the previous tutorial we saw, how to initialize a record variable by fetching data from all the columns of a table using SELECT-INTO statement. But what 
if we want to fetch the data from selected columns of a table? Can we still use the same process for initializing the record variable? 
The answer is No, we cannot use the same process shown in the previous tutorial for initializing a record datatype variable by fetching data from select columns 
of a table. The execution of the following example where we are using the data from one column “First Name” of the “Employees” table for initializing the record 
datatype variable “v_emp” will return an error. 

	SET SERVEROUTPUT ON;
	DECLARE
		v_emp employees%ROWTYPE;
	BEGIN
		SELECT first_name INTO v_emp FROM employees
		WHERE employee_id = 100;
		DBMS_OUTPUT.PUT_LINE(v_emp.first_name);
	END;
	/ 

That error is “PL/SQL: ORA-00913: too many values” So what does this error means? Why is it saying “too many values” even when we are fetching only one data. I 
know sometimes PL/SQL error can be deceptive and confusing. 

In order to find out the solution of this problem and understand this error we have to recall what we learnt in the previous tutorial. There we learnt that 
Database Records are composite data structures made up of multiple fields which share same name, datatype and data width as that of the columns of the table over 
which it is created. And the data which was fetched gets stored into these fields.

In case of initializing a record variable by fetching data from all the columns of a table, we don’t have to do anything, oracle engine does all the dirty work in 
the background for you. It first fetches the data from the table and then stores that data into the corresponding field into the record which has the same data type 
and data width, and for that matter also shares the same name. 
But when it comes to initializing a record datatype variable by fetching the data from selected columns we have to do all this work manually. We have to specify 
the name of the column from which we want to fetch the data and then we have to specify the name of the field where we want to store that data. 

In the above example we did specify the column name of the table whose data we want to fetch but we didn’t specify the name of the record’s field where we want to 
store the fetched data. That confuses the compiler on where to store the data which ultimately causes the error. 

How to Solve “PL/SQL ORA-00913: Too Many Values” Error?
The PL/SQL ORA-00913 error can easily be solved by specifying the record’s field name where you want the fetched data to be stored. But here you have to be a bit 
careful. You have to make sure that the field’s datatype and data width must match with the datatype and data width of the column whose data you have fetched.

Now the question here is that how to specify the record data type field’s name? We can specify the name of the field of the record variable using Dot (.) notation 
where we first write the name of the already declared record variable followed by a dot (.) and the name of the field. And luckily both the columns of the table 
and fields of the record share the same name.

So now that we have learnt why we are having PL/SQL ORA-00913 error on initializing the record data type variable using data from select columns. 
Let’s modify the above example accordingly and try to resolve it.

Example 1: Initialize the Record Datatype variable using data from One Column.

	SET SERVEROUTPUT ON;
	DECLARE
		v_emp employees%ROWTYPE;
	BEGIN
		SELECT first_name INTO v_emp.first_name FROM employees
		WHERE employee_id = 100;
		DBMS_OUTPUT.PUT_LINE (v_emp.first_name);
	END;
	/

Example 2: Initialize the Record Datatype variable using data from Multiple Columns.

	SET SERVEROUTPUT ON;
	DECLARE
		v_emp employees%ROWTYPE;
	BEGIN
		SELECT first_name, hire_date INTO v_emp.first_name, v_emp.hire_date
		FROM employees WHERE employee_id = 100;
		DBMS_OUTPUT.PUT_LINE (v_emp.first_name);
		DBMS_OUTPUT.PUT_LINE (v_emp.hire_date);
	END;
	/

That is how we can initialize a record datatype variable using data from selected columns of a table. 

Question: Can we assign values of one record datatype variable to another record datatype variable?
Try it yourself and send your answers to me on my Twitter or Facebook. 	
	
	

Part 35 - Cursor Based Records in Oracle

What are Cursor Based Records in Oracle Database?
	Cursor based records are those variables whose structure is derived from the SELECT list of an already created cursor. As we know that record datatypes are 
	composite data structures made up of multiple fields and in the case of Cursor based record these fields are initialized by fetching data from the SELECT-LIST 
	of the cursor that was used to create this variable

How To Create Cursor Based Record In Oracle Database?
	The creation of cursor based record variable involves:
	- Declaration of Cursor based Record.
	- Initialization of Cursor Based Record and 
	- Accessing the data stored into the cursor based record variable.

Declare Cursor Based Record In Oracle Database : 
	As it is obvious that in order to declare a Cursor Based Record we need to have a Cursor over which we can design our Record variable. 
	
	SET SERVEROUTPUT ON;
	DECLARE
	CURSOR  cur_RebellionRider  IS
	SELECT first_name, salary FROM employees 
	WHERE employee_id = 100;

	Once you have created your cursor then you are all set to declare your Cursor based Record variable. 
		var_emp cur_RebellionRider%ROWTYPE; 
		
	Declaration of Cursor Based Record is pretty much similar to the declaration of table based record. The declaration starts with the name of the record variable,
	which is completely user defined followed by the name of an already created cursor. And at the end “%ROWTYPE” attribute which indicates that we are declaring 
	a Record Datatype variable to the compiler. 

Initialize Cursor Based Record Datatype : 
	Once you have successfully declared your record datatype variable next you have to initialize it.
	Though the initializing process of cursor based record is very simple and pretty much similar to the one we have seen in the previous tutorial on 
	“Table Based Record” but unlike table records here we are initializing a record variable which is based on a cursor thus we have to make sure that we 
	should follow the cursor cycle properly.

	BEGIN
		OPEN cur_RebellionRider;
		FETCH cur_RebellionRider INTO var_emp;

	Every cursor needs to be opened before being used. Thus here we first opened the cursor and then using FETCH-INTO statement we fetched the data into the 
	record variable “var_emp”.

Access data from the cursor based record : 
	After Declaration and Initialization of cursor based record the thing which we have to learn is How to access data from the cursor based record?

	DBMS_OUTPUT.PUT_LINE (var_emp.first_name);
	DBMS_OUTPUT.PUT_LINE (var_emp.salary); 

	You can see in the above two statements that once again we used the Dot (.) notation for fetching the data from the record variable. 

	Once you have declared, initialize and access the data then make sure to close the cursor.

	Now let’s compile all the above line of codes (LOCs) together and make them into a single PL/SQL block.

	SET SERVEROUTPUT ON;
	DECLARE
		CURSOR cur_RebellionRider
		IS 
		SELECT first_name, salary FROM employees 
		WHERE employee_id = 100;
		--Cursor Based Record Variable Declare
		var_emp cur_RebellionRider%ROWTYPE;
	BEGIN
		OPEN cur_RebellionRider;
		FETCH cur_RebellionRider INTO var_emp;
		DBMS_OUTPUT.PUT_LINE (var_emp.first_name);
		DBMS_OUTPUT.PUT_LINE (var_emp.salary);
		CLOSE cur_RebellionRider;
	END;

Can we declare a Cursor Based Record Datatype variable before the cursor in PL/SQL block?
Hint: Modify the above code and put the Cursor Variable’s declaration before the cursor declaration and check the result. 	
	
	
	
Part 36 - Cursor Based Record Type With The Cursor Returning Multiple Values

We have already seen in the previous tutorial how to create Cursor based Record Type Variable based on Simple Cursor which returns a single row of data. Now the 
question arises here is that can we use the same single record datatype variable with the cursor which returns multiple rows of data? 

Step 1: Declare a Simple Explicit Cursor : 

	SET SERVEROUTPUT ON;
	DECLARE
		CURSOR cur_RebellionRider IS
		SELECT first_name, salary FROM employees 
		WHERE employee_id > 200;

		Unlike the cursor from the previous tutorial which is returning a single row of data, this cursor will return multiple rows. All these rows will consist of 
		the first name and salary of all the employees with employee id greater than 200. 

Step 2: Declare the Cursor Based Record Datatype Variable : 
	var_emp   cur_RebellionRider%ROWTYPE;

Step 3: Initialize the Cursor-Record Variable : 

	BEGIN 
	OPEN cur_RebellionRider; 
		LOOP 
			FETCH cur_RebellionRider INTO var_emp; 
			EXIT WHEN cur_RebellionRider%NOTFOUND; 
			DBMS_OUTPUT.PUT_LINE (var_emp.first_name||' '||var_emp.salary ); 
		END LOOP; --Simple Loop End CLOSE cur_RebellionRider; 
	END; 


Complete Code : 
	
	SET SERVEROUTPUT ON;
	DECLARE
		CURSOR cur_RebellionRider IS
		SELECT first_name, salary FROM employees
		WHERE employee_id > 200; 
		var_emp cur_RebellionRider%ROWTYPE;
	BEGIN
		OPEN cur_RebellionRider;
		LOOP
			FETCH cur_RebellionRider INTO var_emp;
			EXIT WHEN cur_RebellionRider%NOTFOUND;
			DBMS_OUTPUT.PUT_LINE (var_emp.first_name||' '||var_emp.salary);
		END LOOP;
		CLOSE cur_RebellionRider;
	END;

In my PL/SQL video tutorial I asked that can we simplify this code or is there any other way of doing the same task. The answer is yes, there are multiple ways of 
achieving the same result and one of them is by using “Cursor For-Loop”. This is a special kind of loop which declares the record variable as well as Opens, Fetches 
and Closes the underlying cursor implicitly in the background for you.

	SET SERVEROUTPUT ON;
	BEGIN
		FOR var_emp IN (SELECT first_name, salary FROM employees
		WHERE employee_id >200)
		LOOP
			DBMS_OUTPUT.PUT_LINE(var_emp.first_name||' '||var_emp.salary);
		END LOOP;
	END; 

	Both the codes will return the same result as both are doing the same task. 	
	
	
Part 37 - How To Create User defined Record Datatype Variable.

As the name suggests, user define records are the record variables whose structure is defined by the user, which is unlike the table based or cursor based records 
whose structures are derived from their respective tables or cursor. This means that with user define records you can have complete control over the structure of 
your record variable.

The creation process of user define record variable is divided into two parts. Before defining the record we first need to define the TYPE for the record variable. 
This TYPE will become the base of the User Define Record variable and will help in driving its structure. Once the TYPE is successfully declared then we can use it 
for creating our user define record variable.

Syntax of User Define Records in Oracle Database - 

Below is the syntax for creating the TYPE for User Defined Record Datatype Variable.

	TYPE type_name IS RECORD (
		field_name1 datatype 1,
		field_name2 datatype 2,
		...
		field_nameN datatype N 
	);

Once we have our TYPE declared we are all set to create our Record Variable. This variable will then acquire all the properties of the type using which it is 
created. And here is the syntax for creating the user define record datatype variable.

	record_name TYPE_NAME;

Did you notice that unlike the Table based or Cursor Based Record Variable we do not have to use %ROWTYPE attribute here for declaring the record variable?

Example: How To Create User Defined Record Datatype Variable.

Step 1: Declare Type for the User Defined Record Variable 

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE rv_dept IS RECORD   (
			f_name VARCHAR2(20),
			d_name DEPARTMENTS.department_name%TYPE 
		);

Step 2: Declare User Define Record Variable 
	After creating the TYPE you are all set to create your User Defined Record Variable.

	var1 rv_dept;

	This above PL/SQL statement will create a record variable with the name VAR1. 

Step 3: Initialize the User Defined Record Variable.
	User defined record variable can be initialized in multiple ways. For instance you can initialize the record variable directly by assigning value to it using 
	assignment operator or you can fetch the values stored into the column of a table using SELECT-INTO statement. So let’s move ahead with our example and learn 
	how to initialize a user defined record variable using SELECT-INTO statement. 

	Next I will write the execution section. In the execution section we will have a SELECT statement which will be joining employees table and departments table 
	and returning the first name and department name of the specific employee.

	BEGIN
		SELECT first_name , department_name 
		INTO var1.f_name, var1.d_name
		FROM employees join departments
		Using (department_id) WHERE employee_id = 100; 

		DBMS_OUTPUT.PUT_LINE(var1.f_name||' '||var1.d_name);
	END;

	The select statement which we have here will return the first name and the department name of the employee whose employee id is 100. The data for both the 
	columns are coming from different tables thus we used a JOIN here. As there are two different tables involved in the query thus in such a situation use of 
	Table Based Record Variable is not possible therefore the viable solution is the user define record variable. 

	Let’s join all the above chunks of codes together into a single anonymous PL/SQL block.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE rv_dept IS RECORD(
			f_name VARCHAR2(20),
			d_name departments.department_name%type 
		);
		var1 rv_dept;
	BEGIN
		SELECT first_name , department_name 
		INTO var1.f_name, var1.d_name
		FROM employees join departments
		Using (department_id) WHERE employee_id = 100;

		DBMS_OUTPUT.PUT_LINE(var1.f_name||' '||var1.d_name);
	END;
	/
	
	
Part 38 - What are PL/SQL functions in Oracle Database?

In Oracle Database we can define a PL/SQL function as a self-contained sub-program that is meant to do some specific well defined task. Functions are named 
PL/SQL block which means they can be stored into the database as a database object and can be reused. That is also the reason why some books refer to PL/SQL 
functions as stored functions.

Type of PL/SQL functions in Oracle Database :
	There are two types of PL/SQL functions in Oracle Database, these are - 
	- Pass-by-Value Functions and 
	- Pass-by-Reference functions

	In Oracle Database both types of functions should have to return some values and these values should be a valid SQL or PL/SQL datatype. 

Syntax of PL/SQL Functions in Oracle Database : 

	CREATE [OR REPLACE] FUNCTION function_name
	(Parameter 1, Parameter 2…)
	RETURN datatype
	IS
		Declare variable, constant etc. here. 
	BEGIN
		Executable Statements
		Return (Return Value);
	END;

Function Execution Method : 

Depending on your creativity and programming skills, a PL/SQL function can be called by multiple ways. Here are some general ways of calling a PL/SQL function in 
Oracle Database - 
	- You can use SQL*Plus utility of the Oracle Database to invoke a PL/SQL function that can be called from PL/SQL as procedural statement.
	- An anonymous PL/SQL block can also be used to call a function.
	- You can even call a function directly into a SELECT or DML statement.

Restrictions on calling a function - 
	- A function that returns SQL datatype can be used inside SQL statement and a PL/SQL function that returns PL/SQL datatype only works inside PL/SQL blocks. 
		An exception to this rule is that, you cannot call a function that contains a DML operation inside a SQL query. However you can call a function that 
		performs a DML operation inside INSERT, UPDATE and DELETE.
	- A function called from an UPDATE or DELETE statement on a table cannot query (SELECT) or perform transaction (DMLs) on the same table. 
	- A function called from SQL expressions cannot contain the TCL (COMMIT or ROLLBACK) command or the DDL (CREATE or ALTER) command	
	

Part 39 - PL/SQL Functions in Oracle Database 

As discussed in the previous tutorial that the function body is divided into two parts - 
- First is the header of the PL/SQL function and
- Second is the execution part of the PL/SQL function

So let’s start with header of our function.

Step 1. Create the Header of a PL/SQL Function - 
	The header consists of the signature of the function or the declaration of the PL/SQL function. 

	--Function Header
	CREATE OR REPLACE FUNCTION circle_area (radius NUMBER) 
	RETURN NUMBER IS

Step 2. Declare Variables or the Constant : 
	If your program requires you to declare any variable or constant or anything then you can do it right after creating the header, that too without using the 
	DECLARE keyword.

	--Declare a constant and a variable
	pi CONSTANT NUMBER(7,2) := 3.141;
	area NUMBER(7,2);

Step 3. Create the Execution Part of the PL/SQL function.
	Once you have created the header of your function and declared all your necessary variables as well as constants then you are all set to create the execution 
	part of your PL/SQL function. Here in the execution section of a PL/SQL function, you write all your execution statements. This part also defines the working 
	of your function.

	BEGIN
		--Area of Circle pi*r*r;
		area := pi * (radius * radius);
		RETURN area; 
	END;
	/

	Quick Info:
	To calculate the square of the circle’s radius in the area of circle, you can also use the inbuilt function of POWER (p, q). This function takes two numeric 
	input and returns one numeric value which will be the answer to the arithmetic expression of p raise to q. 

	Now let’s join all the above chunks of codes together into a single named unit. 


	PL/SQL function for calculating “Area of the Circle”.

	--Function Header
	CREATE OR REPLACE FUNCTION circle_area (radius NUMBER) 
	RETURN NUMBER IS
	--Declare a constant and a variable
	pi CONSTANT NUMBER(7,2) := 3.141;
	area NUMBER(7,2);
	BEGIN
		--Area of Circle pi*r*r;
		area := pi * (radius * radius);
		RETURN area; 
	END;

	A successful compilation will create a named PL/SQL block which is your PL/SQL function with the name circle_area. 
	As PL/SQL functions are named PL/SQL block thus they are permanently saved in your database which you can use anytime. 
	In order to see your PL/SQL Function in action you have to call it through your program. Your program can be an anonymous PL/SQL block, or a named PL/SQL Block 
	or even using a SELECT statement. 

	
Part 40 - What are stored procedures in Oracle Database?

Similar to PL/SQL Functions a stored Procedure is a self-contained subprogram that is meant to do some specific tasks. Also similar to functions, procedures are 
named PL/SQL blocks thus they can be reused because they are stored into the database as a database object. But unlike PL/SQL functions a stored procedure does 
not return any value.

Syntax of PL/SQL Stored Procedures - 

	CREATE [OR REPLACE] PROCEDURE pro_name (Parameter – List)
	IS [AUTHID DEFINER | CURRENT_USER]
		Declare statements
	BEGIN
		Executable statements 
	END procedure name;
	/ 

The above Syntax of PL/SQL stored procedure is pretty much similar to the syntax of PL/SQL Functions that we saw in the last PL/SQL tutorial. Except for two things: 
	There is no Return clause :
		A core difference between a PL/SQL Function and a stored procedure is that unlike Functions a stored procedure does not return any value. 

	AUTHID Clause :
		The AUTHID clause is used for setting the authority model for the PL/SQL Procedures. This clause has two flags :
			- DEFINER and
			- CURRENT_USER

		As this clause is optional thus in case if you do not use AUTHID clause then Oracle Engine will set the authority (AUTHID) to the DEFINER by default for you.
		Now, you must be wondering what these DEFINER and CURRENT_USER rights are?

		DEFINER right: 
			Definer right is the default right assigned to the procedure by oracle engine. This right means anyone with Execution Privilege on the procedure acts 
			as if they are the owner of the schema in which the privilege is created. 

		CURRENT_USER right: 
			Setting the authority level of a stored procedure to the current_user right overrides the default right which is definer and change it to the invoker 
			rights. 
			Invoker right authority means that you call the procedure to act on your local data and it requires that you replicate data objects in any 
			participating schema. 

Some Extra Points About Stored Procedure : 
	- You can define a procedure with or without formal parameters. 
	- A parameter can be either pass-by-value or pass-by-reference.
	- A procedure will be a pass-by-value procedure when you don’t specify the parameter mode because it uses the default IN mode.

Differences between PL/SQL Function and PL/SQL Stored Procedures?
What are Parameter Modes in PL/SQL Functions and Procedures?
What are Formal and Actual Parameters?


Part 41 - PL/SQL Stored Procedures without Parameters.

While discussing the syntax in the Introduction to PL/SQL stored procedures we learnt that a stored procedure can have zero, one or many parameters. Today in this 
tutorial we will learn how to create a PL/SQL stored procedure with zero parameters or say without any parameters. Apart from creating a stored procedure in 
oracle database, we will also learn in this tutorial the multiple ways of calling a stored procedure in a PL/SQL program. 

How To Create PL/SQL Stored Procedure without Parameters In Oracle Database :

	CREATE OR REPLACE PROCEDURE pr_RebellionRider IS
		var_name VARCHAR2 (30):= 'Manish';
		var_web VARCHAR2 (30) := 'RebellionRider.com';
	BEGIN
		DBMS_OUTPUT.PUT_LINE('Whats Up Internet? I am '||var_name||' from '||var_web);
	END Pr_RebellionRider;
	/

	In the above example I have created a PL/SQL Stored procedure with the name pr_RebellionRider which has two variables capable of holding strings of VARCHAR2 
	datatype. In the execution section this PL/SQL procedure has only one DBMS OUTPUT statement which is displaying the strings stored into those variable back 
	to the user in a formatted manner.

How to Call PL/SQL Stored Procedures in Oracle Database :

	After successfully creating and compiling the stored procedure, next you have to call this subroutine. You can do so in multiple ways such as: 
	- Call a PL/SQL stored procedure using EXECUTE statement.
	- Call a PL/SQL stored procedure using an Anonymous PL/SQL block.
	- Call a PL/SQL stored procedure using a Named PL/SQL block.

	If in case your subroutine such as stored procedure consists of server side PL/SQL statement then do make sure to set the “Server Output On” to see the result. 

Call a PL/SQL stored procedure using EXECUTE statement :
	The best way to quickly check the output of your stored procedure or test the working of your PL/SQL procedure is to call it using EXECUTE keyword. 
	In order to call a stored procedure using EXECUTE keyword you simply have to write the same keyword followed by the name of the procedure.

	EXECUTE PR_RebellionRider; 

	Or you can also write the first 4 letters of the EXECUTE keyword followed by the procedure name. 

	EXEC PR_RebellionRider; 

	Both the statements are the same and will do the same work.

Call a PL/SQL stored procedure using an Anonymous PL/SQL block :
	The second way of calling a procedure is to place a procedure call statement inside the execution section of an anonymous PL/SQL block. 

	BEGIN
		PR_RebellionRider;
	END;
	/

	You simply have to write the name of your stored procedure inside the execution section of an anonymous and named PL/SQL block. The compiler will automatically 
	interpret that as a procedure call statement. If your procedure accepts any parameters then you can supply values for parameters here. We will talk in detail 
	about stored procedures with parameters in our next tutorial.

Try yourself :
	The third way of calling a stored procedure in Oracle Database is by using named PL/SQL Blocks. This is what you should try yourself. 
	Write a PL/SQL stored procedure displaying your favorite string and then try calling it using a named PL/SQL Block such as Database Triggers or PL/SQL Function.


	
Part 42 : PL/SQL Stored Procedures with Parameters. 

So let’s see the demonstration of how to create PL/SQL stored procedure with parameters!

Step 1: Create the header of the stored procedure

In the header of the procedure we define its signature. 

	CREATE OR REPLACE PROCEDURE emp_sal
	(dep_id NUMBER, sal_raise NUMBER) 
	IS

	The header is pretty similar to the one which we saw in the last tutorial except that this time our procedure is accepting parameters which are dep_id and 
	sal_raise of NUMBER datatype.

Step 2: Create the execution section of the stored procedure :
	In the execution section we write all the executable statements which define the working of the stored procedure.

	BEGIN
		UPDATE employees SET salary = salary * sal_raise WHERE department_id = dep_id;
	END;
	/
	
	For a better understanding I have tried to make this code as simple as possible. In the execution section we only have one DML statement which is UPDATE. 
	Using this we update the salary column of employee table.

	You can write the business logic like this then wrap them up into a procedure and call them in your app when needed. This will give you more control on your 
	app. It will also save you from writing the same code again and again. 

	This procedure will accept two parameters which is the department id and the numeric value for salary raise. First parameter which is the dep_id, is used to 
	determine the ID of the department. The second parameter which is sal _ raise will become the multiplication factor in the salary raise. 

Let’s combine all the above chunks of code into a single one named PL/SQL unit.

Stored Procedure for Department Wide Salary Raise

	CREATE OR REPLACE PROCEDURE emp_sal( dep_id NUMBER, sal_raise NUMBER) 
	IS
	BEGIN
		UPDATE emp SET salary = salary * sal_raise WHERE department_id = dep_id;
	END;
	/
	
Once you have successfully created your stored procedure, next you have to call it in your program or code. 
In the last tutorial I showed you different ways of calling a procedure in oracle database. You can refer to that tutorial for the same.



Part 43 - Calling Notation for PL/SQL Subroutines. 

Since previous few tutorials were about PL/SQL Subroutines such as PL/SQL Functions and Stored Procedures thus it becomes mandatory to talk about their calling 
notations. Learning the concepts of PL/SQL Subroutines will not be considered as complete until we learn their calling notations as well.

What is Calling Notation for PL/SQL Subroutines?
Calling notation is a way of providing values to the parameters of a subroutine such as PL/SQL function or a stored procedure.

Types of Calling Notations for Subroutines :
	In Oracle PL/SQL there are 3 types of calling notations. These are:
		- Positional Notation
		- Named Notation and
		- Mixed calling notation

Positional Calling Notations : 
	Positional notation is the most common calling notation which you can see in almost every computer programming language. In positional notation we have to specify 
	the value for each formal parameter in a sequential manner. This means that you have to provide the values for the formal parameters in the same order as they 
	were declared in the procedure or in the function. 
	In positional notation the datatype and the position of the actual parameter must match with the formal parameter.

	Example: Positional Notation for calling PL/SQL Subroutines :

		CREATE OR REPLACE PROCEDURE emp_sal
		(dep_id NUMBER, sal_raise NUMBER) 
		IS
		BEGIN
			UPDATE employees 
			SET salary = salary * sal_raise 
			WHERE department_id = dep_id;
			DBMS_OUTPUT.PUT_LINE ('salary updated successfully');
		END;
		/ 

	This is the same example which we did in PL/SQL Tutorial 42 on how to create stored procedure with parameters albeit some minor changes. Now if we use 
	positional calling notation then we have to supply the values to both the parameters of the above procedure in the same manner in which they are declared. 

	Stored Procedure call using positional notation in Oracle Database :
		EXECUTE  emp_sal  (40,2); 

	In this simple procedure call, the value 40 is corresponding to the formal parameter dep_id and value 2 is corresponding to the parameter sal_raise. 

Named Calling Notations : 
	Named calling notation lets you pass values to the formal parameters using their names. This will in turn let you assign values to only required or say mandatory 
	parameters. 
	This calling notation is useful when you have a subroutine with parameters where some of those parameters are mandatory and some are optional and you want to 
	pass the values to only the mandatory ones. 

	Association Operator :
		In order to assign values to the formal parameters using their names we use association operator. It is a combination of equal to (=) sign and 
		greater than (>) sign. We write the name of the formal parameter to the left hand side of the operator and the value which you want to assign to the 
		right hand side of the operator. 

Example of Named Calling Notation for calling a PL/SQL Subroutines : 

	CREATE OR REPLACE FUNCTION add_num
	(var_1 NUMBER, var_2 NUMBER DEFAULT 0, var_3 NUMBER ) RETURN NUMBER 
	IS
	BEGIN
		RETURN var_1 + var_2 + var_3;
	END;
	/ 

	The above function has 3 parameters. Among these 3 parameters 2 are mandatory and 1 is optional with a default value 0.


	You can call this function using positional notation. But it has a restriction which you have to fulfill and that is that you have to supply values to all 
	the formal parameters in the same order in which they are declared and the datatype of formal and actual parameters must match.

	So if you want to omit the optional parameter and want to use their default value or you just forgot the order of the parameter in which they were declared! 
	Then it will be slightly difficult for you to call the above subroutine using positional notation. In such a scenario you can take advantage of 
	Named Calling Notation. This calling notation will provide you the desired flexibility in calling your subroutines.

PL/SQL Function call using Named Calling Notation in Oracle Database :

	DECLARE
		var_result NUMBER;
	BEGIN
		var_result := add_num(var_3 => 5, var_1 =>2);
		DBMS_OUTPUT.put_line('Result ->' || var_result);
	END;
	/ 

Mixed Calling Notation for calling PL/SQL Subroutines :
	As the name suggests in mixed calling notation you can call subroutines using the combination of named as well as positional calling notations. 
	Mixed calling notation is very helpful where the parameter list is defined with all mandatory parameters first and optional parameters next. 

Example of Mixed calling notation for calling PL/SQL subroutines - 
	Here is the anonymous block in which we are calling the same function add_num ( ) which we coded when doing named calling notation.

	DECLARE
		var_result NUMBER;
	BEGIN
		var_result := add_num(var_1 => 10, 30 ,var_3 =>19);
		DBMS_OUTPUT.put_line('Result ->' || var_result);
	END;
	/ 
	
That’s how we use mixed calling notation for calling PL/SQL Subroutines.

Try it yourself
	Using the knowledge from the above concepts try solving the following question: 
	Write a PL/SQL Function with parameters for swapping two numbers and call that function using mixed calling notation.

	
Part 44 - PL/SQL Packages

Till so far we have seen most of the named PL/SQL blocks such as Database Cursors, PL/SQL Functions, Stored Procedure and Triggers now it’s time to move on to 
another most demanded PL/SQL tutorial on my YouTube channel which is PL/SQL Packages.

What are PL/SQL Packages in Oracle Database?
	Packages are stored libraries in the database which allow us to group related PL/SQL objects under one name. Or in simple words, Packages are logical groups 
	of related PL/SQL objects. Packages are named PL/SQL Blocks which mean they are permanently stored into the database schema and can be referenced or reused by 
	your program. 

Definition of PL/SQL Packages :
	Packages are stored libraries in the database which allow us to group related PL/SQL objects under one name.
	
What are the contents included in a package? 
	A package can hold multiple database objects such as
	- Stored Procedures 
	- PL/SQL Functions 
	- Database Cursors
	- Type declarations as well as
	- Variables

Info Byte : 
	All the objects included into a package are collectively called Package Elements.
	
Package Architecture - 
	PL/SQL package is divided into two parts:
	- The Package Specification, also known as the Header and 
	- The Package Body

	Both these parts are stored separately in the data dictionary. The package specification is the required part whereas the package body is optional, but it is 
	a good practice to provide the body to the package.
	
Package Specification :
	Package specification is also known as the package header. It is the section where we put the declaration of all the package elements. Whatever elements we 
	declare here in this section are publically available and can be referenced outside of the package. 

Info Byte : 
In package specification we only declare package elements but we don’t define them. Also this is the mandatory section of the package. 

Syntax of Package specification :
	
	CREATE OR REPALCE PACKAGE pkg_name IS

		Declaration of all the package element…;

	END [pkg_name]; 
	
Package Body : 
	In package body we provide the actual structure to all the package elements which we have already declared in the specification by programing them. Or we can 
	say that a package body contains the implementation of the elements listed in the package specification. Unlike package specification a package body can 
	contain both declaration of the variable as well as the definition of all the package elements. 
	Any package elements such as PL/SQL Function, a cursor or a stored procedure which is not in the package specification but coded in the package body is called 
	Private Package Elements and thus they cannot be referenced outside the package. 

Syntax of the package body : 

	CREATE OR REPALCE PACKAGE BODY pkg_name IS 
		Variable declaration; 
		Type Declaration; 
	BEGIN
		Implementation of the package elements…
	END [pkg_name];

	

	
Part 45 : How to Create Package?

As we talked while discussing the architecture of the package in the previous tutorial that the package is divided into two parts, which are 
- Package header and
- The package body

So we will start with creating the package header first

Package Header :

	CREATE OR REPLACE PACKAGE pkg_RebellionRider IS
		FUNCTION prnt_strng RETURN VARCHAR2;
		PROCEDURE proc_superhero(f_name VARCHAR2, l_name VARCHAR2);
	END pkg_RebellionRider;

By taking a look at the above code we can clearly say that the package is going to hold two package elements which are – 
a PL/SQL function prnt_strng and a stored procedure proc_superhero. 

Package Body : 

	--Package Body
	CREATE OR REPLACE PACKAGE BODY pkg_RebellionRider IS
		--Function Implimentation
		FUNCTION prnt_strng RETURN VARCHAR2 IS
		BEGIN
			RETURN 'RebellionRider.com';
		END prnt_strng;

		--Procedure Implimentation
		PROCEDURE proc_superhero(f_name VARCHAR2, l_name VARCHAR2) IS
		BEGIN
			INSERT INTO new_superheroes (f_name, l_name) VALUES(f_name, l_name);
		END;

	END pkg_rrdr; 
	
	In the above code for the package body we implemented both the package elements which we defined into the package header.

Info Byte : 
	Both package header and body are individual database objects thus you have to compile them separately in order to put your package to work.
	
How to access the package elements? 
We have our package header and body created and compiled successfully, what’s next? Like every other database object, package serves a unique purpose. Using a 
package you can group different database objects under one name and as PL/SQL packages are named database blocks thus they can be stored into the database and can 
be used later when needed.

So the question arises here is how to access the package elements? To access the elements defined and implemented into a package we use dot (.) notation. 
According to which in order to access the package element you have to first write the name of your package followed by dot (.) operator and then the name of the 
package element.

Example:
For example say you want to call the PL/SQL function prnt_strng of our package pkg_RebellionRider. 

	--Package Calling Function
	BEGIN
		DBMS_OUTPUT.PUT_LINE (PKG_RebellionRider.PRNT_STRNG);
	END; 
	
In the above code using anonymous block we call the function prnt_strng of the package pkg_RebellionRider.


Part 46 - PL/SQL Exception Handling

We cannot say that the code is robust until it can handle all the exceptions. Bugs and abrupt termination of a program are the nightmares of a programmer’s life. 
No programmer wants to develop a code which will crash in a midway or behave unexpectedly. Thus for the smooth execution of a software it is necessary to handle 
all kinds of exceptions.

Knowing your problem is the first step towards finding its solution. So let’s learn more about exception handling in Oracle database. 

What is an Exception?
Any abnormal condition or say event that interrupts the normal flow of your program’s instructions at run time is an exception. Or in simple words you can say 
an exception is a run time error.

Info Byte : 
	Exceptions are designed for run time error handling rather than compile time error handling. Errors that occur during compilation phase are detected by the 
	PL/SQL compiler and reported back to the user.
	
Types of exceptions : 
	There are two types of PL/SQL exceptions in Oracle database.
		- System-defined exceptions and
		- User-defined exceptions
		
System-Defined Exceptions - 
	System-defined exceptions are defined and maintained implicitly by the Oracle server. These exceptions are mainly defined in the Oracle STANDARD package. 
	Whenever an exception occurs inside the program. The Oracle server matches and identifies the appropriate exception from the available set of exceptions.

	System defined exceptions majorly have a negative error code and error message. These errors have a short name which is used with the exception handler. 

Info Byte :
	Oracle avails two utility functions SQLCODE & SQLERRM to retrieve the error code and message for last occur exception.

User-Define Exceptions : 
	Unlike System-Define Exception, User-Define Exceptions are raised explicitly in the body of the PL/SQL block (more specifically inside the BEGIN-END section) 
	using the RAISE statement.

How to Declare a User-Define Exception in Oracle Database : 
	There are three ways of declaring user-define exceptions in Oracle Database : 
		- By declaring a variable of EXCEPTION type in declaration section : 
			You can declare a user defined exception by declaring a variable of EXCEPTION datatype in your code and raise it explicitly in your program using RAISE 
			statement and handle them in the Exception Section.
		- Declare user-defined exception using PRAGMA EXCEPTION_INIT function : 
			Using PRAGMA EXCEPTION_INIT function you can map a non-predefined error number with the variable of EXCEPTION datatype. Means using the same 
			function you can associate a variable of EXCEPTION datatype with a standard error.
		- RAISE_APPLICATION_ERROR method :
			Using this method you can declare a user defined exception with your own customized error number and message.


Part 47 - PL/SQL Exception Handling

In the Introduction to PL/SQL Exceptions we learnt that there are three ways of declaring user-define exceptions in Oracle Database. In this tutorial we are going 
to explore the first way and learn how to declare user-define exception using a variable of Exception datatype.

Declaring a user-define exception using Exception variable is a three step process. These three steps are – 
	- Declare a variable of exception datatype – This variable is going to take the entire burden on its shoulders. 
	- Raise the Exception – This is the part where you tell the compiler about the condition which will trigger the exception. 
	- Handle the exception – This is the last section where you specify what will happen when the error which you raised will trigger. 

For the demonstration purpose I will write a code which will check whether the divisor is zero or not in the division operation. If it is zero then an error will 
occur and will be displayed to the user otherwise an actual value which is the result of the division arithmetic will be returned on the output screen. 

Step 1 Declare a variable of Exception datatype : 
	By Exception variable I mean a variable with Exception datatype. Like any other PL/SQL variable you can declare an Exception variable in declaration section 
	of the anonymous as well as named PL/SQL block. This exception variable will then work as user-define exception for your code.

	DECLARE
		var_dividend NUMBER := 24;
		var_divisor NUMBER := 0;
		var_result NUMBER;
		/*Declare Exception variable*/
		ex_DivZero EXCEPTION;


	In this declaration section we have 4 variables. Among these 4 variables first 3 are normal Number datatype variables and the 4th one which is ex_DivZero 
	is the special EXCEPTION datatype variable. This variable will become our User-Define Exception for this program.

Step 2 Raise the Exception
	The next step after declaring an Exception variable is to raise the exception. To raise the exception in PL/SQL we use Raise statement. 
	Raise statement is a special kind of PL/SQL statement which changes the normal flow of execution of the code. As soon as compiler comes across a raise 
	condition it transfers the control over to the exception handler. 

	BEGIN
		IF var_divisor = 0 THEN
			RAISE ex_DivZero;
		END IF;

	Here raise condition is accompanied with the IF-THEN condition . With the help of this we can avoid unwanted switches during the control flow of the program. 
	Using If Condition we are making sure that this error will come into action only when the divisor is equal to 0. 

	var_result := var_dividend/var_divisor;
	DBMS_OUTPUT.PUT_LINE('Result = ' ||var_result);
	
	After writing the logic for raising the error you can write your other executable statements of the code just like we did here. After the Raise statement we 
	are performing the arithmetic of division operation and storing the result into the variable var_result, as well as displaying it back as the output using 
	the DBMS OUTPUT statement. 

	“Raise statement changes the normal flow of execution of the code.” 

Step 3 Handle the exception
	That is the main section of the code. Here we write the logic for our user-define exception and tell the compiler what it should do if and when that error 
	occurs.

	EXCEPTION WHEN ex_DivZero THEN
		DBMS_OUTPUT.PUT_LINE('Error Error - Your Divisor is Zero');
	END;
	/
	
	Here we have the exception handler for the variable ex_DivZero. In the exception handling section we have a DBMS OUTPUT statement which will get displayed when 
	our user define error which is ex_DivZero occurs.

Now let’s group all these chunks of codes together.

Divide by zero error using PL/SQL User-define Exception in Oracle Database - 

	SET SERVEROUTPUT ON;
	DECLARE
		var_dividend NUMBER := 24;
		var_divisor NUMBER := 0;
		var_result NUMBER;
		ex_DivZero EXCEPTION;
	BEGIN
		IF var_divisor = 0 THEN
			RAISE ex_DivZero;
		END IF;
		var_result := var_dividend/var_divisor;
		DBMS_OUTPUT.PUT_LINE ( 'Result = ' ||var_result );
		
		EXCEPTION WHEN ex_DivZero THEN
			DBMS_OUTPUT.PUT_LINE ( 'Error Error - Your Divisor is Zero' );
	END;
	/

	Before running this program do make sure that you have set the SERVEROUTPUT on otherwise you will not be able to see the result. 

	As in Step-1 we set the divisor’s value on zero that will in turn raise the user define error ex_DivZero because of this on compiling the above code you 
	will see the string “Error Error - Your Divisor is Zero” the same one which we specified in our exception handler (step 3).

	

Part 48 - PL/SQL Exception Handling

As discussed in the introduction to PL/SQL exception handling there are three ways of declaring user-define exceptions in Oracle PL/SQL. Among those three we have 
already discussed and learnt the first way in the previous tutorial. Today in this blog we will take a step ahead and see the second way of 
declaring user define exception and learn how to declare user-define exception using RAISE_APPLICATION_ERROR method.

What is RAISE_APPLICATION_ERROR method?
	RAISE_APPLICATION_ERROR is a stored procedure which comes in-built with Oracle software. Using this procedure you can associate an error number with the 
	custom error message. Combining both the error number as well as the custom error message you can compose an error string which looks similar to those 
	default error strings which are displayed by Oracle engine when an error occurs.

How many errors can we generate using RAISE_APPLICATION_ERROR procedure?
	RAISE_APPLICATION_ERROR procedure allows us to number our errors from -20,000 to -20,999 thus we can say that using RAISE_APPLICATION_ERROR procedure we 
	can generate 1000 errors.

Raise_application_error is part of which package?
	You can find RAISE_APPLICATION_ERROR procedure inside DBMS_STANDARD package.

Syntax of Raise_Application_Error : 
	raise_application_error (error_number, message [, {TRUE | FALSE}]); 
	
	Here the error_number is a negative integer in the range of -20000.. -20999 and the message is a character string up to 2048 bytes long. In case of the 
	optional third parameter being TRUE, the error is placed on the pile of all the previous errors. However in case of FALSE (the default) parameter, the error 
	replaces all previous errors. RAISE_APPLICATION_ERROR is part of package DBMS_STANDARD, and you do not need to qualify references to package STANDARD.

Example of RAISE_APPLICATION_ERROR procedure :
	In the following example we will take an input of numeric datatype from the user and check if it is 18 or above. If it is not then the user-define error, 
	which we will declare, will be raised otherwise there will be the normal flow of execution of the program. 

	Step1: Set the server output on
		If we want to see the result returned by the PL/SQL program on the default output screen then we will have to set the server output ‘on’ which is by 
		default set to ‘off’ for the session. 

		SET SERVEROUTPUT ON; 

	Step 2: Take User Input
		Though we can hardwire the values in our code as we did in the last tutorial but it is not that fun. In order to make the code more dynamic I decided to 
		accept the input by user this time by letting them to enter the value into a pop-up box with a customized message printed on it.

		We can take the input using pop-up box with a customized message printed on it using ACCEPT command in Oracle PL/SQL.

		ACCEPT var_age NUMBER PROMPT 'What is your age?'; 

		Command starts with the keyword Accept followed by the name of the variable and its datatype. In our case the name is var_age and datatype is NUMBER. 
		That is the first half of the statement. This part will help us in storing the input value. The other half of the statement will be responsible for 
		printing the customized message on the pop-up box. Using the keyword PROMPT which is right after the datatype of the variable, you can specify any 
		desired string which you want printed on your pop-up box. In our case this customized message will be ‘What is your age?’

	Step 3: Declare Variable

		DECLARE
			age NUMBER := &var_age; 

		Due to the scope restriction we cannot use the value stored into the variable which we used in the Accept command. This means we cannot directly use that 
		value into our PL/SQL program. We can solve this problem by assigning the value that was stored into the variable var_age to a variable which is local 
		to the PL/SQL block. That is exactly what we did in the above segment of the code. 

		In the above code segment we declared a local variable with name ‘age’ and assigned the value stored into the variable 'var_age' using the assignment 
		operator.

	Step 4: Declare the user-define exception by using RAISE_APPLICATION_ERROR procedure

		BEGIN
			IF age < 18 THEN
				RAISE_APPLICATION_ERROR (-20008, 'you should be 18 or above for the DRINK!');
			END IF; 

		Here in this code segment we declared the user-define exception using RAISE_APPLICATION_ERROR procedure. This procedure is called using two parameters. 
		In which first parameter is the negative number which, in my case, is -20008 and the second number is a string which gets displayed if the same error occurs. 

	Step 5: Executable statement 
	
		DBMS_OUTPUT.PUT_LINE('Sure, What would you like to have?'); 
	
		Executable statements are those that get compiled and run when there is no error and the program has a normal flow of execution. In order to make the 
		code simple and easy to understand I just wrote a single statement which is the DBMS OUTPUT statement. 


	Step 6: Write the Exception handler

		Now that we have declared as well as raised the user-define exception next we need to write the exception handler for it. As said in the previous PL/SQL 
		tutorial that in the Exception Handler section we specify what will happen when the error which you raised will trigger.

		EXCEPTION WHEN OTHERS THEN
			DBMS_OUTPUT.PUT_LINE(SQLERRM);
		END;
		/ 

		In this exception handling section I have called a SQLERRM function using DBMS OUTPUT statement. This is a utility function provided by Oracle which 
		retrieves the error message for the last occurred exception.

Let’s compile all these small chunks of code into one big program.

User-Define Exception Using Raise_Application_Error Procedure : 

	SET SERVEROUTPUT ON;
	ACCEPT var_age NUMBER PROMPT 'What is yor age';
	DECLARE
		age NUMBER := &var_age;
	BEGIN
		IF age < 18 THEN
			RAISE_APPLICATION_ERROR (-20008, 'you should be 18 or above for the DRINK!');
	END IF; 
	DBMS_OUTPUT.PUT_LINE ('Sure, What would you like to have?'); 
	EXCEPTION WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE (SQLERRM);
	END;
	/ 


Part 49 - PL/SQL Exception Handling

What is PRAGMA EXCEPTION_INIT?
Pragma Exception_Init is a two part statement where first part is made up of keyword PRAGMA and second part is the Exception_Init call.

PRAGMA Keyword 
	A pragma is a compiler directive which indicates that the Statements followed by keyword PRAGMA is a compiler directive statement this means that the statement 
	will be processed at the compile time & not at the runtime.

Exception_Init
	Exception_init helps you in associating an exception name with an Oracle error number. In other words we can say that using Exception_Init you can name the 
	exception.

Why name the exception?
	Yes, there is a way of declaring user-define exception without the name and that is by using Raise_Exception_Error procedure. This indeed is a simple and 
	easy way but as we learnt in the last tutorial that to handle exceptions without name we use OTHERS exception handler. 
	
	Now think that in your project you have multiple exceptions and that too without name. In order to handle all those exceptions you have a single exception 
	handler with name OTHERS. In this case on the occurrence of an exception condition the compiler will display the error stack produced by the OTHER handler. 

	Can you imagine how difficult it will be to trace that part of your project which is causing the error. In order to trace that part you need to go through 
	each & every line of your code. This will be mere waste of time.

	You can save all those time wasting efforts just by naming the exception, that way you can design an exception handler specific to the name of your exception 
	which will be easily traceable. This is the advantage of naming the exception.


	Syntax of Pragma Exception_Init : 
		PRAGMA EXCEPTION_INIT (exception_name, error_number); 

Example: Declare User-define exception using Pragma Exception_Init :

	DECLARE
		ex_age EXCEPTION;
		age NUMBER := 17;
		PRAGMA EXCEPTION_INIT(ex_age, -20008);
	BEGIN
		IF age < 18 THEN
			RAISE_APPLICATION_ERROR(-20008, 'You should be 18 or above for the drinks!');
		END IF;

		DBMS_OUTPUT.PUT_LINE('Sure! What would you like to have?');

		EXCEPTION WHEN ex_age THEN
			DBMS_OUTPUT.PUT_LINE(SQLERRM); 
	END;
	/

Why use PRAGMA EXCEPTION_INIT with RAISE_APPLICATION_ERROR?
	Though it is not mandatory to use PRAGMA EXCEPTION_INIT with RAISE_APPLICATION_ERROR procedure however it is more of a personal preference than a programming 
	rule. If you want to print an error message with an error number like the Oracle’s standard way of showing an error then it is the best practice to use 
	PRAGMA EXCEPTION_INIT with RAISE_APPLICATION_ERROR procedure. 
	But if you just want to print the error message & not the error number then you can use PRAGMAEXCEPTION_INIT with RAISE statement. 

	
Part 50 : PL/SQL Collections

What are PL/SQL Collections in Oracle Database?
	A homogeneous single dimension data structure which is made up of elements of same datatype is called collection in Oracle Database. In simple language we 
	can say that, an array in Oracle Database is called Collection.
	
Definition - 
	A homogeneous single dimension data structure which is made up of elements of same datatype is called collection in Oracle Database. 

Why we call collection a homogeneous data structure?
	As we know that array consists data of same datatype and so does the PL/SQL collection which is why we call them homogenous data structure.

The structure of PL/SQL collections consist of a cell with subscript called index. Data is stored into these cells and can be identified and accessed using the 
index number. This is again very similar to the structure of arrays, but unlike array PL/SQL Collections are strictly one-dimensional.

Info byte : 
	The collection in Oracle Database are strictly One-Dimensional. It is not possible to realize them on 2D co-ordinates. However when the collection has an 
	attribute of object type or collection type then it is possible to realize a multi-dimensional array.
	
Types of PL/SQL Collections in Oracle Database : 
	PL/SQL collections can be divided into two categories:
	- Persistent and 
	- Non-persistent.

Persistent collection, as the name suggests, are those which physically store the collection structure with the data into the database and can be accessed again 
if needed. Whereas non-persistent collection only stores data and structure for one session.

On the basis of above categories collections are further divided into three types:
	- Nested Tables
	- Variable Sized Arrays or VARRAYs and
	- Associative arrays.

Nested Table – Nested tables are persistent collection which means they can be stored into the database and can be reused. Nested tables has no upper limits on rows 
thus they are unbounded collections. Nested tables are initially dense but can become sparse through deletion. 

VARRAYs – Similar to Nested tables Variable-Sized Arrays are also persistent collections thus they can be created in database as well as PL/SQL block and can be 
reused. But unlike nested tables VARRAYs are bounded in nature which means that they can hold only a fixed amount of elements. 

Info byte : 
The size and storage schema of VARRAYs makes them different from nested tables. 

Associative Array – Unlike nested table and VARRAYs, associative arrays are non-persistent collections thus they cannot be stored into the database. Since they 
cannot be store hence they cannot be reused but they are available in PL/SQL block for the session. But similar to nested tables associative arrays are 
unbounded which means they also don’t have lower and upper limits on rows. 

Commonly used terms in PL/SQL Collection : 
	Bounded & Unbounded Collection – A collection which has lower or upper limits on values of row number or say a collection which can hold only limited number of 
	elements are called bounded collections. A collection which has no lower or upper limits on row numbers are called unbounded collections.

	Dense & Sparse Collection – Collections is said to be dense if all the rows between the first and the last are defined and given a value. And a collection in 
	which rows are not defined and populated sequentially are called sparse collection.

	
Part 51 : Nested Table in PL/SQL Block

Welcome to the second tutorial of the PL/SQL Collection series. In this tutorial we will learn the first type of Collection that is “Nested Table”. A table inside 
a table is the simplest definition one can come up with and it is correct in every way because a table which is embedded inside another table is exactly what the 
name nested table suggests. 

But, if we have to define the collection ‘Nested table’ in a more fancy and technical way then we can say Nested tables are one-dimensional structures that are 
persistent and unbounded in nature. They are accessible in SQL as well as PL/SQL and can be used in tables, records and object definitions. Since it is an 
unbounded PL/SQL collection hence it can hold any number of elements in an unordered set.

Definition : 
	Nested tables are one-dimensional structures that are persistent and unbounded in nature. They are accessible in SQL as well as PL/SQL and can be used in 
	tables, records and object definitions. Since it is an unbounded PL/SQL collection hence it can hold any number of elements in an unordered set.

A nested table can be created inside the PL/SQL block or in database as a collection type object (Schema Object). In case of the former nested table behaves as a 
one-dimensional array without any index type or any upper limit. 

So for the time being let’s concentrate on how to create Nested Table inside PL/SQL block and leave the rest for the next tutorial.

Syntax for Creating Nested Table : 

	DECLRE 
	TYPE nested_table_name IS TABLE OF element_type [NOT NULL];

Example: How to Create Nested Table inside a PL/SQL Block?
The following example is only for demonstrating how to create nested table, there is nothing fancy about it.

	SET SERVEROUTPUT ON;
		DECLARE
			TYPE my_nested_table IS TABLE OF number;
			var_nt my_nested_table := my_nested_table (9,18,27,36,45,54,63,72,81,90);
		BEGIN
			DBMS_OUTPUT.PUT_LINE ('Value Stored at index 1 in NT is ' ||var_nt (1)); 	-- Index starts from 1 and to access we use () not []
			DBMS_OUTPUT.PUT_LINE ('Value Stored at index 2 in NT is ' ||var_nt (2));
			DBMS_OUTPUT.PUT_LINE ('Value Stored at index 3 in NT is ' ||var_nt (3));
		END;
		/

Above example is a very simple one in which we created a nested table and named it ‘my_nested_table’ (line number 3). In the next line (line number 4) we created 
an instance of the same collection and used it to initialize the nested table and store some data into it. In the execution section we access the stored data 
individually using the index number, the same way we used to do in arrays. 

Instead of accessing data one by one manually using index we can use loops and cycle through each element of the collection nested table. 

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nested_table IS TABLE OF number;
		var_nt my_nested_table := my_nested_table (9,18,27,36,45,54,63,72,81,90);
	BEGIN
		FOR i IN 1..var_nt.COUNT
		LOOP
			DBMS_OUTPUT.PUT_LINE ('Value stored at index '||i||'is '||var_nt(i));
		END LOOP;
	END;
	/

That is another example of how to create nested table in which we cycle through the data and display it back to the user using For Loop.


Part 52 - Nested Table as Database Object

If you plan to reuse the nested table that you want to create then doing so as a database object is the best choice for you. You can store them in your database 
permanently and use them whenever you want. 

Apart from creating Nested Table type PL/SQL Collection inside a PL/SQL block you can also create them as database object and store permanently. Also you can 
reuse them whenever you want. Nested table created as database object can be based on either Primitive Datatype or User-Define Datatype. In this tutorial we 
will concentrate on former and leave the latter for the next tutorial.

How to Create Nested table type collection based on primitive datatype : 

By primitive datatype we mean the datatypes which are predefined by the language and are named by a reserved keyword. You can refer to this Oracle Document to read 
more about PL/SQL Datatypes.


The following tables have no constraint, index or anything designed on them and are created purely for demonstrating how to create nested table as database object.


Step 1: Set Server output on
	SET SERVEROUTPUT ON; 

Step 2: Create Nested Table type collection
	CREATE OR REPLACE TYPE my_nested_table IS TABLE OF VARCHAR2 (10);
	/ 
The above statement on successful execution will create a nested table with name ‘my_nested_table’ which will be based on primitive datatype VARCHAR2. 

Step 3: How to use nested table?
The collection type which we created above can be used to specify the type of a column of a table.

	CREATE TABLE my_subject (
		sub_id NUMBER,
		sub_name VARCHAR2 (20),
		sub_schedule_day  my_nested_table
	) NESTED TABLE 	sub_schedule_day STORE AS nested_tab_space;
	/
	
The above table is a normal table except that its 3rd column is of nested table type which can hold multiple values. In order to define a column of a table as 
nested table type you have to tell the compiler the name of the column and a storage table. You can do so by using NESTED TABLE and STORE AS clause, as we did 
here in line number 5. Using clause NESTED TABLE we specify the name of the column and using STORE AS clause we specify the storage table for the nested table.

Insert rows into the table :
	INSERT INTO my_subject (sub_id, sub_name, sub_schedule_day)
	VALUES (101, 'Maths', my_nested_table('mon', 'Fri')); 

You insert rows into the nested table same as you insert into the normal table. However in order to insert data into the column of nested table type you first 
have to write the name of nested table which in our case is ‘my_nested_table’ (refer step 2) and then write the data according to the datatype of your nested 
table and enclose it inside the parenthesis.

Retrieve data from the table :
A simple SELECT DML statement can be used to retrieve the data from the table. 

	SELECT * FROM my_subject; 

This simple DML statement will show you all the data stored into the table that we created above. To see the data from a specific row you can use WHERE clause 
with SELECT DML

	SELECT * FROM my_subject WHERE sub_id = 101; 

If you want then you can take help of sub-query to just check the data from the column which you defined as nested table type.

	SELECT * FROM TABLE (
		SELECT sub_schedule_day FROM my_subject WHERE sub_id = 101
	);
	
The above query will show you the data of subject which has subject-id 101 only from sub_schedule_day column. In this query we used TABLE expression to open the 
instance and display the data in relational format.

Update data of the table
You can either update all the values of the column which you define as nested table or you can update a single instance of the same.

Update all the values of the nested table type column:

	UPDATE my_subject SET sub_schedule_day = my_nested_table('Tue', 'Sat') 
	WHERE sub_id = 101;
	/
The above query will update all the values of sub_schedule_day from ‘Mon’, ‘Fri’ to ‘Tue’ and ‘Sat’. Now suppose you want to update only a single instance of this 
column by replacing ‘Sat’ with ‘Thu’. How will you do that?



Part 53 : Nested Table Using User-Define Datatype

Hey guys! Today we will learn how to create nested table type collection using user-define datatype. Hope you had great time with the last tutorial where we 
learnt the creation process of nested table with primitive datatype. I highly suggest you to take a look at that tutorial as we are going use the concepts from 
there.

Similar to primitive datatype a nested table can be created using user define datatypes also. For the demonstration we will use user Oracle Object. Objects require 
no introduction, if you have ever studied OOP Concepts. In Oracle, like other programming languages, object type is a kind of a datatype which works in the same 
way as other datatypes such as Char, Varchar2, Number etc. but with more flexibility.

To create an Oracle Object we use our old and trusty ‘Create Type’ statement. 
	CREATE OR REPLACE TYPE object_type AS OBJECT (
		obj_id NUMBER,
		obj_name VARCHAR2(10)
	);
	/

The above statement will create an oracle object with the name ‘object type’ with two attributes obj_id and obj_name on successful execution. This datatype then 
can be used to create a nested table. 

	CREATE OR REPLACE TYPE My_NT IS TABLE OF object_type;
	/ 
I think if you checked the last tutorial then you’ll find this above statement very familiar, except the element type which is a primitive datatype there. Here 
we use a user-define datatype which is an Oracle Object. 

What does creating a nested table using Oracle Object means?
Whenever you create a nested table using an Oracle Object then the attributes of the Object become the columns of that table. For example, in our case we created 
a nested table ‘My_NT’ using the user-define datatype which is an Oracle Object ‘Object_Type’ which has two attributes obj_id and obj_name. These two attributes 
of the object will act as the columns of the table. The following pic will help you in understanding this more clearly.

Now that we have created the nested table using user-define datatype it’s time for putting it to some work.

	CREATE TABLE Base_Table(
		tab_id NUMBER,
		tab_ele My_NT
	)NESTED TABLE tab_ele STORE AS stor_tab_1;
	/
The above table named ‘Base_Table’ is a simple one which has 2 columns ‘tab_id’ and ‘tab_ele’. The first column is of Number Datatype while second column is of 
Nested Table type. This means that the second column contains a table into it and that table is our Nested table ‘My_Nt’

Though this ‘Base_Table’ is a simple table but one of its column contains a nested table into it which arises some questions such as:
How to insert data into the table? How to update the data of the table? Or how to retrieve the data from the table? Let’s try to find out the answers to all 
these questions one at a time.

How to insert data into the nested table?
Yes, I agree that inserting data into a table which has a column of nested table type can be tricky but somehow we have to find the way of doing it. As a table 
without data is of no use to us. Right? Let’s see how we can do that.

	INSERT INTO base_table (tab_id, tab_ele) VALUES
	(
	 801, -- value for 1st colum 
	 My_NT (object_type (1,'Superman') -- values for 2nd column )
	);

As you can see in this INSERT statement everything is same as a normal Insert DML except the line number 3 where we are inserting data into the second column of 
the table. In order to insert data into the column which is of Nested Table type you first have to write the name of your nested table which in this case is 
‘My_NT’ then you have to write the name of your Oracle Object which here is ‘Object_Type’ followed by the values you want to insert into your table. 
Don’t forget to match the parenthesis for table name and object name, otherwise you will get an error.

How to update values of the nested table?
	UPDATE base_table SET tab_ele = My_NT(object_type(1,'SpiderMan')) WHERE tab_id = 801;
The above DML statement will update the values accordingly on successful execution. 

How to retrieve data from the nested table?
You can simply execute the Select statement on your table to get the data.

	Select tab_id, tab_ele FROM base_table;

As you can see this SELECT statement will show you the data from the columns which are of primary datatype but only the name of your nested table along with the 
Oracle Object from the column which you define as a Nested Table type. You can easily overcome this problem by using TABLE expression like this.

	SELECT * FROM TABLE(
		SELECT tab_ele FROM Base_Table WHERE tab_id = 801
	)
Successful execution of the above query will show you the data from second column of your table ‘Base_Table’ in a relational format.


Part 54 : Introduction to VARRAYs

VARRAY is an important topic because it is seen that generally there is always a question on it in certification exam. In order to minimize any confusion we will 
first take a brief look at the intro of VARRAYs collection.

VARRAYs which is an acronym of Variable Sized Arrays were introduced in Oracle 8i back in 1998 as a modified format of nested tables. The major modifications can 
be seen in storage orientation. There are no noticeable changes in the implementation but their storage orientation is completely different compared to the 
nested tables. Unlike nested table which requires an external table for its storage, VARRAYs are stored in-line with their parent record as raw value in the 
parent table. It means no more need for STORE AS clause. Oh, what a relief, no unnecessary I/Os and on top of that increased performance. 

Can we save and reuse VARRAYs?
Similar to Nested Tables VARRAYs are Persistent type of Collection which means they can be created as database object that can be saved for later use. 
VARRAYs can also be created as member of PL/SQL Blocks. The scope of the VARRAY which is declared inside a PL/SQL block is limited to the block in which it is 
created. 

Are VARRAYs bounded or Unbounded?
Unlike Nested table VARRAYs are bounded form of collection. By bounded I mean, you have to decide how many elements you want to store in your collection while 
declaring it. Whereas in nested table which is unbounded type of collection there is no upper cap on number of elements. 

VARRAYs Storage Mechanism - 
The storage mechanism of VARRAYs is the biggest difference which makes them a superior choice than Nested tables. Unlike nested tables which requires an external 
table for its storage, VARRAYs are stored in-line with their parent record as raw value in the parent table. This means there is no requirement of STORE AS clause 
or separate storage table.

The in-line storage of VARRAYs help in reducing disk Inputs/Outputs (I/O) which makes VARRAYs more performance efficient than nested table. But when VARRAYs exceed 
4K data then Oracle follows out-of-line storage mechanism and stores VARRAYs as an LOB. 

Syntax for creating PL/SQL VARRAYs - 
In this section we will see the syntax for creating VARRAYs as : 
- Database Object and
- Member of PL/SQL Block.

VARRAY as Database Object :

	CREATE [OR REPLACE] TYPE type_name
	IS {VARRAY | VARYING ARRAY} (size_limit) OF element_type;

VARRAY as a member of PL/SQL Block :

	DECLARE
		TYPE type_name IS {VARRAY | VARYING ARRAY} (size_limit) OF
		element_type;

Both the above syntaxes are same as of nested table except here we have an additional clause which is Size_Limit. Size limit is a numeric integer which will 
indicate the maximum number of elements your VARRAY can hold. 

Always remember similar to nested table we can declare VARRAY only in the declaration section of PL/SQL block.

How to modify the size limit of VARRAYs type collection?
Size limit of a VARRAY can be altered using ALTER TYPE DDL statement.

	ALTER TYPE type_name MODIFY LIMIT new-size-limit [INVALIDATE | CASCADE]

Where ALTER TYPE is a reserved phrase that indicates to the compiler which DDL action you want to perform.
TYPE NAME is the name of type which you want to alter.
MODIFY LIMIT is a clause which informs the compiler that user wants to modify the size limit.
NEW-SIZE-LIMIT is an integer which will be the new size limit of your VARRAY.
INVALIDATE clause is an optional clause which will Invalidate all dependent objects without any checking mechanism.
CASCADE clause again is an optional clause which will propagate changes to dependent types and table.

How to drop a VARRAY type collection?
To drop a VARRAY type you can take help from DROP DDL statement.

	DROP TYPE type_name [FORCE];

Where Drop Type Is a DDL statement using which you can drop any type created on your database.
Type name is the name of an already created type which you want to drop.
Specify FORCE to drop the type even if it has dependent database objects. Oracle Database marks UNUSED all columns dependent on the type to be dropped, and those 
columns become inaccessible. Remember this operation is not recoverable and could cause the data in the dependent tables or columns to become inaccessible. 


Part 55 : How to create varray as PL/SQL block Member 

Previously we discussed in the introduction to PL/SQL VARRAYs that like nested table VARRAYs can be created - 
- As a member of PL/SQL Block and 
- As a database object.

Today we will learn how to create VARRAYs as a Member of PL/SQL block and leave the rest for the future tutorials. 

Step 1: Define a Varray inside PL/SQL block : 
You can define a varray only inside the declaration section of a PL/SQL block. 

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE inBlock_vry IS VARRAY (5) OF NUMBER;

In the above code we created a VARRAY and named it inBlock_vry. This varray is capable of holding 5 elements of Number datatype. 

Step 2: Initialize the Varray : 
Initialization of a varray can easily be done using the collection variable. To initialize the VARRAY we will first define a collection variable and then use it 
for initializing.

	vry_obj inBlock_vry := inBlock_vry();
	
In the above code we created a collection variable with name vry_obj and used that to initialize the varray inBlock_vry. 

Info : Some books refer to collection variable as collection object, so please don’t get confused as both are the same. 

Step 3: How to insert data into the VARRAY: 
Inserting data into the varray is very similar to inserting data into the array of other programming language. You can insert data either directly into each cell 
of the varray using the index number or you can use LOOP for populating the varray. 

Step 3.1: How to insert data into the VARRAY using index of the cell : 
As we know that the structure of a cell PL/SQL collection consists of a cell with a subscript called index. We can use this index for inserting the data into the 
varray. 

Line 5:		BEGIN
Line 6:			vry_obj.EXTEND(5); 
Line 7:			vry_obj(1):= 10*2;
Line 8:			DBMS_OUTPUT.PUT_LINE(vry_obj(1));
Line 9:		END;
Line 10:	/

Execution section - 1
In the above code we wrote the execution section of the PL/SQL block. It consists of 3 executable statements. These three statements are –

Line 6: Statement 1
First statement is an EXTEND procedure call. In this statement we are allocating the memory to each cell of VARRAY using the EXTEND procedure. 

Line 7: Statement 2
In the second statement we are assigning a numeric value (value derived from arithmetic multiplication expression) into the first cell of the varray (cell with 
index number 1). 

Info : In PL/SQL collection VARRAY index number of the cell starts with 1 whereas the index number of cells in array starts with 0. 

Line 8: Statement 3
Third statement is an output statement where we are displaying the value which we stored into the 1st cell of the VARRY back to the user.

That is how you can store and display the value stored in individual cell of the varray. This process is good only when you have a short varray. Otherwise it is not 
an efficient way. Another way of inserting data into the Varray is by using Loop. 

Step 3.2: How to insert data into a VARRAY using PL/SQL Loop
The most common way of dealing with data of a collection is by using Loops. Most programmers are used to using Loops to cycle through the data of any kind of 
array because this is easy, less time consuming and have less line of codes which keep your code cleaner and makes it easy to read. In short it is easy and 
efficient.

Line 5: 	BEGIN
Line 6:			FOR i IN 1 .. vry_obj.LIMIT
Line 7:			LOOP
Line 8:				vry_obj.EXTEND;
Line 9:				vry_obj (i):= 10*i; 
Line 10:			DBMS_OUTPUT.PUT_LINE (vry_obj (i)); 
Line 11:		END LOOP;
Line 12:	END;
Line 13:	/

Execution section - 2 
Still to minimize the confusion I will explain to you here the two main functions used in the above execution section (Execution Section – 2) that are – 
Limit & Extend.

Limit (line 6): Limit is a collection method which returns the maximum number of elements which are allowed in the VARRAY. In our case the maximum number of 
elements which are allowed in the VARRAY is 5 (line 3) which in turn becomes the upper limit of the For-Loop here.

Extend (Line 8): Extend is a procedure which is used for allocating the memory and appends an element to the VARRAY. If used without argument (Execution Section-2 
Line 8) it appends single null element and if used with an argument EXTEND (n) (execution section -1 Line 6) it then appends n numbers to the collection. 
Where n is the integer you supplied as an argument to the procedure EXTEND.


Part 56 - VARRAYs as Database Object

The scope of the VARRAY which is created as PL/SQL block member is limited to the block in which it is created, that means we cannot use this VARRAY outside its 
block or even reuse it and that is its biggest drawback. So go ahead & read on to find out how we can overcome this disadvantage of VARRAY.

This drawback can easily be overcome if we can find out a way to create the VARRAY outside the PL/SQL block and store it permanently into the schema. Fortunately 
we can achieve both the goals by creating the VARRAY as a database object. That is exactly what we are going to learn in this tutorial.

In this tutorial we will learn – 
- How to create VARRAY as database object.
- How to use that varray.
- How to insert data into the VARRAY.
- How to retrieve data from the VARRAY 
- How to update the data of the VARRAY.

How to Create VARRAY as Database Object?

	SET SERVEROUTPUT ON;
	CREATE OR REPLACE TYPE dbObj_vry IS VARRAY (5) OF NUMBER;
	/
Above code on successful execution will create a VARRAY with name dbObj_vry which will have the size limit of 5 elements and their datatype will be NUMBER. This 
VARRAY has wider scope and can be used not only inside the PL/SQL block but also with other schema objects.

How to Use the VARRAY Created as Database Object?
The benefit of defining the VARRAY as database object is that it may be referenced from any program that has the permission to use it. You can use the VARRAY with 
tables, records or even with PL/SQL blocks.

Example 1. How to define a column of a table using VARRAY?

	CREATE TABLE calendar(
		day_name VARCHAR2(25),
		day_date dbObj_vry
	);
	/
In the above code we created a table with the name Calendar which has two columns day_name and day_date. The first column can hold data of VARCHAR2 datatype whereas 
the second column can hold data of a dbObj_vry type which is a VARRAY.

Info: What does defining a column of a table as VARRAY type means?
Defining a column of a table as VARRAY type means that it can hold ‘n’ number of values into it. Where ‘n’ is equal to the size limit of that varray. In our case 
the size limit of VARRAY is 5 that means the column ‘Day Date’ of table Calendar can hold 5 values. 

How to insert data into the VARRAY?
	INSERT INTO calendar ( day_name, day_date ) 
	VALUES ( 'Sunday', dbObj_vry (7, 14, 21, 28) ); 
	
This insert DML statement will insert a row into the Calendar table. Inserting data into the first column ‘Day Name’ which is of varchar2 datatype is easy. You 
just have to write the desired data and enclose it into single quotes. But same is not true with the second column ‘Day Date’ which is of VARRAY type. In order 
to insert data into the column which is of VARRAY type you first have to write the name of the varray and supply the data.

Also, you have to make sure four things - 
- The data that you are supplying must be enclosed inside the parenthesis.
- The Datatype of the data must match with the datatype of the elements of your VARRAY which in our case is NUMBER.
- The number of elements you are inserting into the column must either be less than or equal to the size limit of the VARRAY. In our case it is 5 and we are 
	inserting 4 elements into the column which is completely ok. But if suppose I insert 6 elements into the column then there will be an error.
- If inserting multiple data into VARRAY column then make sure to separate the elements from each other using semi-colon. 

How to retrieve the data from the VARRAY?
Data can be retrieved using SELECT statement. Any correctly written SELECT statement will do the work. For example 
	SELECT * FROM calendar; 
This will retrieve all the data from the table calendar. 

Result 1: Simple SELECT Statement : 
In case you want to display the data stored into the column, which is holding data of VARRAY type, in a relational format then you can take the help of TABLE 
expression. For example

	SELECT 
		tab1.day_name, 
		vry.column_value AS "Date"
	FROM calendar tab1, TABLE (tab1.day_date) vry;
This SELECT statement will show you the data from both the columns in a relational format. The TABLE expression can open the collection instance and represent 
the object rows in relational format.
 
Result 2: TABLE Expression : 
How to update the data of VARRAY type column?
Updating the values of VARRAY type column is pretty simple. Below example will show you how to update the values of day_date columns. 

	UPDATE calendar 
	SET day_date = dbObj_vry(10,14,21,28) 
	WHERE day_name = 'Sunday';

Example 2. How to use VARRAY with PL/SQL block?
In the above example we learnt, how to use the VARRAY which is created as Database object to define the column of a table. Now we will see how to use the same 
varray inside a PL/SQL block. 

DECLARE
	vry_obj dbObj_vry := dbObj_vry();
BEGIN
	FOR i IN 1..vry_obj.LIMIT
	LOOP
		vry_obj.EXTEND; 
		vry_obj(i):= 10*i;
		DBMS_OUTPUT.PUT_LINE(vry_obj(i)); 
	END LOOP;
END;
/

You have seen this example in the last tutorial. There are no such big changes here except that this time instead of defining the VARRAY inside the block we 
created it as a standalone database object. I suggest you to take a look at the last tutorial where I explained the above code in detail.



Part 57 - Associative Array

Associative array is formerly known as PL/SQL tables in PL/SQL 2 (PL/SQL version which came with Oracle 7) and Index-by-Table in Oracle 8 Database. After Nested 
Table and VARRAYs, Associative Array is the third type of collection which is widely used by developers. 

Let’s find out the answers of a few questions about associative array which would help you in understanding them better. In this section you will also find out 
some of the core differences & similarities between Associative Array and other collections such as VARRAY & Nested Tables.

Are Associative arrays bounded or Unbounded?
Similar to Nested tables, Associative arrays are unbounded form of collection. This means there is no upper bound on the number of elements that it can hold. 
Same is not true for VARRAYs as Variable arrays are bounded in nature.

Are Associative arrays persistent or non-persistent?
Unlike Nested Table & VARRAYs, Associative arrays are non-persistent form of collection. This means neither the array nor the data can be stored in the database 
but they are available in PL/SQL blocks only. 

Are Associative arrays sparse or dense?
Whereas VARRAYs are densely populated arrays, Nested tables and Associative Arrays are sparsely populated arrays which mean that subscript numbering must be unique 
but not necessarily sequential. 

Can we create Associative array as database object?
Because of their non-persistent nature Associative arrays cannot be stored into the schema. They can only be created in PL/SQL blocks but not at schema level as 
database object.

Can we reuse associative array?
As mentioned above Associative array is a non-persistent collection which cannot be created at schema level thus it cannot be stored into the schema hence it 
cannot be reused.

Is index numbering/Subscript numbering in Associative array implicit or explicit?
Unlike Nested Tables and VARRAYs, indexing in Associative array is Explicit. Where Oracle Engine assigns subscript/Index number to the elements of the Nested 
table and VARRAY collections implicitly in the background, in associative array users have to specify the index number explicitly while populating the collection.

How does Data gets stored into the Associative Array?
Associative array stores data in Key-Value pairs where index number serves as the key and data stored into the cell serves as the value.

These are a few core questions which you can expect in your exam or interview. Read along to find out the technical differences between Associative arrays and 
other collections.

Define PL/SQL Collection - Associative Array?
Using the information derived from above questions we can define Associative Arrays as one-dimensional, homogenous collection which stores data into key-value pair. 
It is sparse, unbounded and non-persistent in nature.

What is the Syntax of PL/SQL Associative Array?

	TYPE aArray_name IS TABLE OF element_datatype [Not Null]
		INDEX BY index_elements_datatype;
		
As said above Associative array is non-persistent type of collection thus it cannot be created as standalone database object hence cannot be reused like the rest 
of the other collections. It can only be available in PL/SQL block. Always make sure you create your associative array in DELCARATION section of your PL/SQL Block.
[Read here to know how many sections are there in PL/SQL block?] Let’s see the syntax in detail –

Type: Keyword marks the beginning of the statement.

aArray_name: Name of the associative array. It is completely user-defined and complies with Oracle Database naming norms.

IS TABLE OF: Oracle Database reserved phrase using which user tells the compiler what type of elements the array is going to hold? 

Element_Datatype: Datatype of the elements the array is going to hold. In Oracle Database all the collections are homogenous in nature, which means every element 
of the collection must be of the same datatype. 

Not_null: An optional clause, which if used makes sure that every index has a value corresponding to it rather than a NULL.

INDEX BY: Clause using which user specifies the datatype of array’s subscript.

Index_elements_dataype: Datatype of the array’s subscript elements. 

Example: How to Create Associative Array in Oracle Database?
Associative array can only be created inside a PL/SQL block thus its scope is limited to the block in which it is created which means it cannot be used outside 
that block. Let’s see how to create an Associative Array in Oracle Database?

Step 1: Create Associative Array

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE books IS TABLE OF NUMBER
			INDEX BY VARCHAR2 (20);

In the above code we created an Associative array with the name ‘Books’ which can hold elements of NUMBER datatypes and subscript of VARCHAR2 datatype.



Step 2: Create Associative Array Variable

	Isbn Books;
You need an Associative array variable for referencing the array in the program. Array variable can be created very easily. You just have to write the name of the 
variable (which is ‘isbn’ in our case) which is user defined followed by the name of the associative array.

Step 3: Insert Data into the Associative Array
As mentioned above Associative array holds data into key-value pairs. Thus unlike rest of the other collections the users have to insert both the subscript of the 
array (the key) and the data. 

	BEGIN
	-- How to insert data into the associative array 
	isbn('Oracle Database') := 1234;
	isbn('MySQL') := 9876; 
Like Nested table and VARRAYs we insert data into the Associative array in the execution section of PL/SQL block. If you noticed here unlike other collections we 
didn’t use the INSERT DML statement for inserting the data rather we inserted it using the Array variable ‘isbn’ . Below you can see the syntax of insert statement 
for associative array using array variable.

	Array_variable (subscript/key) := data; 
As you can see in order to insert the data into the associative array you first have to write the name of array variable followed by the array’s subscript and 
then the data for your array.

Step 4: How to update the data of collection - Associative array?
Updating values of Associative array is as easy as inserting them. If you want to change any value write the same statement which is used for insertion with the 
modified values. For example say you want to change the value against the key MySQL from 9876 to 1010 then you just write

	-- How to update data of associative array.
	isbn('MySQL') := 1010; 
Again you don’t need to write the UPDATE DML for updating the values. You simply use the array variable.

Step 5: How to retrieve data from the Collection - Associative array?
Just like we don’t need Insert DML statement for inserting values or Update DML for updating values similarly we don’t need Select DML for retrieving values.
Suppose you want to see the value stored against the key ‘Oracle Database’. For that you just need to write…

-- how to retrieve data using key from associative array. 
	DBMS_OUTPUT.PUT_LINE ('Value '||isbn ('Oracle Database'));

Let’s combine all these chunks of code into a single program.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE books IS TABLE OF NUMBER
			INDEX BY VARCHAR2(20);
		isbn Books;
	BEGIN
		-- How to insert data into the associative array 
		isbn('Oracle Database') := 1234;
		isbn('MySQL') := 9876;
		DBMS_OUTPUT.PUT_LINE('Value Before Updation '||isbn('MySQL'));

		-- How to update data of associative array.
		isbn('MySQL') := 1010;

		-- how to retrieve data using key from associative array. 
		DBMS_OUTPUT.PUT_LINE('Value After Updation '||isbn('MySQL'));
	END;
	/

Here is the program with some minute modifications. The above PL/SQL program shows how to retrieve one specific value using the key. 
You can watch the Video Tutorial to learn how to retrieve all the values from Associative Array using Loops. There I have explained it in great detail.

Before winding up this tutorial, there are few pointers which I think you should know. These pointers are –
PL/SQL Associative Array support BINARY_INTEGER, PLS_INTEGER, POSITIVE, NATURAL, SIGNTYPE or VARCHAR2 as index datatype. 
RAW, NUMBER, LONG-ROW, ROWID and CHAR are unsupported index datatypes.

In case of Element Datatype, PL/SQL collection Associative Array Supports –
PL/SQL scalar data type: DATE, BLOB, CLOB, BOOLEAN or NUMBER & VARCHAR2 with their subtypes.
Inferred data: Term used for such data types that are inherited from a table column, cursor expression or predefined package variable
User-defined type: An object type or collection type which is user defined.

That is a detailed tutorial on PL/SQL Collection – Associative Array. This tutorial covers all the topics which you can expect in Oracle Database Certification Exam 
as well as in Interview. Hope you enjoyed reading.


Part 58 - Collection Methods

What are Collection Methods?
Collection methods are PL/SQL’s in-built functions and procedures which can be used in conjunction with collections.

So, what they can do for you? 
Using PL/SQL collection method you can get the information as well as alter the content of the collection.

How many collection methods do we have? 
In Oracle Database we have 3 Collection Procedures and 7 Collection functions. In total we have 10 collection methods. Here are their names —

Collection Functions - 
1. Count
2. Exists
3. First
4. Last
5. Limit
6. Prior
7. Next

Collection Procedures - 
1. Delete
2. Extend
3. Trim

Since the syntax for using the collection built-ins is different from the normal syntax used to call procedures and functions therefore they are referred to 
as methods.

How do we use collection methods? 
In Oracle PL/SQL, collection methods can be used using Dot (.) notation. Let’s take a look at the syntax.
	
	Collection. Method (parameters) 



Part 59 - COUNT Function

I mentioned in the previous tutorial that there are 7 collection functions. Among these seven collection function – COUNT ( ) is the first one which we are going 
to explore in this tutorial. If you are following this series of PL/SQL Collection then you must have already came across this collection function. But as of 
today we have dedicated a full blog to this topic thus we will take the liberty and explore the collection method COUNT ( ) in detail.

What is Collection Method COUNT ( )?
Collection method COUNT ( ) returns the number of elements in an initialize collection. If used with an initialize collection with no elements; it returns zero.

When does Collection Method COUNT ( ) return zero?
Collection method COUNT ( ) returns zero when it is applied or say used with an initialize collection (i.e. VARRAYs & Nested Tables) with no elements. It also 
returns zero as a result when it is used with an empty associated array.

Signature of Collection Method COUNT ( )?
The signature of the function COUNT is –

	FUNCTION COUNT RETURN PLS_INTEGER; 

Does collection method COUNT ( ) works the same with a Nested Table?
No. This is because COUNT ( ), returns the number of non-empty elements in a nested table since it is possible for a collection nested table to have individual 
elements that are empty.

Why the heck am I getting ‘Collection_IS_NULL’ error?
It seems like you are using COUNT ( ) with an uninitialized collection. Whenever you apply collection function COUNT ( ) to an uninitialized collection 
(i.e. Nested Tables & VARRAYs) it raises the ‘Collection_Is_Null’ exception which is a pre-defined exception in Oracle Database. 

As Associative Arrays don’t require initialization, thus you will not get this exception with them.

Examples of Collection Method COUNT ( )
Example 1: Compute total number of elements stored in a Nested table.

You can use COUNT ( ) function to compute total number of elements stored into a collection such as Nested table. 

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nested_table IS TABLE OF number;
		var_nt my_nested_table := my_nested_table (9,18,27,36,45,54,63,72,81,90);
	BEGIN
		DBMS_OUTPUT.PUT_LINE ('The Size of the Nested Table is ' ||var_nt.count);
	END;
	/

Example 2. COUNT ( ) function with IF Condition
You can use COUNT ( ) function to control the flow of the program using a condition. So let’s write a very simple program which will demonstrate how to use 
collection Method COUNT ( ) with IF Condition.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nested_table IS TABLE OF number;
		var_nt my_nested_table := my_nested_table (9,18,27,36,45,54,63,72,81,90);
	BEGIN
		IF var_nt.count >= 10 THEN
			DBMS_OUTPUT.PUT_LINE (‘you have already inserted 10 elements in your Nested table.');
			DBMS_OUTPUT.PUT_LINE ('Are you sure you want to insert more?');
		END IF;
	END;
	/
	
Similarly you can use the collection method COUNT ( ) with Loops. 


Part 60 : Collection Method EXISTS ( )

What is Collection Method EXISTS ( )?
Collection Method EXISTS ( ) checks the existence of an element at a specific index in a collection. If it finds the specified element then it returns TRUE 
otherwise it returns FALSE.

You can use EXISTS ( ) function to check the existence of a specific row within the collection. 

The syntax of EXISTS ( ) function is –

	EXISTS (index number); 

EXISTS function takes the subscript/index number of a cell of a collection as an Input and searches it in the collection. If it finds any element corresponding 
to the index number then it returns TRUE otherwise it returns FALSE. 

Does the collection method EXISTS returns NULL?
No EXISTS function does not return null. It either returns True or False.

What if I remove an already existing row using TRIM or DELETE function? 
If you remove a row using Trim or Delete function then collection method EXISTS ( ) will return FALSE for the index of that row. 

Does the collection method EXISTS raises any exception?
No, collection method EXISTS does not raise any exception. In fact, this is the only function which does not raise any exception, even if it used with an 
uninitialized collection.

If it does not raise an exception then what will happen if I applied this function to an uninitialized collection?
Collection method EXISTS ( ) returns false, if it is applied either to an uninitialized collection or to an initialize collection with no elements.

Example of Collection Method EXISTS ( )
This simple example will show you how to use this function in your application.

	SET SERVEROUTPUT ON;
	DECLARE

		--Declare a local Nested Table
		TYPE my_nested_table IS TABLE OF VARCHAR2 (20);

		--Declare collection variable and initialize the collection.
		col_var_1 my_nested_table := my_nested_table('Super Man','Iron Man','Bat Man');

	BEGIN
		IF col_var_1.EXISTS (1) THEN
			DBMS_OUTPUT.PUT_LINE ('Hey we found '||col_var_1 (1));
		ELSE
			DBMS_OUTPUT.PUT_LINE ('Sorry, no data at this INDEX');
		END IF;
	END;
	/ 

In the above program we are checking if there is any element at index 1 of the collection ‘my_nested_table’ or not. If there is an element at the specified index 
then the IF part of the IF-ELSE statement will execute otherwise the ELSE part will come into the action. 

What will you do…?
Suppose you want to insert a data into a specific index but you are not sure whether that index is already holding some data or not. In case if it is holding 
any then you don’t want to overwrite it. What will you do in this case? 


Part 61 - Collection Function FIRST ( ) & LAST ( )

What are collection methods FIRST ( ) and LAST ( )?
We use collection functions First & Last to know the first and last index values defined in a collection.

Can we use these collection methods with any type of collection?
Yes! You can use both these functions with all three types of collections that are Associative Array, Nested table and VARRAYs.

When does collection method FIRST ( ) and LAST ( ) return null?
Both the functions return null when applied to an empty collection or when applied to an initialize collection that has no elements.

Can you list the function specification for both these functions?
Sure! Why not. The specification for collection function FIRST ( ) is:

	FUNCTION FIRST RETURN PLS_INTEGER | VARCHAR2 
And the function specification for collection function LAST ( ) is:

	FUNCTION LAST RETURN PLS_INTEGER | VARCHAR2 

What if there is only 1 element in my VARRAY?
In that case collection function FIRST ( ) is always 1 and collection method LAST ( ) is always equal to COUNT.

For string indexed associative array, these methods return strings; “lowest” and “highest” are determined by the ordering of the character set in use in that 
session.

What if I applied these functions to an uninitialized collection?
I mean seriously, why would you do so! Anyways if you applied collection function FIRST & LAST to an uninitialized collection then it will raise COLLECTION_IS_NULL 
exception. 

Example: How to use collection function FIRST and LAST with collection?

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE nt_tab IS TABLE OF NUMBER;
		col_var nt_tab := nt_tab(10, 20, 30, 40, 50);
	BEGIN
		DBMS_OUTPUT.PUT_LINE ('First Index of the Nested table is ' || col_var.FIRST);
		DBMS_OUTPUT.PUT_LINE ('Last Index of the Nested table is ' || col_var.LAST);
	END;
	/
	
In the above example we have created a nested table with the name NT_TAB and initialized it using collection variable col_var. This nested table has 5 indexes 
into which we have stored the values. The lowest index in this nested table is 1 which is holding value 10 and maximum index is 5 with value 50. Thus on execution 
the result from the first DBMS_OUTPUT will be 1 and from the second DBMS_OUTPUT statement will be 5. 

What if we delete the first element of the nested table? What will then be the output of collection function FIRST?
That is a very good question! If you delete the first element of the collection function then the collection function FIRST will return the subscript which is 
greater than 1 and is holding some data. Let’s see the example:

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE nt_tab IS TABLE OF NUMBER;
		col_var nt_tab := nt_tab(10, 20, 30, 40, 50);
	BEGIN
		col_var.DELETE(1);
		DBMS_OUTPUT.PUT_LINE ('First Index after DELETE is ' || col_var.FIRST);
	END;
	/
	
In the above example we deleted the first element of the nested table nt_tab using the collection method DELETE. After deleting the first element which is 10 on 
index 1 the new lowest subscript is now 2 which has some data stored into it. Thus on execution the result will be 2.

What if I delete the element from the middle of the collection?
If you delete the data from the middle then the collection function LAST will return a value which is greater than the value returned by COUNT method.

Can we see the data stored into the indexes of the collection using FIRST and LAST collection methods?
When I was explaining this same concept in a class a student raised her hand and asked me.
Sir, so far we see that these functions return the index number of the collection. What if we want to see the data stored into those index. Is there a way to 
see the data stored into the index using these collection methods FIRST & LAST? 
The answer to this question is, yes! Of course. Along with subscript number you can use these functions to see the data stored in lowest and highest index of the 
collection. 

For example

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE nt_tab IS TABLE OF NUMBER;
		col_var nt_tab := nt_tab(10, 20, 30, 40, 50);
	BEGIN
		-- This output statement will return 10 which is the value stored at the first index
		DBMS_OUTPUT.PUT_LINE ('Value stored at First Index is ' || col_var(col_var.FIRST));
		-- This output statement will return 50 which is the value stored at the last index
		DBMS_OUTPUT.PUT_LINE ('Value stored at First Index is ' || col_var(col_var.LAST));
	END;
	/
	
In order to see the data stored into the first and last index you just have to place the function calls of these function inside the parenthesis of collection 
variable which is col_var just like we did in the above example.

Now the question is what if we TRIM the collection? What will then be the output of the collection function LAST? 
Go ahead and check out the video tutorial where I have explained what will be the output of collection method LAST when you trim the collection using the example. 


Part 62 - Collection Function LIMIT

What is Collection Method LIMIT?
Collection method LIMIT which is actually a PL/SQL function returns the maximum number of elements that a VARRAY can hold. This means that by using this function 
you can find out how many elements you can store in a VARRAY.

What does collection method LIMIT return?
Collection method LIMIT returns a value of PLS_INTEGER type. 

Does this function works with other two collections – Nested Tables and Associative Array?
Collection method LIMIT only works with VARRAY. If applied to Nested table or associative array then this function will either return a NULL or No value. 
So the answer is, No, the collection function LIMIT does not work with Nested tables and Associative Arrays.

What is the specification of collection function LIMIT?
The specification of collection function LIMIT is:

	FUNCTION LIMIT RETURN pls_integer; 

Does the collection function LIMIT raises any exceptions? If yes, then when?
Yes the function LIMIT raises COLLECTION_IS_NULL exception if it is applied to an uninitialized nested table or a VARRAY.

Can you show us an example of how to use the function LIMIT?
Sure, why not. Here is a very simple example demonstrating how to properly use collection function LIMIT with VARRAYs.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE inBlock_vry IS VARRAY (5) OF NUMBER;
		vry_obj inBlock_vry := inBlock_vry();
	BEGIN
	--Let's find out total number of indexes in the above VARRAY
		DBMS_OUTPUT.PUT_LINE ('Total Indexes  '|| vry_obj.LIMIT);
	END;
	/

Don’t we have the function COUNT which gives us the same information?
The collection function LIMIT returns the total number of indexes of a VARRAY regardless of whether these indexes are empty or holding some data. It checks the 
definition of the VARRAY and sees the total number of elements that is stored in it and returns that number.
While the collection function COUNT returns the number of Indexes which are not empty and holding some data.

Take a look at this PL/SQL program. It will help you in understanding the difference between collection method COUNT and LIMIT more clearly.

	SET SERVEROUTPUT ON;
	DECLARE
	--Create VARRAY of 5 element
		TYPE inblock_vry IS VARRAY ( 5 ) OF NUMBER;
		vry_obj inblock_vry := inblock_vry ();
	BEGIN
	--Insert into VARRAY
		vry_obj.extend;
		vry_obj(1) := 10 * 2; 
		dbms_output.put_line('Total Number of Index ' || vry_obj.limit);
		dbms_output.put_line('Total Number of Index which are occupied ' || vry_obj.count);
	END;
	/
	
In the above code we have a VARRAY which is capable of holding 5 elements of NUMBER datatype. In the execution section we have two DBMS output statements. 
The first output statement which is showing the result of LIMIT function will return 5 because that is the total strength of our VARRAY while the second output 
statement will return 1 because among those 5 indexes there is only one index which has some data stored into it.

"You said in the video that you will show us how to find out the total number of elements left un-used for us to store data into a varray using collection method 
LIMIT?"
Finding out the number of vacant indexes for your use in a VARRAY is very easy. Let me tell you how. 
As I said above collection function COUNT returns the number of indexes which have data stored into them and collection function LIMIT returns the total number 
of indexes that a VARRAY can accommodate. 
If you subtract the result of count function from the result of the LIMIT function you will get the total number of elements left un-used for you to store data 
into a varray. For example

	DECLARE
	--Create VARRAY of 5 element
		TYPE inblock_vry IS VARRAY ( 5 ) OF NUMBER;
		vry_obj inblock_vry := inblock_vry ();
	BEGIN
		--Insert into VARRAY
		vry_obj.extend;
		vry_obj(1) := 10 * 2;
		dbms_output.put_line('Total Number of Index ' || vry_obj.limit);
		dbms_output.put_line('Total Number of Index which are occupied ' || vry_obj.count);
		dbms_output.put_line('Total Number of Vacant index left for use ' || (vry_obj.limit - vry_obj.count) );
	END;
	/


Part 63 - Collection Function Next & Prior

What are Prior and Next Collection Functions?
It is always good to have some functions under your sleeve which can help you in navigating through the content of your collection. The function Prior & Next 
could be those functions. 

Both these functions take an index of the collection as input and return the result. 
For example PL/SQL collection method PRIOR takes an index as input and returns the value stored into the previous lowest index. Whereas the collection method 
NEXT returns the value from the next higher index. 

Are Prior and Next collection Functions or Procedures?
Both Prior and Next are functions.

Can we use both these functions with all three types of collections?
Yes, both Prior and Next collection functions can be used with all the three types of collections. 

When will PL/SQL Collection Methods Prior and Next return null?
Collection Method Prior returns null when there are no lower subscript values available and Collection method Next returns null when there are no higher subscript 
values available to return. 
In simple words we can say that both these collection functions return Null if they are used with the First and Last indexes of a collection respectively. 

What will be the output of Collection method Next and Prior if we use them with associative array?
If collection method PRIOR and NEXT are used with associative arrays then they will return an output of VARCHAR2 or LONG datatype.

I've heard that, these methods raise some type of exception. Is it true?
Yes, it is true. If either of these functions are applied to an uninitialized Nested Table or a Varray then they raise the COLLECTION_IS_NULL exception.

Can you demonstrate us how to use these functions in our code?
Sure, why not! I will show you the application of both Prior and Next collection functions with the help of a very easy code. 

Example of Collection Method Prior.
In this method we will learn how to use collection method Prior with Nested Table. 

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nested_table IS TABLE OF NUMBER;
		var_nt my_nested_table := my_nested_table(9,18,27,36,45,54,63,72,81,90);
	BEGIN
		dbms_output.put_line('Index prior to index 3 is  ' ||var_nt.PRIOR(3));
		dbms_output.put_line('Value before 3rd Index is '||var_nt(var_nt.PRIOR(3)));
	END;
	/ 

In the above anonymous PL/SQL Block, we have two output statements with ‘Prior Function Call’. The first output statement will return the index number prior to 
the Index number 3 which has some value stored into it. In our case the index prior to index number 3 is 2. Thus 2 will be the output of first output statement.

In the second output statement we called the Prior function and supplied it as an input to the collection object.

	var_nt ( var_nt.PRIOR(3) ) 
	
Oracle engine will execute the Collection function Prior first (let’s call it part 1) and using the result from part 1 it will then execute the 
collection object (let’s call it part 2) and produce the final result which will be 18 in our case.

What will happen if we delete the Previous Lowest Index from the nested table?
So now the question is, what will happen if you delete the Previous Lowest Index which is 2 in our code. In that case, result will definitely not be the same. 
Prior function returns the previous lowest index. But that Index must contain some value. 

	DECLARE
		TYPE my_nested_table IS TABLE OF NUMBER;
		var_nt my_nested_table := my_nested_table(9,18,27,36,45,54,63,72,81,90);
	BEGIN
		var_nt.DELETE(2);
		dbms_output.put_line('Index prior to index 3 is '||var_nt.PRIOR(3)); 
		dbms_output.put_line('Value before 3rd Index is '||var_nt(var_nt.PRIOR(3))); 
	END;
	/ 
	
Output - 
Index prior to index 3 is 1
Value before 3rd Index is 9	
	
Example of Collection Method Next - 
You can use PL/SQL Collection method Next same as you used Prior function in the above code. Collection method NEXT returns the value from the next higher index. 
Here is the example

	DECLARE
		TYPE my_nested_table IS TABLE OF NUMBER;
		var_nt my_nested_table := my_nested_table(9,18,27,36,45,54,63,72,81,90);
	BEGIN
		dbms_output.put_line('Next Higher Index to index 3 is '||var_nt.NEXT(3)); 
		dbms_output.put_line('Value after 3rd Index is '||var_nt(var_nt.NEXT(3)));
	END; 
	/ 

Both the examples are almost the same except the collection function call. In execution section of this PL/SQL block we again have two output statements. The 
first output statement will return the next non-empty index number while the second one will return the data stored into that index. The working of both these 
statements will be the same as we discussed above. 


Part 64 - Collection Procedure Delete

What is PL/SQL collection method Delete?
Collection method DELETE is an overloaded procedure which removes elements from the collection. 

What do you mean by an overloaded procedure? 
You heard it right. PL/SQL collection method DELETE is an overloaded procedure, which means you can use the same procedure in three different ways. 
These three different ways are –
- DELETE: Simple procedure call without any parameters. If the PL/SQL Collection procedure DELETE is used without any parameter then it will remove all the elements 
	from the collection.
- DELETE (index-number): Procedure call with a single parameter. This single parameter is the valid index number of the collection. Collection procedure DELETE 
	called by passing a valid index number will remove the element of the specific index.
- DELETE (start-index, ending-index): Procedure call with two parameters. This way of calling a DELETE procedure is termed as Range delete. In this way you have 
	to specify two Indexes and the procedure deletes the range of elements which fall between starting-index and ending-index.

If the collection is a string-indexed associative array the starting-index and ending-index are string; otherwise starting and ending indexes are integers.

Can we use PL/SQL Collection method DELETE with all the collections?
Yes, collection method DELETE can be used will all three types of collections. These are – Nested table, VARRAYs and Associative arrays.

Wait! But if we use the procedure DELETE with VARRAYs then won’t it make a sparse collection? 
As VARRAY is not a sparse collection hence we cannot delete individual rows from it. The only procedure call we can execute with VARRAY is the first one which is 
collection method DELETE without any arguments which removes all the elements from the collection. The only way of removing an individual row from a VARRAY is 
by trimming it from its end using another procedure call TRIM.

Can we expect any exception with collection method DELETE?
Yes, there is an exception associated with PL/SQL collection method DELETE. If the procedure DELETE is applied to an uninitialized Nested Table and VARRAY then 
it raises a “Collection_is_Null” exception. 

Examples of PL/SQL Collection Method DELETE.
Let’s see some examples of each of the above mentioned Procedure DELETE calls.

Example 1: Simple procedure call without argument.

	DECLARE
		TYPE my_nested_table IS TABLE OF NUMBER;
		var_nt my_nested_table := my_nested_table(2,4,6,8,10,12,14,16,18,20);
	BEGIN
		--Range Delete
		var_nt.DELETE;
		FOR i IN 1..var_nt.LAST 
		LOOP
			IF var_nt.EXISTS(i) THEN
				DBMS_OUTPUT.PUT_LINE('Value at Index ['||i||'] is '|| var_nt(i));
			END IF;
		END LOOP;
	END;
	/

Calling collection procedure DELETE without any argument will delete all the elements of the collection over which it is applied. In the above example we have a 
nested table with the name “my_nested_table” over which we applied the procedure DELETE. On successful execution the procedure call will delete all the 
10 numeric elements which are stored in it. 

Example 2: Procedure call with a single parameter

	DECLARE
		TYPE my_nested_table IS TABLE OF NUMBER;
		var_nt my_nested_table := my_nested_table(2,4,6,8,10,12,14,16,18,20);
	BEGIN
		DBMS_OUTPUT.PUT_LINE('After Deleted');
		--Delete Specific Index
		var_nt.DELETE(5);
		IF var_nt.EXISTS(5) THEN
			DBMS_OUTPUT.PUT_LINE('Value at Index [5] is '|| var_nt(5));
		ELSE
			DBMS_OUTPUT.PUT_LINE('Data is Deleted');
		END IF;
	END;
	/ 

This single parameter is the valid index number of the collection. Collection procedure DELETE called by passing a valid index number will remove the element of 
the specific index. In the above example we specified 5 as the argument to the PL/SQL collection method DELETE. On successful execution the procedure call will 
remove the element from the collection which is stored at index 5.

Example 3: Procedure call with two parameters.

	DECLARE
		TYPE my_nested_table IS TABLE OF NUMBER;
		var_nt my_nested_table := my_nested_table(2,4,6,8,10,12,14,16,18,20);
	BEGIN
		--Delete Range
		var_nt.DELETE(2,6);
		FOR i IN 1..var_nt.LAST 
		LOOP
			IF var_nt.EXISTS(i) THEN
				DBMS_OUTPUT.PUT_LINE('Value at Index ['||i||'] is '|| var_nt(i));
			END IF;
		END LOOP;
	END;
	/

This way of calling DELETE procedure is termed as Range delete. Here you have to specify two Indexes and the procedure deletes the range of elements which fall 
between starting-index and ending-index. In the above example we set the starting index as 2 and ending index as 6 which means on execution the procedure call 
DELETE will remove all the elements which fall into this range.


Part 65 : Collection Procedure EXTEND

What is PL/SQL Collection Method EXTEND?
Similar to DELETE, Collection method EXTEND is an overloaded PL/SQL procedure which is used for appending elements to the collection. 

In how many ways we can call collection method EXTEND?
As PL/SQL Collection Procedure is an overloaded procedure, hence it means that we call this same procedure in different ways. These different ways for calling 
Collection Procedure EXTEND are: 
- Extend: Extend procedure call without any argument. 
	Calling PL/SQL Collection procedure Extend without any argument will append a single NULL element to the collection. 
- Extend (n): Extend procedure call with one argument. 
	Calling PL/SQL Collection procedure Extend with one argument will append the number of NULL elements that you mentioned as the argument of the Extend procedure. 
	Remember that the argument must be a valid Integer value. 
- Extend (n, v): Extend procedure call with two arguments.
	In this case the first argument indicates the number of elements that will be appended to the collection. The second argument is the index number whose value 
	will be copied and assigned to each of the newly appended element of the collection. This form of EXTEND is required for collections with “not null elements”. 

Can we use PL/SQL Collection Method EXTEND with all three types of collections?
No, Collection Method EXTEND can only be applied to collection Nested Tables and VARRAYs. EXTEND cannot be used with collection Associative Arrays.

Can you show us the specification of Collection Method EXTEND?
Sure, why not! Here are the overloaded specifications of PL/SQL Collection Method EXTEND: 

EXTEND with one argument:

	PROCEDURE EXTEND (n pls_integer := 1); 

EXTEND with two arguments:

	PROCEDURE EXTEND (n pls_integer, v pls_integer); 

When should we use collection method EXTEND in our code?
If you have a collection (either Nested Table or VARRAY) in your code which is not 'initialized with sufficient number of elements then you must first use 
PL/SQL Collection Method EXTEND.

What is the requirement of PL/SQL collection Method EXTEND?
Declaring, Defining and Initializing are the three steps which we have to go through while working with collection in Oracle Database but before storing the data 
into the index we need to create a memory slot for it. PL/SQL Collection procedure EXTEND helps us in creating that memory slot for that data. 

What if we have deleted or trimmed the end of the collection?
In that case PL/SQL Collection method EXTEND will skip the deleted elements when it assigns a new index.

What if I apply the collection method EXTEND to an uninitialized Nested table or VARRAY?
If PL/SQL Collection Method EXTEND is applied to an uninitialized collection then it will show a COLLECTION_IS_NULL exception.

And what if I try to EXTEND a VARRAY beyond its defined limit?
If collection method EXTEND is used with VARRAY to extend it beyond its defined limit then you will have to face another exception which is SUBSCRIPT_BEYOND_LIMIT.

Example 1: PL/SQL Collection Procedure EXTEND with No Argument.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nestedTable IS TABLE OF number;
		nt_obj my_nestedTable := my_nestedTable();
	BEGIN
		nt_obj.EXTEND;			--If we are not intializing at the time of declaration then we will have to use EXTEND.
		nt_obj(1) := 10;
		DBMS_OUTPUT.PUT_LINE ('Data at index 1 is '||nt_obj(1));
	END;
	/
	
Example 2: PL/SQL Collection Procedure EXTEND with One Argument.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nestedTable IS TABLE OF number;
		nt_obj my_nestedTable := my_nestedTable();
	BEGIN
		nt_obj.EXTEND(3);		--If we are not intializing at the time of declaration then we will have to use EXTEND.
		nt_obj(1) := 10;
		nt_obj(2) := 20;
		nt_obj(3) := 30;
		DBMS_OUTPUT.PUT_LINE ('Data at index 1 is '||nt_obj(1));
		DBMS_OUTPUT.PUT_LINE ('Data at index 2 is '||nt_obj(2)); 
		DBMS_OUTPUT.PUT_LINE ('Data at index 3 is '||nt_obj(3));
	END;
	/


Example 3: PL/SQL Collection Procedure EXTEND with Two Arguments.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nestedTable IS TABLE OF number;
		nt_obj my_nestedTable := my_nestedTable();
	BEGIN
		nt_obj.EXTEND;
		nt_obj(1) := 28;
		DBMS_OUTPUT.PUT_LINE ('Data at index 1 is '||nt_obj(1));
		nt_obj.EXTEND(5,1);
		DBMS_OUTPUT.PUT_LINE ('Data at index 4 is '||nt_obj(4));		--Outputs -> 28
	END;
	/
	
Example 4: PL/SQL Collection Procedure EXTEND (No Argument) with VARRAY

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_Varray IS VARRAY (5) OF NUMBER;
		vry_obj my_Varray := my_Varray();
	BEGIN
		vry_obj.EXTEND;
		vry_obj(1) := 10;
		DBMS_OUTPUT.PUT_LINE('Data at index 1 is '||vry_obj(1));
	END;
	/

	
Part 66 - Collection Procedure TRIM

What is PL/SQL Collection Method TRIM?
Collection Method TRIM is an overloaded procedure using which you can remove one or more elements from the end of a collection. 

In how many ways can we call the collection method TRIM?
As PL/SQL Collection Method TRIM is an Overloaded procedure thus we can call it in two different ways. These two different calls of TRIM procedure are:
- TRIM: Trim procedure without parameter.
	If we use TRIM procedure without any parameters then it will remove only one element from the end of that collection with which it is used. 
- TRIM (n): Trim procedure with one parameter.
	TRIM procedure called by passing one argument will remove number of elements from the end of the collection as specified by the parameter. That parameter 
	must be a valid Integer number. Also it should not be greater than the maximum number of elements that your collection has. 

Info: Trim procedure will raise an error if there is an attempt to trim space below zero elements.

Can we use PL/SQL collection method TRIM with all the three types of collections?
Unfortunately no, we cannot. Similar to PL/SQL Collection procedure EXTEND, procedure TRIM can only be used with collection Nested Tables and VARRAYs. However 
we cannot use it with Associative Arrays.

What will happen if we use PL/SQL Collection Procedure TRIM with an Associative array?
If collection procedure TRIM is used with an Associative Array then you will get a compile time error.

What is the specification of PL/SQL Collection Procedure TRIM in Oracle Database?
The specification of collection procedure TRIM is: 

	PROCEDURE TRIM (n PLS_INTEGER:= 1); 
If n is NULL then trim will do nothing.

I heard you saying in the video that we can also get SUBSCRIPT_BEYOND_COUNT exception? 
Yes, PL/SQL Collection Method TRIM will raise SUBSCRIPT_BEYOND_COUNT exception if there is an attempt to trim more elements than actually exist in the collection.

Are there any other exceptions associated with PL/SQL Collection method Trim which we should know about?
Yes, there is one more exception associated with TRIM procedure and that is COLLECTION_IS_NULL exception.

Whenever you apply collection procedure TRIM to an uninitialized Nested Table or VARRAY then the compiler will raise COLLECTION_IS_NULL exception.

Can we use TRIM and DELETE procedure together?
No we cannot use collections TRIM and DELETE procedure together. Using them with each other will produce unexpected results. 

Think about a scenario when you have DELETED an element situated in the end of a VARRAY variable and thereafter apply TRIM procedure on the same. Can you guess 
the number of elements that you may have removed? You might be confused into believing that two elements have been removed however the fact is that only one has 
been removed. TRIM acts upon the placeholder left by procedure DELETE.

In order to steer clear of these confusing and unnerving results, Oracle highly recommends that these two procedures should be used exclusively on a given 
collection.

Example 1: PL/SQL Collection Procedure TRIM without parameter.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nestedTable IS TABLE OF number;
		nt_obj my_nestedTable := my_nestedTable(1,2,3,4,5);
	BEGIN
		nt_obj.TRIM;
		DBMS_OUTPUT.PUT_LINE ('After TRIM procedure');
		FOR i IN 1..nt_obj.COUNT
		LOOP
			DBMS_OUTPUT.PUT_LINE (nt_obj (i));
		END LOOP;
	END;
	/ 

Example 2: PL/SQL Collection Procedure TRIM with parameter.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nestedTable IS TABLE OF number;
		nt_obj my_nestedTable := my_nestedTable(1,2,3,4,5);
	BEGIN
		nt_obj.TRIM (3);
		DBMS_OUTPUT.PUT_LINE ('After TRIM procedure');
		FOR i IN 1..nt_obj.COUNT
		LOOP
			DBMS_OUTPUT.PUT_LINE (nt_obj(i));
		END LOOP;
	END;
	/

Example 3: PL/SQL Collection Procedure TRIM SUBSCRIPT_BEYOND_COUNT exception.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE my_nestedTable IS TABLE OF number;
		nt_obj my_nestedTable := my_nestedTable(1,2,3,4,5);
	BEGIN
		nt_obj.TRIM(6);
		DBMS_OUTPUT.PUT_LINE ('After TRIM procedure');
		FOR i IN 1..nt_obj.COUNT
		LOOP
			DBMS_OUTPUT.PUT_LINE (nt_obj(i));
		END LOOP;
	END;
	/

SUBSCRIPT_BEYOND_COUNT exception occurs when we pass an argument greater than the total number of elements of the collection. In the above example the collection 
which we use is Nested table with the name ‘my_nestedTable’ which has 5 numeric elements stored into it. However in the procedure call we instructed the compiler 
to TRIM 6 elements which is definitely impossible thus in this case compiler raises SUBSCRIPT_BEYOND_COUNT exception.

Example 4: PL/SQL Collection Procedure TRIM with VARRAY.

	SET SERVEROUTPUT ON;
	DECLARE
		TYPE inBlock_vry IS VARRAY (5) OF NUMBER;
		vry_obj inBlock_vry := inBlock_vry(1, 2, 3, 4, 5);
	BEGIN

		--TRIM without parameter
		vry_obj.TRIM;
		DBMS_OUTPUT.PUT_LINE ('After TRIM procedure');
		FOR i IN 1..vry_obj.COUNT
		LOOP
			DBMS_OUTPUT.PUT_LINE (vry_obj(i));
		END LOOP;

		--TRIM with Parameter
		vry_obj.TRIM (2);
		DBMS_OUTPUT.PUT_LINE ('After TRIM procedure');
		FOR i IN 1..vry_obj.COUNT
		LOOP
			DBMS_OUTPUT.PUT_LINE (vry_obj(i));
		END LOOP;
	END;
	/

	
Part 67 - Introduction to PL/SQL Ref Cursors in Oracle Database

When it comes to performance, Ref Cursors have always proven themselves superior to static cursors. This is because of the ability of a single ref cursor to 
get associated with multiple SELECT statements in a single PL/SQL block. This then reduces the need for writing separate explicit cursors which in turn makes 
them a highly efficient, flexible and robust feature of PL/SQL language. So let’s explore Ref Cursor in PL/SQL and learn more about it.

What is PL/SQL Ref Cursor?
Ref Cursor is an acronym of Reference to a Cursor. It is a PL/SQL datatype using which you can declare a special type of variable called Cursor Variable.

Are Cursor Variable and Ref Cursor connected to each other?
That is a very good question. I saw in many books that both these names are used interchangeably. Well, both of them are two separate yet inter-dependent topics. 

Cursor variable is like a pointer which refers to different context area in SGA whereas Ref Cursor is a datatype which holds a cursor value. 

Then, how are Cursor Variable and Ref Cursors inter-dependent to each other?
As mentioned above, Cursor Variables are declared with the help of Ref Cursors. We can say that in Oracle Database cursor variables exist in the form of Ref Cursors.

Definition of Cursor Variable - 

Using all the above information we can define cursor variable as:
A variable of Ref Cursor Type is called Cursor Variable.

What is the syntax for Declaring Ref Cursor?
Here is the generalized syntax for declaring Ref cursors in Oracle Database:

	DECLARE
		TYPE [cursor_variable_name] IS REF CURSOR [RETURN (return_type)];

Syntax can be modified and used depending on what type of Ref Cursors you want to use in your application. With that said let’s see the types of Ref Cursors 
available in Oracle Database.

How many types of ref cursors do we have?
There are two types of Ref Cursors in PL/SQL. These are: 
Strong Ref Cursor and
Weak Ref Cursor

What is Strong Ref Cursor in Oracle Database?
Any Ref Cursor which has fixed return type is called a Strong Ref Cursor. 

Such ref cursors can only be used with those SELECT statements that return the result whose datatype matches with the one that we have fixed during the strong 
cursor’s declaration.

Syntax of Strong Ref Cursors in PL/SQL
Here is the strong ref cursor’s syntax.

	DECLARE
		TYPE cursor_variable_name IS REF CURSOR 
		RETURN (return type);
		
Return clause plays a very vital role in declaring a Ref Cursor. It restricts its scope and makes your Ref Cursor limited to only those SELECT statements that 
return the result whose datatype matches with the one you specified in the RETURN clause while declaring it.

Also the return type of a Ref Cursor must always be of Record Datatype. It can either be record structure of a table or user defined record structure. 

What is Weak Ref Cursor in Oracle Database?
In contrast to strong ref cursors, weak ref cursors are those which do not have any return type. In simple words, those ref cursors which do not have fixed return 
type are called weak ref cursors. 

Since weak Ref Cursors do not have any fixed return type thus they are open to all SELECT statements and this makes them one of the most used Ref Cursors in PL/SQL.

Syntax of Weak Ref Cursors in PL/SQL - 

	DECLARE
		TYPE ref_cursor_name IS REF CURSOR;
		
Except from the missing return clause the syntax is pretty much similar to the strong ref cursors.

A Canadian study suggests that humans are biologically wired to be lazy. Also, what is the point of having a computer with all these processing powers when we 
have to do all the hard work of declaring a Ref pointer type and then creating a variable. 

Well, my dear friends if you are one of those who want to refrain from doing all the hard work of creating a Cursor Variable then Oracle PL/SQL has an option 
for you. This option will serve as an implicitly created cursor variable to you. 

Sys_RefCursor :
Sys Ref cursor is an Oracle built in cursor variable. It declares a weak ref cursor and that too without declaring the ref pointer type. It is mostly used as a 
generic cursor which can be passed as an argument to a stored sub program. 


Part 68 - Strong Ref Cursors with Table Based Record Datatype

As we learned in the introduction to PL/SQL Ref Cursor that there are two types of PL/SQL Ref Cursors in Oracle Database. 
Strong Ref Cursors and
Weak Ref Cursors
We will explore all the concepts of both these types of Ref Cursors in this series. With this blog we will start with the first one that is the Strong Ref Cursor. 

What is PL/SQL Strong Ref Cursor in Oracle Database?
A ref cursor which has fixed return type is called a Strong Ref Cursor in Oracle Database. Because of fixed return type, strong ref cursors can only be used with 
those SELECT statements that return the result whose datatype matches with the one that you have fixed during the strong ref cursor’s declaration. 

Can we use Strong Ref Cursor with any SELECT statement in Oracle Database?
No, we cannot use Strong Ref Cursors with any SELECT statement. This is because of the fixed ‘Return Type’. 
A strong ref cursor can only be used with those SELECT statements that return the result whose datatype matches with the ‘Return Clause’ of the cursor. 

Can we use any PL/SQL datatypes for declaring our Strong Ref Cursor?
No, we cannot. The return type of a strong ref cursor must always be a Record Datatype. It can either be a Table Based Record datatype or a User Defined Record 
Datatype. 

Example of Strong Ref Cursor in Oracle PL/SQL
Let’s write an example. In this example we will create a Strong Ref Cursor based on Table Based Record Datatype. 

	SET SERVEROUTPUT ON
	DECLARE
			/*Create Ref Pointer Type*/
		TYPE my_RefCur IS REF CURSOR RETURN employees%ROWTYPE;
			/*Create Cursor Variable*/
		cur_var my_RefCur;
		rec_var employees%ROWTYPE;
	BEGIN
		OPEN cur_var FOR SELECT * FROM employees WHERE employee_id = 100;
		FETCH cur_var INTO rec_var;
		CLOSE cur_var;
		DBMS_OUTPUT.PUT_LINE ('Employee '||rec_var.first_name||' has salary '||rec_var.salary||'.');
	END;
	/

Creation of a Ref Cursor is a two-step process.
Create a ref pointer type. 
First we need to create a ref pointer type. Using the TYPE statement we create a Ref Cursor Type pointer as we did in the above code. In this statement you first 
write the keyword TYPE followed by the name of your ref cursor. After that you have to write a reserved phrase IS REF CURSOR which will tell the compiler that 
we are creating a type which is REF CURSOR followed by that you have to specify the RETURN clause.

For example - 
	TYPE my_RefCur IS REF CURSOR RETURN employees%ROWTYPE; 

Create a Cursor Variable - 
In the second step we create a cursor variable. In order to create a cursor variable you have to first write the name of your variable followed by the name of 
your Ref Cursor. This variable will then be used to refer to the Ref Cursor over which it is created.

For Example - 

	cur_var my_RefCur; 

Apart from the Cursor Variable in the above code we also have an extra variable which is again of table based record datatype and designed using ‘Employees’ table. 
This variable will hold the data fetched from the cursor.

	rec_var employees%ROWTYPE; 

In the execution section of our code we have four executable statements. Let me explain these to you.

OPEN FOR statement
	The first statement is the OPEN FOR statement. It associates the SELECT statement with Cursor’s variable and opens the cursor for the statement. This 
	statement also looks for all the resources required for processing the SELECT statement. 

FETCH statement 
As we discussed in PL/SQL tutorial 26. The process of retrieving data from the cursor is called fetching. In this statement we are fetching the data from the 
Ref Cursor into the record variable ‘Rec_Var’. 

CLOSE Statement
Once we are done with our cursor then it is advisable to close it so that our Oracle Engine / Server can relinquish all the resources associated with it. 
That’s exactly we have done in the third statement. In this statement using CLOSE keyword followed by the cursor variable we closed our ref cursor. 

DBMS_OUTPUT statement 
Fourth statement is a DBMS_OUTPUT statement using which we will display back the first name and the salary of the employee with employee id 100. 

You can watch PL/SQL tutorial 33 in order to learn the workings of a table based record variable. 
In the above code we created a PL/SQL Strong Ref Cursor with the name ‘my_RefCur’ which will return a result table based record datatype. This table based 
record datatype is supported on the Employees table of HR schema. Thus before executing this program we need to make sure that we are connected to the HR 
schema of our database. 

	

Part 69 - Strong Ref Cursors with User-Defined Record Datatype

In the previous tutorial we learnt how to create a PL/SQL strong ref cursor using table based record datatype variable. There I demonstrated the use of strong ref 
cursor to handle the data from all the columns of employees table. This raises the concern that – What if we want the data from some specific column of the table? 
That’s exactly what we will be addressing in today’s tutorial. 

Before moving ahead in this tutorial I suggest you to get acquainted with the knowledge of PL/SQL Ref Cursors, specially the Strong Ref Cursor and User Defined 
Record Datatype. 

The previous tutorial successfully showed how a PL/SQL Strong ref cursor retrieved and handled data from all the columns of a row. But what if we want the data 
from a specific column of a row? Let’s say we just want to see the E-mail or the salary of an employee. We don’t want to spend the expensive resources in 
retrieving all the unnecessary information. Can we use this same ref cursor for that? Let’s find out.

Can we use the Strong Ref Cursor we created in the previous tutorial to retrieve data from a specific column? 
The answer to that question is No, we cannot. 
Because that Strong Ref Cursor was created using Table Based Record Datatype. When we create a table based record datatype Oracle engine creates a composite 
data structure with fields corresponding to each column of the specified table. All these fields automatically get assigned with the same name and same datatype 
as of the columns of the base table. But when it comes to initializing a record using a specific column we have to do all this work manually. 

To understand it more clearly please refer to PL/SQL tutorial 34 on how to initialize record datatype. There I have explained the workings of record datatype in 
detail. 

So, what is the solution to this problem? 

We can easily solve this problem by creating a PL/SQL strong ref cursor with User-Defined Record Datatype variable.

Example: PL/SQL Strong Ref Cursor with User-Defined Record Datatype Variable.

Suppose we want to create a strong ref cursor with the SELECT statement which returns only the salary of the employee whose employee id is 100.

	SET SERVEROUTPUT ON;
	DECLARE
		--Create User-Defined Record Datatype
		TYPE my_rec IS RECORD (
			emp_sal employees.salary%TYPE
		);
		--Declare Strong Ref Cursor
		TYPE RefCur IS REF CURSOR RETURN my_rec;
		cur_var REFCUR;
		--Another anchored datatype variable for holding data
		at_var employees.salary%TYPE;
	BEGIN
		OPEN cur_var FOR SELECT salary FROM employees WHERE employee_id = 100;
		FETCH cur_var INTO at_var;
		CLOSE cur_var;
		DBMS_OUTPUT.PUT_LINE ('Salary of the employee is '||at_var);
	END;
	/ 
Let’s break this code and see what is happening in here.

Declaration Section - 

	DECLARE
		TYPE my_rec IS RECORD (
			emp_sal employees.salary%TYPE
		);
		TYPE RefCur IS REF CURSOR RETURN my_rec;
		cur_var REFCUR;
		at_var employees.salary%TYPE;

Here is our declaration section. In the first three lines of this section we created our user-defined record datatype with the name my_rec. This user defined 
record datatype has only one field which is emp_sal. Emp_sal is an anchored datatype field which is designed over the salary column of the employees table. 
Because emp_sal is of anchored datatype thus it will automatically get assigned the datatype and the data width of the base column which in this case is salary.

Right after that we declared our PL/SQL Strong Ref Cursor with the name “RefCur”. The return type of this strong ref cursor is “my_rec”. Followed by cursor 
declaration we created a cursor variable with the name cur_var. This variable is used for referring to the strong ref cursor ahead in the code.

Apart from cursor variable we also have another variable declared in this section. This variable is “at_var” this is again an anchored datatype variable and is 
used for storing the data returned by the cursor.

Execution Section

	BEGIN
		OPEN cur_var FOR SELECT salary FROM employees WHERE employee_id = 100;
		FETCH cur_var INTO at_var;
		CLOSE cur_var;
		DBMS_OUTPUT.PUT_LINE('Salary of the employee is '||at_var);
	END;
	/ 
This execution section has four executable line of codes. Let’s see what those are.

Line 1: Open For statement
This statement dynamically Opens the mentioned cursor and attaches the SELECT statement that is specified right after the FOR keyword.
In our case this statement is opening the strong ref cursor using the cursor variable “cur_var” – a SELECT statement which is returning the data only from the 
“salary column” of the employees table.

Line 2: Fetch statement
This statement will fetch the data from the ref cursor= and store it into the variable “at_var”. Here we have to make sure that the datatype of the data fetched 
and the datatype of the variable into which the data is getting stored must match otherwise there will be an error.

Line 3: Close statement
The third line is a close statement. Closing a cursor that you are done with is a good practice.

Line 4: Output statement
The last statement of the execution section is the DBMS_OUTPUT statement which is displaying the salary of the employee back to the user.

These four lines complete the execution section of this PL/SQL block.

On successful execution this code should show you the salary with the formatted string. 


	
Part 70 - How to create PL/SQL weak ref cursor

In the previous tutorial we learnt how to fetch data of different datatypes from different columns using the strong ref cursor. The strong ref cursors have a 
limitation that they have fixed return type which can only be a record datatype. However fixed return type makes a strong ref cursor less error prone in the 
application development. But this definitely requires an extra step of creating a user defined record datatype. 

So, don’t we have any alternative way of fetching data of different datatype using ref cursor which doesn’t required the creation of user defined record datatype? 
Can’t we create a ref cursor which doesn’t have a fixed return type? Let’s find out the answers of these questions in this blog.

What is a PL/SQL Weak Ref Cursor in Oracle Database?
A ref cursor which does not have a fixed return type is called a Weak Ref Cursor.

Can we use PL/SQL Weak Ref Cursor with any SELECT statement or not?
Yes, we can. Because weak ref cursors don’t have a fixed return type like strong ref cursors thus they are open to all types of SELECT statements. This also makes 
them most frequently used ref cursors in comparison to others.

I guess now you have got the answers to the above questions. PL/SQL Weak Ref Cursor is the alternative way of fetching data of different datatypes. As weak ref 
cursor doesn’t have a fixed return type thus there is no need of creating a separate record datatype. Now that we have cleared all our doubts it’s time to see 
an example which will help you in learning how to create PL/SQL weak ref cursors in Oracle Database. 

Syntax of Weak Ref Cursor?
	
	TYPE ref_cursor_name IS REF CURSOR; 

Example: How to create PL/SQL Weak Ref Cursor in Oracle Database?

	SET SERVEROUTPUT ON;
	DECLARE
		/*Declare Weak Ref Cursor*/
		TYPE wk_RefCur IS REF CURSOR;

		/*Declare Cursor Variable of ref cursor type*/
		cur_var wk_RefCur;

		/*Declare two "Anchored Datatype Variable" for holding data from the cursor*/
		f_name employees.first_name%TYPE;
		emp_sal employees.salary%TYPE;
	BEGIN
		OPEN cur_var FOR SELECT first_name, Salary FROM employees WHERE employee_id = 100;
		FETCH cur_var INTO f_name, emp_sal;
		CLOSE cur_var;
		DBMS_OUTPUT.PUT_LINE (f_name ||' '||emp_sal);
	END;
	/

	
	
Part 71 - How to create PL/SQL SYS_REFCURSOR

As we learnt in the introduction to the ref cursor that there are three types of PL/SQL ref cursor in Oracle Database.

Strong ref cursor
Weak ref cursor and
SYS_REFCURSOR
So far in this series we have covered the concepts of Strong as well as Weak ref cursor. The only type of cursor which still untouched is PL/SQL SYS_REFCURSOR in 
Oracle Database. Which we will learn in this blog.

What is PL/SQL Sys_Refcursor?
SYS_REFCURSOR is a predefined weak ref cursor which comes built-in with the Oracle database software.

How will its being a pre-defined ref cursor help us?
SYS_REFCURSOR is a predefined weak ref cursor which means we do not have to define it into our code like we did with the explicit weak ref cursor in the previous 
tutorial. As we learnt in that tutorial that creating a weak ref cursor is a two-step process. First you have to create the “weak ref cursor type” and then you 
have to create “a cursor variable” using that ref cursor.

When using SYS_REFCURSOR, you just have to create a cursor variable and nothing else. SYS_REFCURSOR completely minimizes the first step where you create the 
weak ref cursor type. 

So Sys_Refcursor is a built-in ref cursor, where can we find its definition?
You can find out the definition of PL/SQL SYS_REFCURSOR in a script named “stdspec.sql”. You can locate this script into the directory whose path is as follow. 

	%ORACLE_HOME% \RDBMS\ADMIN\stdspec.sql 

SYS_REFCURSOR definition will look something like this:

What type of Ref Cursor a SYS_REFCURSOR is? 
As mentioned above in the definition a SYS_REFCURSOR is a Weak Ref Cursor.

Info : There is no space between REF and CURSOR. It is a single word “RefCursor”.
Wrong: SYS_REF CURSOR
Correct: SYS_REFCURSOR 

Now that you have cleared almost all the doubts about SYS_REFCURSOR. I just want to ask you one last question. 

Why would someone declare a weak ref cursor when we already have predefined one?
That is actually a very good question. The answer to this question is No, we do not need to create a weak ref cursor explicitly. Oracle minimized the need of 
creating a weak ref cursor by shipping SYS_REFCURSOR as a part of standard package since Oracle Database 9i though the option of creating one is still available.

It is like a personal choice, if someone wants to create a weak ref cursor then they can. If not, then they have SYS_REFCURSOR always at their disposal. 

Let’s see a very easy example demonstrating how to use a PL/SQL SYS_REFCURSOR in Oracle Database. 

Example: How to create SYS_REFCURSOR in Oracle Database?
	SET SERVEROUTPUT ON;
	DECLARE
		--Declare cursor variable of SYS_REFCURSOR type
		cur_var SYS_REFCURSOR;

		--Declare variables for holding data
		f_name employees.first_name%TYPE;
		emp_sal employees.salary%TYPE;
	BEGIN
		OPEN cur_var FOR SELECT first_name, Salary FROM employees WHERE employee_id = 100;
		FETCH cur_var INTO f_name, emp_sal;
		CLOSE cur_var;
		DBMS_OUTPUT.PUT_LINE(f_name ||' '||emp_sal);
	END;
	/

	
Part 72 - Introduction to PL/SQL Bulk Collect

A well structured query, written today could save you from catastrophic events in the future. Query performance is something we all seek, but very few 
truly find it. Learning small concepts could help you in gaining experience which could lead to a better query writing skill. Today in this blog you are going 
to learn one of those small concepts that is the “Bulk Collect”. 

Bulk collect is all about reducing context switches and improving the performance of the query. Thus in order to understand what is bulk collect we have to 
first learn what is Context Switching? 

What is Context Switching?
Whenever you write a PL/SQL block or say a PL/SQL program and execute it, the PL/SQL runtime engine starts processing it line by line. This engine processes all 
the PL/SQL statements by itself but it passes all the SQL statements which you have coded into that PL/SQL block to the SQL runtime engine. Those SQL statements 
will then get processed separately by the SQL engine. Once it is done processing them the SQL engine then returns the result back to the PL/SQL engine. So that 
a combined result can be produced by the latter. This to and fro hopping of control is called context switching.

How does context switching affect the query performance?
Context switching has a direct impact on the performance of the query. The higher the hopping of controls the greater will be the overhead which in turn will 
degrade the performance. This means that lesser the context switching better will be the query performance. 

Now you must be thinking “Can’t we do something about this?” Can we reduce those control transitions? Is there anyway using which we can reduce the context 
switches? The answer to all those questions is yes, we do have an option which can help us. That option is Bulk Collect clause. 

What is Bulk Collect Clause?
Bulk collect clause compresses multiple switches into a single context switch and increases the efficiency and performance of a PL/SQL program. 

Bulk collect clause reduces multiple control hopping by collecting all the SQL statement calls from PL/SQL program and sending them to SQL Engine in just one go 
and vice versa.

Where can we use Bulk Collect clause?
Bulk collect clause can be used with SELECT-INTO, FETCH-INTO and RETURN-INTO clauses. 

With the help of Bulk Collect Statement we can SELECT, INSERT, UPDATE or DELETE large data sets from database objects such as Tables or Views.

What is Bulk Data Processing?
The process of fetching batches of data from PL/SQL runtime engine to SQL engine and vice versa is called Bulk Data Processing.

How many bulk data processing statements do we have?
We have one bulk data processing clause which is Bulk Collect and one bulk data processing statement which is FORALL in Oracle Database.

I’ve heard that bulk collect clause uses both implicit as well as explicit cursors?
Yes, you heard it right. We can use Bulk collect clause either inside a SQL Statement or with FETCH statement. When we use bulk collect clause with SQL Statement 
i.e. SELECT INTO it uses implicit cursor. Whereas if we use bulk collect clause with FETCH statement it uses explicit cursor. 


Part 73 



Oracle SQL 
Oracle PL/SQL
Oracle Architerchture
Everything from basic to advance
Collect resources

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	