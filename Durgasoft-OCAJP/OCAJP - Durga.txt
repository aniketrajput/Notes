Part - 1 

If you are working on any technology, compulsory you need to get certified in that technology. 

Until Java 1.6 version --> SCJP
After that Oracle acquired Java so now --> OCJP		(Instead of S for Sun, O for Oracle came)

Exam Duration - 150 minutes
Number of questions - 70
Passing - 65% (Around 46 questions)
Format - Multiple Choice

Demo.java	-> javac(compiler) -> Demo.class(byte code. This byte code is machine independent. We can run it on windows/Linux/mac etc. 
Now JVM is responsible to convert this byte code into respective platform machine code(like windows based JVM will be responsible to convert it to windows specific machine code. Similarly linux based JVM will be responsible to convert it to Linux specific machine code.) 
So java code and byte code is platform independent, but JVM is platform dependent.)

JVM is part of JRE. 

Byte code can run on any platform but make sure the corresponding JVM/JRE is available


- Which statement is true about Java Byte code?
	A) It can run on any platform		- false, because if JRE is not availble how will it run
	B) It can run on any platform only if it was complied for that platform	- False
	C) It can run on any platform that has the JAVA Runtime Enviornment (JRE)	- True
	D) It can run on any platform that has a Java Compiler	- False
	E) It can run on any platform only if that platform has both JRE and Java Compiler - False
	
- Which of the following are true?
	A) Java is platform dependent but JVM is platform independent	- False
	B) Java is platform independent but JVM is platform dependent	- True
	C) Java Byte code is platform dependent but JVM is platform independent	 - False
	D) Java byte code is platform independent but JVM is platform dependent  - True	

- Consider the code
	
	int i = 100;
	float f = 100.100f;
	double d = 123;
	
	Which of the following won't compile?
	
	a) i = f;	//Won't Compile
	b) f = i;	//Compile
	c) d = f;	//Compile
	d) f = d;	//Won't Compile
	e) d = i;	//Compile
	f) i = d;	//Won't Compile
	
- 
class Test
{
	public static void main(String[] args){
		
		int x = 100;
		int a = x++;	//a = 100 ; x = 101
		int b = ++x;	//b = 102 ; x = 102
		int c = x++		//c = 102 ; x = 103
		int d = (a < b) ? (a < c) ? a : (b < c) ? b : c;
		System.out.println(d);		
	}
}

a) 100	
b) 101
c) 102
d) 103
e) Compilation fails - Answer

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 

1. Simple
2. Secure
3. Portable
4. Object-Oriented
5. Robust
6. Multi-threaded
7. Architectural Neutral
8. Interpreted
9. High Performance
10. Distributed
11. Dynamic 

Secure - 
	Byte code is verified by the JVM component called Byte Code Verifier. It checks whether the byte code is valid or not, if it was generated by valid complier, if it contains any malware, etc. If it is not valid then JVM will not execute it. That's why Java program are never harmful. 
	
	byte code -> loaded into JVM memory (by class loader in JVM) -> Bytecode verifier -> then interpretor in JVM will convert to machine code -> machine code -> Execute (Byte code can be verified before it is loaded into JVM memory or after, before makes sense, if its invalid then it won't be loaded.)
	
	First four number is magic number using which it checks if it is generated by valid compiler or not. 
	
Object-Oriented - 
	Features like inheritance(Reusablity), polymorphism(Flexibility), encapsulation(security), etc. 
	Every thing in java is object only, even primitives we can have as objects using wrapper classes. 
	It is OO programming. 
	
	mutple inhertance, operator overloading and several other OO feautures are not supported in java thus it is not Pure OO Programing language.

Robust - 
	Robust means strong, chance of failing is very less. Java is robust because of following features - 
		Type checking by compiler
		Java has garbage collector to manage memory, so memory related problems are very less. Thus failing the program at runtime is very less due to memory problem.
		In build support for Exception handling - try, catch, throws, etc.
		No problem related to platform, because Java is platform independent. 

Platform Independent - 
	Write Once and Run Anywhere
	In old languages like C, program written on windows, might not work on linux		--TRUE

Architecture Neutral - 
	Any change to architecture(RAM, processor, 32 bits, 64 bits, etc., change in windows version) won't affect the java program. 
 
Portability - 
	Without making any change to our java program we can migrate from one machine to another machine (from one platform to another platform). (just like mobile portability, without changing the number we can change the network provider.). Java program is running on windows but we need to migrate it on Linux because window is not free.

Multi-threaded - 
	In build multi-threading concept.
	
	1 person requires 10hrs to complete a tasks
	then 2 person will require only 5hrs
	same terminology is there. 

	If we have 10k lines of code we are executing it line-by-line the it would be sequenctial execution. But if first 5k and second 5k lines are independent of each other then we can have one thread executing first 5k and another thread executing second 5k lines, this is parallel execution (Multi-threading). 
	
	JVM won't convert sequenctial execution to parallel execution automatically, we will have to write the code. By default we have sequenctial execution.

Simple - 
	C/C++ has concepts like pointers
	C++ - create objects, programmer is responsible
		  destroying objects, programmer is responsible
	Java - create objects, programmer is responsible
			destroying objects, GC
			
Distributed - 
	If our program is distributed across several JVMs/Machines then it is called a distributed application. Functionality is distributed across different JVMs. Business logic on one JVM, Frontend logic on another, database logic on another machine/JVM. Performance will be improved. 
	We can develop such kind of applications in java. For this RMI(Remote Method Invocation) or EJB concepts are there and there are many other technologies as well. 
	Advantage of this is Load Balancing, because total load is not on single machine/JVM, it is distributed. Another advantage is Fail Over situations. 

Compiled and interpreted - 
	First it is compiled then then interpreted. Because of compilation all syntax related issue will be found at compile time only. 
	Byte code is interpreted into machine code. 
	Interpretor is responsible for interpreting and executing. 

High Performance - 
	Compared to other interpreted programming languages and not C and C++.
	
	By default every JVM is a HOTSPOT JVM only. 
	Previously suppose we have a method with 1 crore of lines. Then when that method is called FOR FIRST TIME, interpreter will do following for each line - 	read -> interpret -> execute. 
	Now when we call the same method again, same steps will happen - read -> interpret -> execute. 
	Thus JVM with JIT compiler came and it is called as HOTSPOT JVM in 1.2 version. For every method a count is maintained. When count reaches max value or threshold value then it helps JVM to know that this method is very commonly used and so it translated into machine code as whole at once, instead of line by line by JIT compiler and then interpreter will execute that machine code directly.  
	JVM always monitors and optimizes the code internally, coz of this performance is more. (Watch this again.)
	
	
Dynamic programming language - 
	In C - #include<stdio.h>
			This means all the standard input and output header files will be loaded in the beginning only. After loading the program execution will start. This is called static loading. 
	In java nothing will be loaded in the beginning. 
		
		import java.util.*;				//import DOESN't load any thing. When we will use it then it will be loaded.
		
		class Test{
			public static void main(String args[]){
				.......
				
				Date d = new Date();	//Date class will be loaded at this line only. Whenever the class is needed then only it will be loaded. 
			}
		}

	Loading of classes will happen at runtime. At beginning nothing will be loaded. This behavior is nothing but dynamic loading (Loading on demand). 
	
	class Test{
			public static void main(String args[]){
				.......
				
				Student s = new Student();		//1.
				Customer c = new Customer();	//2.	
			}
		}
	
	Test.class will be loaded first
	Student.class will be loaded at 1.
	Customer.class will be loaded at 2. 
	
	If you want to load any class first use static block, it will be loaded at the time of class loading. 
	

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 4 - 

												Java Source File (Test.java)
														|
														|
													Java Compiler	(javac Test.java)	- compiler is also machine/platform independent
														|
														|
													Byte Code	(Test.class)		
														|
														|		------------------- Till here everything is platform?machine independent. Below is platform dependent
														|
							JVM for Windows			JVM for Linux				JVM for MAC
								|						|							|
								|						|							|
							Windows Machine			Linux Machine Code			MAC Machine Code
							Code
							
Developer: 
	Can Develop java program + Run (We need JDK)
	
Client:
	Run	(We need JRE. (JVM is part of JRE, because it will run the program line by line.))

JDK vs JRE vs JVM :

	JDK(Java Development Kit) - Provides environment to Develop and Run java application.

	JRE (Java Runtime Environment) - Provides environment just to Run java applications (and not Develop). Inside JRE, JVM is responsible to run our program line by line(interpret). (So JVM is part of JRE)

	JVM(Java Virtual Machine) - Is an interpretor to run program line by line. (JVM also does many other tasks, its like mini OS.)
	
	(Interpreter is part of JVM, compiler is not. Compiler is part of JDK.)

	 ______________________________
	|JDK		 				   |
	| __________ 	 _____________ |
	||JRE		|   |Development  ||
	||			| + |Tools		  ||	
	||  JVM +	|   | (Java       ||
	||  Library |   |	Compiler, ||
	||  Classes |   |	Debugger,)||	
	||__________|   |_____________||	
	|							   |		
	|							   |	
	|							   |				
	|______________________________|

Library classes might be helper classes for JVM. 


Data types and literals - 

Java is strongly typed programming languge. Type checking is very strong in java. Every variable should have a type and a valid value. 

When compared to languages like C++, more object-oriented concepts are there in java, that's why java is pure object-oriented language.
Again compared to OOP feature like operator overloading, multiple inheritance, etc. java is not pure Object-Oriented language. In OOP language every thing should be in terms of object, but we have primitives also in java which is not a object. So it is and also not a pure Object-Oriented language. 

In java 8 primitives are available - 

Numeric Data Type - 
	Integral -
		byte
		short
		int
		long
		
	Floating point - 
		float
		double

Non-Numeric Data Type - 
	char
	boolean
	
Complex data type is not available in java, but available in python. For this we need to write code.

Except boolean and char all data types are signed. 


----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 5 - 

byte - 
	1 byte = 8 bits. 
	
	| MSB(Most Significant Bit) |    |    |    |    |    |    |    |
		
	MSB is considered as sign bit. It is reserved for sign. 0 means positive number, 1 means negative number. 
	By using remaining 7 bits the max value can be -> 64 (2 ^ 6) + 32 (2 ^ 5) + 16 (2 ^ 4) + 8 (2 ^ 3) + 4 (2 ^ 2) + 2 (2 ^ 1) + 1 (2^0) = +127
    Minimum value = -128
	Negative numbers will not be represented directly into the memory. It will be represented in 2's complement form. Thus using 2's complement -128 is possible. 

	Range: -128 to 127		OR   -2^7 to 2^7 - 1

	If we are going to handle data in terms of Streams(Images, Video files.. ), then we should go for byte data type. Because file supported form or network supported form is byte. 
	
short - 
	Most rarely used data type. 
	Size - 2 Bytes (16 bits)
	Range: 2^15 to 2^15 -1 OR -32768 to 32767
	
int - 
	Most commonly used data type.
	Size - 4 byte (32 bits)
	Range : -2^31 to 2^31 - 1 OR -2147483648 to 2147483647
	
long - 
	E.g. Distance travelled by light in 1000 days.
	
	Size -> 8 bytes (64 bits)
	Range -> -2^63 to 2^63 - 1
		

float and double -
	5 to 6 decimal places(precision) then use float
	14 to 15 decimal places then use double
	
	float size - 4 bytes
	double size - 8 bytes

char - 
	Size = 2 byte
	
	In C and C++ size is 1 byte because it follows ASCII code (< than 256), but java is Unicode based (>256 < 65536) (Can hold world wide characters, 1 byte is not enough). 

boolean - 
	Size and Range - Not Applicable
	
	The way of internal representation of boolean data type depends on JVM to JVM. We don't kown how its represented. 	

String is a object type and not primitive type. For any object reference default value is null. 


----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 6 - 	

Literal means value. 

Integral data types(byte, short, int, long)

1. Decimal (base-10)
	0 to 9

2. Octal(base-8)
	0 to 7
	int x = 010;		//If number is preceding with zero then it is octal
	
3. Hexa decimal(base-16)
	0 to 9, A to F		//we can either use upper case (A) or lower case (a)
	int x = 0x10;		//hexadecimal will precede with 0x or 0X


	eg. - 
	int x = 0777;		//valid
	int x = 0786; 		//invalid. Won't compile, because its considering it as octal
	int x = 0XFace;		//valid
	int x = 0xBeef;		//valid
	int x = 0xBeer;		//invalid. Won't compile. Because r doesn't come in hexadecimal
	
	class Test{
	
		public static void main(String[] args){
			
			int x = 10;
			int y = 010;
			int z = 0X10;
																		//Whenever we are printing the values, JVM will always provide it in decimal form.
			System.out.println(x : "..." + y + "..." + z);				// 10 ... 8 (octal 10 will be converted into decimal 10 -> (1 * 8^1) + (0 * 8^0)) ... 16 (hexadecimal 10 will be converted into decimal 10 -> (1 * 16^1) + (0 * 16^0)) 
		}	
	}
	
	Whenever we are printing the values, JVM will always provide it in decimal form. 

	
10, 010, 0XFACE - all are integral literals. By default they are all int type. Every octal, decimal, hexadecimal literals are int type. 
If we want it as long then it should suffix with L - 10L, 0777L, 0XFaceL

int x = 10; 	//valid
long l = 10;	//valid. 10 by default int type(4 byte). So we are putting 4 bytes literal into 8 byte. Possible.
long l = 10L;	//valid
int x = 10L;	//invalid. 10L means long (8 byte). Cannot put it in 4 byte.

There is no way to explicitly specify byte type and short type - 
	byte b = 100b; 	//invalid
	short s = 100s; //invalid
Whenever we are assigning integral literal to byte or short variable, and if value is within there range, then compiler will treat them as there respective type. 


---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Online Java 11 Session 1 - 


java is more strong in security than python.

When Math.sqr() is executed - 
Math.class is loaded inside JVM memory
static blocks in that class will be executed automatically
Then Maths.sqr() will be executed	


---------------------------------------------------------------------------------------------------------------------------------------

Told to watch all vedios - http://durgasoftvideos.com/core-java-ocjp-scjp-durga/


---------------------------------------------------------------------------------------------------------------------------------------

ARRAYS - 

homogeneous elements - same type 
arrays can hold only homogeneous elements(same type elements)

int[5] a; //Invalid. While declaring don't specify the size
int[] a = new int[5]; //valid. While creating array specify size

int[] []a;	//valid
int[] a[];	//valid
int []a[];  //valid
brackets can be any where, its valid


1. int[] a,b;	//Valid, both are one dimension

2. int[] a[], b; //a is two dimension and b is one dimension

3. int[] []a, b;	//Now both are two dimensions. Before varaible if there are any dimensions(brakets) then they are common for all

4. int[] a,[]b; //Invalid, we cannot specify dimensions for second varaible, only for first varaible like 2.


Array construction - 
Every array in java is an object. (refence varaible pointing to an object in memory)
Object means there must be classes for them, they are in lang package- 
int[] ---> [I
int[][] ---> [[I
double[] ---> [D
byte[] ---> [B
boolean[] ---> [Z

(
check with 
int[] x = new int[3];	
x.getClass().getName()
)


1. int[] x = new int[]; 	//invalid, specify size

2. int[] x = new int[0]; 	//valid, eg. in main method we may or may not pass command line args. If we are not passing anything the size of args array is 0
	x[0] = 10; ArrayIndexOutOfBoundException

3. int[] x = new int[-3];	//Compiler checks if size is int or not, -3 is int. But at runtime JVM will throw an runtime exception - NegativeSizeException. 

4. int[] x = new int['a'];	//size of this array is 97 - ascii. Whereever int value is expected we can provide byte, short and char. It will automatically get converted to int. Check by x.length (length not function in case of array)

Array size is restricted to int size - int x = new int[2147483647]; but at runtime this much memory might not be available and you may get Memory not available exception at runtime.
int x = new int[2147483648];	//Wil get compile time error itself not runtime, coz size is out of int range

Memory is from heap area, heap is part of JVM, JVM is part of RAM, so memory problem is there for large data, to store large data use persistence storage - db, big data, etc.

Integer.MAX_VALUE will give you max value of int, same MIN_VALUE, same for other types as well.

---------------------------------------------------------------------------------------------------------------------------------------

To prevent memory waste in java multi dimension arrays are not implemented as matrix or table, but as Array of arrays (you know this diagram already. Jagged arrays is same as Arrays of arrays)

int[][] x = new int[2][];
x[0] = new int[2];
x[1] = new int[3];


3-dimension array - (check diagram)

int[][][] x = new int[2][][];
x[0] = new int[3][];
x[0][0] = new int[1];
x[0][1] = new int[2];
x[0][2] = new int[3];
x[1] = new int[2][2];	//below level size were fixed or same. 

In multidimension array complusary we need to specify base size (row size)

int[][][] x = new int[2][][5];		//Invalid


ARRAY INITIALIZATION - 

int[] x = new int[3];		// this will intitalize all the array elements to its default value i.e. 0
sysout(x);					//x is reference varaible, whereever we are trying to print object reference internally toString() will be called. It returns 			- 							// classname@hascode_in_hexadecimal_string_form. So Output is - [I@78502e922. We have seen previously int[] class name is [I
sysout(x[0]);		//because of line 1 it will print 0



int[][] x = new int[3][2];
System.out.println(x);				//[[I@2325646e5		Two D arrays have [[ 
System.out.println(x[0]);			// [I@77e512364
System.out.println(x[0][0]);		// 0



int[][] x = new int[3][];
System.out.println(x);				//[[I@2325646e5
System.out.println(x[0]);			// null. Because null is deafulat value for 	object reference
System.out.println(x[0][0]);		//NullPointerException


int[] x = new int[3];
x[-4] = 200;		// compiles file but run time exception - ArrayIndexOutOfBoundException





Seesion 10 missed on 01-11-19
Session 3, Data types ko second session. Session 7 missed..


-----------------------------------------------------------------------------------------------------------------------------------------

java is distributed- functionality is distributed across multiple jvms. So our objects and byte code needs to be send to other jvms across the network. So serialization of byte code is possible. Sending object across the network is called serialization. Or sending object to file. 
 
 Java technology is nothing but java libraries which can be used to develop applications. web applications - Servlet, JSP, etc. Database = JDBC api, EJP, RMI, util, sql package, lang, etc. 
 
 Java enviornment - JDK vs JRE vs JVM
 
 JDK - To develop and run java applications. We can write code, compile, and execute
 
 JRE - We want to deliver the developed application to client - then client is responsible to just run the application - so on client application development enviornment is not required. So it just needs JRE.

 JDK is superior compared to JRE.
 
 JVM - Inside JRE JVM is responsible to run program line by line
 
 JVM will always provide(print) data in decimal. (It will convert octal, hex, binary into decimal and then print it.)
 Integral literal in all four form
 Floating point literal can be specified only in decimal form


-----------------------------------------------------------------------------------------------------------------------------------------


Session 11 - 02/11
 
In multi dimensional array length will represent only base size. 
 
Anonymous arrays - Nameless arrays. If we are going to use an array only once then we can use an anonymous array. Or instance use. We cannot directly acess the, but suppose we want to call a method which is accepting a array, then while calling this method we can pass an anonymous array, as we are not going to use that array later. 

	new int[] {10,20,30}		//unintialized arrays will never be anonymous becasue to initialize we need name.
	
	new int[3] {10,20,30}		//invalid

	2D anonymous arrays - 
	new int[][]{{10,20}{30,40,50}}

	int[] x = new int[3] {10,20,30}		//invalid
	
	
	
Array elements assignments - 

Case 1 : In the case of primitive type arrays, as array elements we can provide any type, which can be implicitly promoted to declared type. 

Case 2 : Object type arrays:
	In the case of Object type arrays, as array elements we can provide either declared type or its child class objects. 
	
In the case of abstract class type arrays, as array elements we can provide its child class objects - 
	Number[]  n = new Number[10];
	n[0]  new Integer(10); 	//Valid
	n[1]  new String(10); 	//Invalid


Case 3 - Interface type arrays - 
	Runnable[] r = new Runnable[10];
	r[0] = new Thread();
	
	Its implemented class type objects are allowed

	
List l = new List[10];
l[0] = new ArrayList();
l[1] = new LinkedList();


We are representing tic tac game as 2-D array.


---------------------------------------------------------------------------------------------------------------------------------------

04-11-19

Array Varaible Assignments. 
- 

	int[] a = {10,20,30};
	char[] ch = {'a','b','c'};

	int[] b = a; //valid
	int[] c = ch; //invalid, becasue char can be promoted to int but char[] (array) cannot be promoted to int[]

	BUT. Sting[] ----> Object[] this promotion is possible, in case of primitive level arrays promotion is not possible but in case of Object type arrays promotion is possible. 

	String[] s = {"S1", "S2"};
	Object[] o = s;			//Valid

	Element level promotions are not applicable at array level. For eg, char can be promoted to int  type but char[] connot be promoted to int[].
	But in case of object type arrays, child type array can be promoted to parent type arrays. 

-

	Compiler always considers only reference type, but at runtime JVM will always consider 'runtime object' type - 
		Object[] a = new String[3];
		a[0] = new Object();		//No compile time error but throws runtime ArrayStoreExceoption
	
	
- 
		
	int[] a = {10,20,30,40,50};
	int[] b = {60,70}

	S1 : a= b 
	S2 : b=a

	Both are valid, becasue whenever we are assign one array to another array it will just make the refence varaible point to another array object. Internal elements wont be copied just reference varaible will be reassigned. Hence sizes are not required to match, but types must be matched.

- 
	int[][] a = new int[3][];
	a[0] = new int[4][5]; 	//invalid
	a[0] = 10;				//invalid
	a[0] = new int[4];		//valid

	Whenever we are assigning one array to another array, dimensions must be matched.
-

int[][] a = new int[3][2];	--- Will created 4 objects
a[0] = new int[3];			--- 1 new object
a[1] = new int[4];			--- 1 new object
a = new int[4][3];			--- 5 objects, a will now refer to this. 

Total how many objects got created? - 11 objects
How many objects are eligible for garbage collection - 6 objects


---------------------------------------------------------------------------------------------------------------------------------------

05-11-19

Local Varaible Type Inference (LVTI) - came in java 10. Only for local variables, no static.
Based on value type will be decided. 
eg - 
	var x = new int[]{10,20,30}; 		//now x will become int[] type based on value


//set path = ...jdk path		// will set path temporarily, from env it will set permanantly


var x = new Integer[]{10,20,30,40}; 		// internally autoboxing will happen where int values will be converted to object Integer, similarly autoUnboxing is also done automatically


var x = {10,20,30,40}; //Invalid

var x = [10,20,30,40]; //Invalid

In java once the type x is decided then throught its life it will be same. 

Class Parent{

}

class Child1 extends Parent{

}

class Child2 extends Parent{

}

Parent[] p = new Child[10];
p[0] = new Child1();
p[1] = new Child2();		//Runtime exception java.lang.ArrayStoreException. Compiler will check only reference type, and at runtime JVM check object


Types of varaibles - 
	Division-1 : Based on type:
		1. primitive varaibles
		2. reference variables
	
	Division-2 : 
		1. Instance varaibles
		2. Static varaibles
		3. Local varaibles

1. Instance varaibles - 
If value of varaible differes from object to object then it is called instance varaible. Separate copy for each object. Created at the time of object creation, and destroyed at the time of object destruction. Scope of it is same as object. 
All objects in java are stored in the heap area. Instance varaibles are part of object.
Instance varaible are declared in the class, outside all methods, no other place, within the class directly. 
To access instance variable we will compulsorily need an object.

class Test{

	int x = 10;

	public static void main(String[] args){
		syso(x);			// Compilation error, we cannot access instance varaible from static area directly. 		
		Test t = new Test();		
		syso(t.x);				// after creating object we can access it in static area using object. 
	}
	
	public void m1(){
		syso(x);		//here we can access directly without object, because this method will be called by using object, i.e after object is created. 
	}
}


For instance variable JVM provides default value, we are not required to provide intitalization.

class Test{

	int x;
	char ch;
	boolean b;
	String s;
	
	public static void main(String[] args){
		Test t = new Test();		
		syso(t.x);			//0
		syso(t.ch);			//space
		syso(t.b);			//false
		syso(t.s);			//null	
	}	
}

Static Varaibles - 
Common to all objects. Single copy for all objects. static variables are created at the time of class loading, .class file loading. At the time of class unloading static variables will be destroyed. If .class file is not there then you static variables are not there. 
We can access it directly from any area. 
can access either by class name or by using object, recommended using class name, can access directly also in same class. 
Static variables will be stored inside method area becasue .class is stored in method area. 
For static variables also we have default values. 
If static variable is final then can't change it. 


class Test{

	static int x = 10;

	public static void main(String[] args){
		syso(x);	// 10
		syso(Test.x);
		Test t = new Test();
		syso(t.x);
	}
}


class Test{

	int x = 10;
	static int y = 20;

	public static void main(String[] args){
		Test t = null;
		
		syso(t.x);		//NullPointerException
		syso(t.y);		//NO EXCEPTION... runs fine... for static object is not required. 
		
	}
}

class Test{

	int x = 10;
	static int y = 20;

	public static void main(String[] args){
		Test t1 = new Test();
		t1.x = 888;
		t1.y = 999;
		
		Test t2 = new Test();
				
		syso(t2.x);		//10
		syso(t2.y);		//999
		
	}
}

---------------------------------------------------------------------------------------------------------------------------------------

06-11-19

If 10 objects are there 10 copies of instance variables and only 1 copy of static variable will be there.

Static variable can only be declare within the class directly and not any where else, not in constructor or not in static blocks. 
If you are declaring a variable not inside a class directly (in method, in instance block, in static block, constructors) it is local variable. 
If a variable is declared inside static block it is local variable, it not like we have to declare compulsory static variable in static block, its not instance variable its local variable, scope is till that block only.

Local variables are stored in stack area. 

For static variables, instance variables default values is provided by JVM, but for local variables default value is not provided by JVM. 

For instance and static variable, JVM provide default values. But for local variables, JVM won't provide deafult values, compulsory we should perform initialization explicitly, BEFORE USING THAT VARIABLE. If we are not using local variable, then we are not required to perform initialization explicitly.
e.g. - 

	public static void main(String[] args){
		
		int x;		// no initialization but still programs works perfectly fine because we are not using the variable
		
		SOP("hello");		
	}


	public static void main(String[] args){
		
		int x;		
		
		SOP("hello : " + x);		//CE Error
	}


	public static void main(String[] args){
		
		int x;		
		
		if(args.length > 0){
			x = 10;
		}
		
		SOP("hello : " + x);		//CE Error, because we pass command line args at run time, this will give error at compile time itself. 
	}
	
	public static void main(String[] args){
		
		int x;		
		
		if(args.length > 0){
			x = 10;
		}
		else{
			x = 10; 
		}
		
		SOP("hello : " + x);		//NO CE error, becasue in this case x will always be initialized
	}
	
	
	public static void main(String[] args){
		
		int i;		
		int j = 10;
		
		if(j < 5){
			j = j++;		//i is not getting initialized in this case and we are using it later, so CE
		}
		else{
			j = j++;
			i = j--;			
		}
		
		SOP(i + j);		//CE error
	}
	

Practive increament and decrement operator related programs.

We cannot define access specifier for local variables. Also local variable cannot be static. Only applicable modifier for local variable is final. 

---------------------------------------------------------------------------------------------------------------------------------------

07-11-19

The only applicable modifier for local variables is final.

Parameter passing mechanism. 

Can't we call methods in same class directly? ..... 


class Test{

	public void m1(){
		i = i + 10;
		j = j +10;
		
		sop(i+":"j);		//110:210	
	}

	public static void main(String[] args){
		
		int i = 100;
		int  j = 200;
		
		Test t = new Test();		
		t.m1(i,j);	//check why we can't call it without object? method is in same class....
		
		sop(i+":"j);			//100:200
	}
}



class Test{

	Test(int x){
		m1(x)
	}

	public void m1(int x){
		this.x = 3 * x;
	}

	public static void main(String[] args){
		
		int x = 10;
		
		Test t = new Test(10);		
		
		sop("x : " + x);			//10
		sop("t.x : " + t.x);			//30		
		
	}
}


class Test{

	int x;
	
	public int m1(int x){
		this.x = this.x + x * x;
		return x;
	}

	public static void main(String[] args){
		int x = 10;
		
		Test t = new Test();		
		sop(t.m1(x));			//10
		sop(t.m1(x));			//10
		sop(t.x + x);			//210
	}
}

---------------------------------

class Demo {
	int x;
	int y;
	
}

class Test{

	public void m1(Demo d){			//d here is local duplicate object reference, its pointing to same object.
		d.x = 888;
		d.y = 999;
		
		sop("Inside method : " + d.x + " : " + d.y);
	}

	public static void main(String[] args){
		
		Demo d = new Demo();
		d1.x = 10;
		d1.y = 20;
		Test t = new Test();		
		t.m1(d);		//whenever we are passing object reference as parameter, then in method duplicate method reference is created and not object.
		
		sop("After completing method:" + d.x " : " + d.y);
	}
}

O/P =>
Inside method : 888:999
After completing method: 888:999




---------------------------------

class Book {
	int pages;
	double cost;	
	
	Book(int p, double c){
		this.pages = p;
		this.cost = c;
	}
}

class Test{

	public void updateBook(Book b, double newCost){
		b.pages = 400;
		b.cost = b.cost + newCost;
	}

	public static void main(String[] args){
		
		Book b = new Book(264, 100.0);
		double newCost = 200.0;
		Test t = new Test();		
		t.updateBook(b, newCost);		
		t.updateBook(b, newCost);
		sop(b.pages " : " + newCost + " : " + b.cost");	//400 : 200.0 : 500.0
	}
}

---------------------------------------

Main method:

class Test{
}
//The code compiles file, because main method is optional, at runtime JVM will check if main method is there or not. It throws runtime exception. 

main method is always public, always static, and will String[] as argument
class Test{
	public static void main(String[] args){}		//for normal method we can pass Object[], but here if we pass we will get runtime error

}

To let JVM call main method from anywhere main() is public
main() is no way related to object, so at the time of calling main() we don't have object, without object JVM needs to call it, so static
JVm is not expecting any return value from main(), so void
'main' this is name configured inside JVM to be called
String[] are command line arguments. 

If it doesn't match the syntax it will compile but throw runtime exception.


---------------------------------------------------------------------------------------------------------------------------------------

08-11-19

public static void main(String[] args){}		//you can write String[] args in any style. We cna take any valid identifier instead of args. 


m1(int... x);	//We can pass any number of int arguments. Including zero. Such type of method is called var arg method. When we pass multiple argumets, then all those values are converted to one dimentional int array -  int[]. Thats why where ever one dimentional array is required we can replace it with var args nethod. 
Thats why public static void main(String... args){} is allowed

main() method can be final, synchronized and strictfp

class Test{
	final static synchronized strictfp public static void main(String[] args){}	//Valid 

}



WHich of the folloing is valid main() method declaration?
A. public static void main(String args){}										//Invalid, String[] required
B. public synchronized strictfp final void main(String args){}					//Invalid. static missing
C. public static void Main(String... args){}									//Invalid. 'Main'
D. public static int main(String[] args){}										//Invalid. return type int
E. public static synchronized final strictfp void main(String... args){}		//Valid
F. public static void main(String... args){}									//Valid
G. public void main(String[] args){}											//Invalid. static missing. 

Inside class, which of the following main() method declarations will cause compile time error?
A. public static void main(String args){}										
B. public synchronized strictfp final void main(String args){}					
C. public static void Main(String... args){}									
D. public static int main(String[] args){}										
E. public static synchronized final strictfp void main(String... args){}		
F. public static void main(String... args){}									
G. public void main(String[] args){}											
H. 	All will compile.
I. None of these			//ANSWER


Overloading concept is possible for main() method. 

class Test{
	public static void main(String[] args){}		//But JVM will always call String[] argument main() method only. 
	
	public static void main(Object[] args){}	//this one we will have to call explicitly.
}


---------------------------------------------

class Parent{
	public static void(String[] args){
		System.out.println("Parent Main Method");
	}
}
class Child extends Parent{

}

Above program will be saved in Test.java file

javac Test.java
java Child

It compiles fine, what will happen at runtime - 
S1: Runtime exception
S2: No runtime exception and Parent's main() is called. 


Inheritance concept applicable for main() method. Hence while executing child class, if child class does not contain main() method then parent class main() method will be executed.


class Parent{
	public static void(String[] args){
		System.out.println("Parent Main Method");
	}
}
class Child extends Parent{
	public static void(String[] args){
		System.out.println("Child Main Method");
	}
}


This concept looks like method overriding but those are static methods, so it is method hiding concept. 
javac Test.java
java Child
O/P = Child Main Method

Which of the following is TRUE?
a. Overloading concept is applicable for main method
b. Inheritance concept applicable for main method. 
c. Main method is mandatory for every java class.
d. If a class does not contain main method then we will get compile time error.
ANSWER - a,b

Until 1.6 version if we are trying to execute a class which doesn't contain main method, then we will get runtime exception - NoSuchMethod-main.
In later version you will get exception like main method not found in class



class Test{
	static{
		System.out.println("Static Block");
	}	
}

o/p => (before 1.7 version)
Static Block
RE: main method is not found

o/p(After 1.7)
RE: main method is not found	(static block will never execute)

static block is executed at the time of class loading, then at the time of class loading how JVM know that main() is not there - 
	jvm is started
	jvm will create and start main thread
	main thread should load Test.class file, but main thread will check if this .class contains the main() method, if not it will not load the class. 
	

---------------------------------------------------------------------------------------------------------------------------------------

09-11-19 - Session 17

Command line arguments - 
we can customize behaviour of main() method. 
No need to hardcode values, pass in command line argument.

whatever argument we pass JVM is responsible to create String[] and then call main()

We have String[] in main() because String is most commonly used data type, there is a way to convert String to other data types.  


java Test A B C //here A is args[0], in some languages Test will be args[0]

---------------------

class Test{
	
	public static void main(String[] args){
		for(int i = 0 ; i <= args.length; i++){
			SOP(args[i]);
		}
	}
}

java Test X Y Z

What is the result?
A) TestXYZ
B)XYZ
C)Compilation Fails
D)An exception is thrown at runtime - Answer - ArrayIndexOutOfBoundException. Watch <= in for loop. 



---------------------

class Test{
	
	public static void main(String[] args){
		
		String[] argh = {'A', 'B', 'C'};
		args = argh;
		
		for(String s : args){
			SOP(s);
		}
	}
}

What is the output in below cases - 
1. java Test			//ABC
2. java Test X Y 		//ABC
3. java Test X Y Z		//ABC



java Test "Sunny Leone"				//If our command line argument contains space then we need to enclose it into double quotes. 


-------------------------------------

class Test{
	
	public static void main(String[] args){
		
		SOP(args[0]+args[1]);		//1020
	}
}

java Test 10 20 


-------------------------------------

class Test{
	
	public static void main(String[] args){
		int x = Integer.parseInt(args[0]);
		int y = Integer.parseInt(args[1]);
		
		SOP(x+y);		//30
	}
}

java Test 10 20 


-------------------------------------
class Test{
	
	public static void main(String[] args){

		SOP(args.length);		
	}
}

java Test ____________ (spaces)		//output - 0
java Test A____________ (spaces)____B		//output - 2


-------------------------------------

generic information related to functionality not related to user can be passed as command line argument. Which DB, system property, etc 

-------------------------------------

Assume that Test.java present in D:\durgaclasses

class Test 
{

}

And command execution - 
javac D:\durgaclasses\Test.java

A. The code won't compile because we are not writing main method. 			//class contain main() or not, these type of things compiler won't check.
B. The code won't compile becasue we are not importing java.lang package
C. The code won't compile because we are not writing package statement.
D. The code won't compile because while compiling we should not use full path like D:\durgaclasses\Test.java
E. None of these

Answer - E. 
		Above code will compile fine but will throw runtime exception - Could not find or load main class D:\durgaclasses\Test
		import and package statements are optional. 
		Compiler won't check if class contain main() method or not.

-------------------------------------

Assume that Test.java present in D:\durgaclasses

class Test 
{
	public static void main(String[] args){
		SOP("Hello world");
	}	
}

javac Test.java
java Test 		//works fine

javac D:\durgaclasses\Test.java			//compiles fine
java D:\durgaclasses\Test				
// will throw an runtime exception could not load main class, ClassNotFoundException, becasue this - 'D:\durgaclasses\Test' total is considered as .class file name


So how we can execute above code - 
java -cp D:\durgaclasses Test				//Hello world. We set classpath

CHECK CH20: CORE JACA WITH OCJP/SCJP: DEVELOPMENT VEDIOS FROM DURGASOFT WEBSITE


---------------------------------------------------------------------------------------------------------------------------------------

10-11-19

Sunday.

---------------------------------------------------------------------------------------------------------------------------------------

11-11-19 - Session 18

Local Variable Type Inference (LVTI) in Java 10 - 
	Type inference: Based on provided value, automatic identification of the type by compiler is called type inference. 
	Automatic detection of data type based on provided value.

	Local variable type inference: Automatic identification of the type for local variables.

	Until 9, for local variables we have to declare the type explicitly. But from Java 10 on wards, we are not required to declare the type explicitly. Based on our provided value, the type will be considered automatically by the compiler. 

	//Will compile in after Java version 9
	var s = "durga";
	
	var l = new ArrayList<Integer>();
	
	var x = new int[]{10,20,30};
	for(var x1 : x){
		SOP(x1);
	}
	
	
Advantages of LVTI - 
- Not required to to specify the type multiple times. It reduces length of the code and readibily will be improved.
- It is more convinent to programmed.

Note: This new concept is already there in other languages like JS, etc. 

Where we can use LVTI: 
1. We can use for local varaible inside a method

2. We can use for local variable inside static/instance blocks, constructors (whereever local variable can be used) -CHECKKKKKK how. Because its local variable and not INSTANCE varaible. We cannot use instance varaible. Check. 

3. As iteration variable inside for-each loop.
	var x = new int[]{10,20,30};
	for(var x1 : x){
		SOP(x1);
	}
	
4. Inside loops for index variables. 
	for(var i = 0; i < x.length; i++){
	
	}

5. As a return value from another method. To store return value of method.
	
	public static int m1(){
		var x = 10;
		return x;
	}
	
	var y = m1();
	
Error Case:

1. We can use LVTI only for local variables but not for instance variables and static variables. If we are trying to use for instance and static variables then we will get compile time error. (There is no concept of local static variables, static are always class level.)

2. var x; // Invalid, value not provided. We cannot use LVTI for unintialized local variables. 

3. var x = null; // Invalid, multiple types can have null value (String, StringBuffer). For null value variables we can't use var. null is allowed for any object type hence compiler can't guess the type uniquely.

4. public void m1(var x) // Invalid, we cannot use var for method parameter type, becasue compiler can't guess the type as values will come at runtime. At runtime there is possibilities to pass any type of argument. i.e. all below calls are possible arguments at runtime but var needs to be replaced with type at compile time only - 
m1(10)
m1("durga")
m1(10.7)	

5. public static var m1() //Invalid, for method return types we can't use var. Compiler don't know what type a method is going to return. 

6. 
	int[] x = {10,20,30};			//Valid
	var x = {10,20,30};				//Invalid
	var x = new int[]{10,20,30};	//Valid
	var x = new int[3]{10,20,30};	//Invalid, size is not required.
	var x = new int[3];				//Valid

7. 
	int if = 20; //Invalid, if is keyword will be used at compile time and runtime. 
	
	var var = 10;			//This is valid, because var is only required at compile time, while compiling compiler will replace it with a type, so at runtime there is no concept of var. Hence var is not required to be a keyword in java. Due to this we can use var as identifier.  
	SOP(var);		

int _x = 10; //valid
int __x = 100; //valid
int _ = 1000; //invalid, as of java 9, _ is a keyword. There is some inbuild functionality provided for underscore. It will work for versions before 9.

Which is valid - 

- var var = 10;					//valid
- var x = null;					//invalid
- var if = 10.5;				//invalid	
- var x = {'a','aa','aaa'}; 	//invalid
- var _="durgasoft";			//invalid
- var x;						//invalid

- var x;						//invalid
	x = 10;		

Which of method declarations are valid - 
- public void m1(var x)			//invalid
- public var m1(int x)			//invalid



---------------------------------------------------------------------------------------------------------------------------------------

12-11-19 - Session 19 - Missed












---------------------------------------------------------------------------------------------------------------------------------------

13-11-19 - Session 20 


In which of the following line we will get compile time error - 
A) Line 1
B) Line 2
C) Line 3
D) Line 4
E) Line 5

class Student{
	String name;
	int rollno;
	
	Student(String n, int r){
		this.name = n;
		this.r = r;
	}
	
	public String toString(){
		return "Name: " + this.name + ", Rollno: " + this.rollno;
	}
}

class Test {
	static var students = new LinkedList<Student>();		//Line 1, Error - var is applicable only for local variables not static and instance
	
	public var info(){										//Line 2, Error - We can't use var on method return type
		var s = new Student("Sunny", 101);					//Line 3, Valid
		var students = new ArrayList<>();					//Line 4			
												//Line 4 - This should be valid, but here we are not specifying type in <>, so it will treat it as a Object type. So we need to override toString() method in Students class, becasue it is calling (Object-Type-)obj.name - thats why error - cannot find symbol student.name  
		students.add("Bunny", 101);
		students.add("Chinni", 102);
		
		for(var student : students){						//Line 5, Valid
			
			//SOP("Name : " + student.name + " RollNo : " + student.rollno);	//This line will throw compile time error - can't find symbol student.name 
			
			//If we are not using toString() then we can type cast student which is Object type to Student type and then use it - 
			//Student s = (Student) student;
		
			
			//Now after adding toString() we will print reference
			SOP(student);
		}
	}

	public static void main(String[] args){
		Test t = new Test();
		t.info;		
	}
}

Answer - A, B 


java 7 <> diamond operator came and java 9 did some enhancement
Whenever we are trying to print object reference internally toString() method will be called. 

------------------------------

Operator and Assignments: 
1.  Increament and Decrement operator:
	
Increament	
	- Pre-increment: y = ++x;			//First increament then assign
	- Post-increament: y = x++;			//First assign then increament
	
Decrement
	- Pre-decrement
	- Post-decrement

- We can use increament and decrement operators only for varaibles but not for constant values otherwise we will get CE.	
	int y = ++10;		//compile time error - operator is only for variable and not constant value.

- Nesting of increament and decrement operators are not allowed. 
	int y = ++(++x);		//compile time error, because after (++x) it will become constant and we are again doing ++ on constant.
	
- x++ and ++x means x = x +1; internally

- Increament and decrement operators are not allowed for final variables

	final int x = 10;
	++x;		//CE. x is final. 

- 	Increament and decrement type is applicable for all primitives except boolean. (Wrapper class it is applicable becasue of autoboxing and autounboxing.)
	
	var ch = 'a';
	SOP(++ch);			//b. Internally it is ch = (char)(ch + 1) => (char) (97 + 1)
	var d = 10.5;
	SOP(++d);			//11.5
	var b = true;		//CE: bad operand type boolean for unary operator ++
	SOP(++b)
	
-  Internal type casting will be performed.
	byte b = 127;
	b++
	SOP(b);		//range of byte is -128 to 127. Internally this line is - b = (byte) (b + 1); => b = (byte) (127 + 1). We won't get any error. Answer will be -128
	
Arithmetic Operator - 
+ - * / %
Whenever we perform adn arithmetic operation using arithmetic operator it will return - internally the return type is implemented as max(int, type of a, type of b)

a + b => then result type is always -> max(int, type of a, type of b)
byte+byte => int return type

byte a = 10;
byte b = 20;
byte c = a+b;			//Error: incompatible types: possible lossy conversion from byte c = a + b. Because byte + byte returns int. It returns int type because at runtime the values of a and b can change, a can become 127 and b can become 127, so a + b will be out of byte range, so its return type is int. 
SOP(c);


byte a = 10;
byte b = 20;
int c = a+b;			// Valid or we can use byte c = (byte)(a + b)
SOP(c);


final byte a = 10;
final byte b = 20;
byte c = a+b;			//No error. O/P -> 30. Because as a and b are final it will be replaced with constant value at compile time itself => byte c = 10 + 30 at compile time. This operation is perform at compile time => byte c = 30;
SOP(c);



final byte a = 100;
final byte b = 100;
byte c = a+b;			//compile time error. Because value will not be in range of byte. 
SOP(c);


final byte a = 10;
byte b = 20;
byte c = a+b;			//compile time error. Because b is non-final and it may change at runtime. 
SOP(c);



---------------------------------------------------------------------------------------------------------------------------------------

14-11-19 - Session 21

If we apply any arithmetic operation between two operants(a and b) the result is always max(int, type of a, type of b)	
Keep the cycle in mind => byte - short - int - long - float - double
								char - int
	
	byte  + byte -> max(int, byte, byte) => int
	byte + short -> max(int, byte, short) => int
	short + short -> max(int, short, short) => int
	
	SOP('a' + 'b') -> max(int, char, char) => int (97 + 98 => 195)	//o/p = 195

	int + long => long
	float + int => float
	double + float = > double

	SOP(10 + 'a')	=> max(int, int, char) -> int (10 + 97 => 107)


SOP(10/0);		//We will get ArithmeticException, max(int, int, int) => int, In integral arithmatic(i.e. byte, short, int, long there is no way to represent infinity. That why RE.)

SOP(10.0/0);		//max(int, double, int) => double, in Floating-Point arithmatic(i.e. float and double) there a way to represent infinity, thats why we won't get run time exception, but result will be "Infinity". 

SOP(0/0);	// 0/0 means undefined max(int, int, int) -> int. So in integral arithmatic to represent undefined there is no way, so RE. 

SOP(0.0/0);  // max(int, double, int) -> double. In float and double there is way to represent undefined and for that NaN(Not A Number) constant is there. So O/p is "NaN"

In java whenever we are dividing by 0, we will get runtime exception arithmetic exception. 

Consider the following lines: 
How many lines will cause a RE - ArithmeticException. 
SOP(10/0);				//RE
SOP(10.0/0);			//Infinite
SOP(-10.0/0);			//-Infinite		obeserve minus
SOP(0/0);				//RE
SOP(0.0/0);				//NaN
SOP(-0.0/0);			//NaN			here no minus just NaN



Float and Double classes contains below constants to represent infinity and undefined - 
public static final float POSITIVE_INFINITY;
public static final float NEGITIVE_INFINITY;
public static final float NaN;

You can see these using javap command -
javap java.lang.Integer


-------------------

Consider the following lines - 
Among below lines how many times we will get true as a answer - 

SOP(10 > Float.NaN);				//false
SOP(10 < Float.NaN);				//false
SOP(10 >= Float.NaN);				//false
SOP(10 <= Float.NaN);				//false
SOP(10 == Float.NaN);				//false
SOP(Float.NaN == Float.NaN);		//false

If we are comparing NaN with any number including NaN, then it will return false. So in all cases we get false

SOP(Float.NaN != Float.NaN);	//true
SOP(10 != Float.NaN);			//true

-------------------------

Which of the following is TRUE about ArithmeticException?
A) It is a Runtime exception, but not compile time error
B) It will be raised only in integral arithmatic but not in floating point arithmatic
C) The only operators which cause ArithmeticException are / and  %
D) All of these
Answer - D


------------------------

Math class check.

String Concatenation Operator(+) : 
The only overloaded operator in java is +

10 + 20 			//first overloading is for numbers
"durga"+"soft"		//second overloading is for Strings

student_object1 + student_object2		//not possible in java, but possible in other languages like python

- If both arguments are numbers then + acts as arithmetic addition operator
- If atleast one argument is String type, then + operator acts as concatenation operator.

Eg - 
	String a = "durga";
	int b = 20, c = 30, d = 40;
	SOP(a + b + c + d);			//durga203040
	SOP(b + a + c + d);			//20durga3040
	SOP(b + c + a + d);			//50durga40	-- becasue left association - first number b + number c i.e. 20+30 = 50 then String a
	SOP(b + c + d + a);			//90durga

------------ 

consider the code, which of the following lines are valid - 
	String a = "durga";
	int b = 20, c = 30, d = 40;

A) a = b+c+d;			//Invalid, int cannot be assigned to String
B) b = a+c+d;			//Invalid, cannot assign String to int
C) a = a+c+d;			//Valid
D) d = b+c+d;			//Valid

--------------------------------------------


int a = 10;
int b = 20;
SOP("a+b="+a+b);					//a+b=1020
SOP("a+b="+(a+b));					//a+b=30
SOP("a+b="+(a)+(b));				//a+b=1020

SOP(a+b+"=a+b="+a+b);				//30=a+b=1020
SOP((a)+(b)+"=a+b="+a+b);			//30=a+b=1020
SOP((a)+(b)+"=a+b="+(a+b));			//30=a+b=30


Relational Operators:

>, >=, <, <= 

Except boolean we can apply relational operators everywhere. 

SOP(10<20);	//true
SOP('a'>'b');	//false
SOP(100>'a');	//true, in such cases smaller type is automatically converted to bigger type. i.e. char to int  -> 100 > 97
SOP(10<10.0);	//false, here int will be promoted to double i.e. 10.0 < 10.0 - false 

SOP(false<true);	//Invalid, CE

Is it possible to apply for Object types? For Wrapper types we can, but we can't apply relational operators for object types like String.

SOP("durga" < "soft");		//CE
SOP("durga".lenght() < "soft".lenght());		//Valid - false

SOP(10<20<30<40);		//Invalid, because - 10<20 will return true - true<30 - Error - CE

Nesting of relational operators not allowed


---------------------------------------------------------------------------------------------------------------------------------------

15-11-19 - Session 22

Equality Operator application everywhere, for primitives and for Object type also.

public static void main(String[] args){

	SOP(10 == 20);					//Valid. false
	
	SOP('a'==97.0);					//Valid. true, whenever we compare lower data type (char) to upper data type(int), then lower data type is conveerted to upper data type
	
	SOP(10.0 == 10.5);				//false
	
	SOP(false == false);			//true
}

We can apply == for Object types also


r1 == r2 returns true iff both are pointing to same object. When there references are same. Reference comparision or Address comparision.

public static void main(String[] args){

	Thread t1 = new Thread();
	Thread t2 = new Thread();
	Thread t3 = t1;
	
	SOP(t1 == t2);		//false
	SOP(t1 == t3);		//true
}

O/p - falsetrue

-------------------------------------

***To use equality operators between object references, compulsory there should be some relation between argument type (either parent to child, or child to parent or same type), if there no relation then we will get Compile Time Error. 

public static void main(String[] args){

	Object o = new Object();
	Thread t = new Thread();
	String s = new String("durga");
	
	SOP(o == t);		//false					
	SOP(t == s);		//CE - incomparable types
	SOP(s == o);		//false	
}


---------------------------------

For  any object reference r, r == null is always fale, but null = null is always true.

public static void main(String[] args){

	Object o = new Object();
	Thread t = new Thread();
	String s = new String("durga");
	StringBuffer sb = null;
	
	SOP(o == null);		//false
	SOP(t == null);		//false
	SOP(s == null);		//false	
	SOP(sb == null);	//false
	SOP(null == null);	//true
}


Difference between == operator and equals method - 

In general, == operator always ment for reference comparision.
In general we can use .equals() method for content comparision.

public static void main(String[] args){

	String s1 = new String("durga");
	String s2 = new String("durga");
	
	SOP(s1 == s2);			//false
	SOP(s1.equals(s2));		//true
}


------------------------------

public static void main(String[] args){

	String s1 = new String("durga");
	String s2 = new String("durga");
	
	s1 = s2;
	
	SOP(s1 == s2);			//true
	SOP(s1.equals(s2));		//true
}


------------------------------

public static void main(String[] args){

	StringBuilder sb1 = new StringBuilder("durga");
	StringBuilder sb2 = new StringBuilder("durga");
	
	SOP(sb1 == sb2);			//false
	SOP(s1.equals(s2));		//false
}

Object class equals() ments for reference comparison. String has overridden it for content comparison. StringBuilder is still using Object's equal(), its not overridden. StringBuffer also uses Object's equals() method, its not overridden in it. 
In StringBuilder equals() method is not overridden for content comparison. Hence Object class equals() method will be executed which is meant for reference comparision. Same concept for StringBuffer.

hashCode means address of object ==> wrong
In String class hashCode() method is overridden based on the content. 
Hence if the content of two string objects is same then their hashcodes are same. 

public static void main(String[] args){

	String s1 = new String("durga");
	String s2 = new String("durga");

	SOP(s1.hashCode() == s2.hashCode());		//true
}


--------------------------------------

***Whenever we are overridding equals() method, it is highly recommended to override hashCode() method. Such that two equivalent objects should have same hashcode.
In String class equals() method is overridden based on content and hence hashCode() method is also overridden based on content.
In StringBuffer and StringBuilder, equals() method is not overridden based on content and hence hashCode() method is also not overridden.

public static void main(String[] args){

	StringBuilder s1 = new StringBuilder("durga");
	StringBuilder s2 = new StringBuilder("durga");

	SOP(s1.hashCode() == s2.hashCode());		//false
}

-----------------------------------

If equals() method's arguments are of different type then equals() method returns false and it won't raise any error. 
If == operators have different arguments and there is no relation between argument types, then == operator will raise compile time error.

public static void main(String[] args){

	String s = new String("durga");
	StringBuilder sb = new StringBuilder("durga");

	SOP(s.equals(sb));		//fasle
	SOP(s == sb);			//CE
}




---------------------------------------------------------------------------------------------------------------------------------------

16-11-19


******** VERY IMPORTANT CONCEPT, MUST WATCH AGAIN.


int[][] x = {{10,20,30},{40,50,60}};
int[][] y = x.clone();   	//Object class clone(), so shallow cloning. 
int[] z = x[0].clone();

SOP(x==y);					//false

SOP(x[1]==y[1]);			//true, its comparing objects and not reference. if only x or only y then reference comparision. x[1] or y[1] object will be compared.

SOP(x[0]==y[0]);				//true

SOP(x[0]==z);				//false

SOP(x.equals(y));			// false.Object class equals() meant for reference comparision.	

Deep Cloning Vs Shallow Cloning - check if durga vedio is there. 

clone() method present in Object class meant for shallow cloning. 
If we want the deep cloning for our objects, we required to override clone() method in our class. 

Shallow cloning will create duplicate objects only for primitive, if its reference then it will not create new object but new references for those objects.

Deep cloning: The process of creating completely independent duplicate object is called Deep cloning. 

Shallow cloning: The process of creating exactly duplicate copy of original object(base object), if original object contains any reference varaibles then duplicate copies won't be created for the contained object, just duplicate reference variables will be created. 

We can use clone in cases like - 
	- We have got a object from outside then we create a clone of that object before making any changes, so that if anything goes wrong we will have original object and we can recover. 
	- If we want to update the cloned object and then compare it with the original one. 
	- If future purpose
	- For backup purpose


int[][] x = {{10,20,30},{40,50,60}};
int[][] y = x.clone();
x[0][1] = 7777;
x[1][2] = 9999;
SOP(y[0][1]) + " : " + y[1][2];				//7777:9999


For predefined classes like Arrays, we cannot have deep cloining. 
For our own custom classes we can override clone() for deep cloning. 



int[][] x = {{10,20,30},{40,50,60}};
int[][] y = x.clone();
x[0] = new int[]{1,11,111};
x[0][1] = 7777;
x[1][2] = 9999;
SOP(y[0][1]) + " : " + y[1][2];				//20:9999

----------------------------------



int[][] x = {{10,20,30},{40,50,60}};
int[][] y = x.clone();
SOP(x == y);				//false
SOP(x.equals(y));			//false, Object class equals()
SOP(x[0] == y[0]);			//true
SOP(x[0].equals(y[0]));		//true


---------------------------------------------------------------------------------------------------------------------------------------

18-11-19

Constructor - AFTER creating object to perform initialization. 

Bitwise operators: 
	& --> AND			- if both operands are true then results is true
	| --> OR			- if atleast one operand is true then the result is true	
	^ --> XOR			- if arguments are different then only result is true
	
	SOP(true & false);			//false
	SOP(true | false);			//true
	SOP(true ^ false);			//true


	Now here in below example - the decimal number we need to first consider as bitwise then perform bitwise operation between them. 
	SOP(4 & 5);			//here bitwise 4 -> 100 and bitwise 5 -> 101 , 100 & 101 -> 100 i.e 4 will be the result. 
							1 0 0
						  & 1 0 1
						  ---------
							1 0 0				//for & if both are true then true, so 1 & 1 -> 1. 0 is false and 1 is true.
	
	SOP(4 | 5);			//101 i.e. 5
	SOP(4 ^ 5);			//001 i.e. 1

For exam we don't have left and right shift operators. 

There operators are applicable only for boolean integral types only, and not on floating type. 


Bitwise complement operator (~) : 

SOP(~true); 		//CE. 

~ is applicable only for internal values and not for boolean values.


SOP(~4); 		//~100 -> 011 i.e. 3 This is wrong.. Output will be -5, because we need to do 32 bit's complement and not 3 bits. If we do 32 bit's complement we 	will get -5 
 

The most significant bit acts as sign bit. 
0 means +ve number
1 means -ve number

The most significant bit means the one in the left. 

+ve number will be represented in memory directly. But -ve number will be represented in 2's complement form. 

How to get 2's complement form:
	Find 1's complement and then add 1
	
	How to find 1's complement - 1's complement means => interchange 0's and 1's.
	

SOP(~4);  

4 ==in memory==> (as its a positive number so most significant bit is 0 and 4 means 100, we want to represent in 32 bit so - ) 000000...0100 (total 32 digits) 

~4 ==> interchange of 0's and 1's => 1111....1011 => In this most significant bit is 1 so -ve number, (as it is -ve number so its 2's complement will be stored, so remaining bits are 2's complement), now find 2's complement for remaining bits - 2's complement of 111...101, 
1's complement = 000...0100, now add 1 => 000...0101, here 101 is 5 and its already -ve so -5

These things are not required for exam.. 


boolean complement operator (!): Only for boolean values. 

SOP(!true); 		//false

-----------------------------------

Short circuit operators: 
&&
||

&, | Vs &&, || :

int x = 10, y = 15;
if(++x < 10 & ++y > 15)//1st condition is false, but still in case of '&' both operands will be evaluted compulsorily, in case of && if first is false then it won't evalute 2nd
{

	++x;
}
else{
	++y;
}

SOP(x: + " : " + y);		//11:17


-----------------------


int x = 10, y = 15;
if(++x < 10 && ++y > 15)		//won't evalute 2nd operand now for &&
{

	++x;
}
else{
	++y;
}

SOP(x: + " : " + y);		//11:16



-----------------------


int x = 10, y = 15;
if(++x > 10 | ++y > 15)		//Observe the change in 1st operand. Now the 1st operand is true, but still 2nd will also evalute, in case of || 2nd won't evalute
{
	++x;
}
else{
	++y;
}

SOP(x: + " : " + y);		//12:16



-----------------------


int x = 10, y = 15;
if(++x > 10 || ++y > 15)
{
	++x;
}
else{
	++y;
}

SOP(x: + " : " + y);		//12:15

So performance wise short curcuit operand &&, || recommended than logical &, |

**** &, | applicable for both integral and boolean
	 &&, || only applicable for boolean type

SOP(true & false);	
SOP(true | false);	
SOP(10 & 20);	
SOP(10 | 20);	
SOP(true && false);	
SOP(true || false);	
SOP(10 && 20);			//CE
SOP(10 || 20);			//CE

-----------------------------------

int x = 10;

if(++x < 10 && (x/0>10))
{
	SOP("Hello")
}
else{
	SOP("Hi");	
}

A) Compilation fails
B) ArithmeticException is thrown at runtime
C) Hello
D) Hi		-- Answer



-----------------------------------

int x = 10;

if(++x < 10 & (x/0>10))
{
	SOP("Hello")
}
else{
	SOP("Hi");	
}

A) Compilation fails
B) ArithmeticException is thrown at runtime -- Answer
C) Hello
D) Hi		


---------------------------------------------------------------------------------------------------------------------------------------

19-11-19

instanceof operator:			//instanceOf	- CE

To check if given object is of particular type or not. 
eg - 
s instanceof Student

Suppose we have a ArrayList, it can hold any type of objects, like first is Student, second is Customer, etc. 
Object o = l.get(0);
if(o instanceof Student){
	Student s = (Student) o;

	//perform Student specific functionality
}
else if(o instanceof Customer){
	Customer s = (Customer) o;

	//perform Customer specific functionality
}


Thread is child class of Object. Thread is implementation class of Runnable interface also. 
Every child is of parent type automatically.

Thread t = new Thread();
SOP(t instanceof Thread);		//true

SOP(t instanceof Object);		//true

SOP(t instanceof Runnable);		//true

SOP(t instanceof String);		//CE, to use instanceof operator there should be some relation between argument types. It won't return false

SOP(t instanceof Callable);		//false, Callable also doesn't have any relation with Thread. Here it didn't give CE here, becasue for interface type there is this relaxation. If its a class the CE, if interface then false. 

SOP(t instanceof Callable);		//false

To use instanceof operator ther should be some relation between argument types, otherwise we will get compile time error. But this rule is not applicable if the argument is interface type. 


Study Multithreading enhancement...............


Object o1 = new Object();
SOP(o1 instanceof String);		//false, relation is there but internally o is not String object. 

Object o2 = new String("durga");
SOP(o2 instanceof String);		//true, because internal object is String now.


For any class or interface X, null instanceof of X is always false - 

SOP(null instanceof String); //false, becasue internally there is no object.
SOP(null instanceof Thread); //false
SOP(null instanceof Runnable); //false


Assignment operators:

1. Simple assignments:
	int x = 10;

2. Chained assignments:
	a = b = c = d = 20;
	
3. Compound Assignments:
	x += 10;
	
	-=, *=, %=, /=
	>>=, >>>=, <<=
	&=
	|=
	^=

	
int a = b = c = d = 10;				
SOP(a + " : " + b + " : " + c + " : " + d);

//CE, in 1st line we are only declaring a but not c, d, b 	
	

int a,b,c,d;
a = b = c = d = 10;				
SOP(a + " : " + b + " : " + c + " : " + d);		//10:10:10:10


int x = 10; 
x += 20;
SOP(x);		//30


---------------------------

byte b = 10;
b = b +1;			//max(int, byte, int) => int, we cann't assign int to byte so CE - incompatable type
SOP(b);


byte b = 10;
++b;				//In case of increament and decrement operator inplicit type casting will be performed, so O/P is 11
SOP(b);


byte b = 10;
b+=1;				//This internally becomes b = (byte)(b+1);		// here also implicit type casting is done, so O/P is 11
SOP(b);


-----------------------------


int a, b, c, d;
a = b = c = d = 20;								//Assignment is Right to left, right associative.

a += b -= c *= d /= 2;							//Assignment is Right to left, right associative. So first d /= 2 will evalute 

SOP(a + " : " + b + " : " + c + " : " + d);				// -160 : -180 : 200 : 10



---------------------------------------------------------------------------------------------------------------------------------------

20-11-19 - Session 25

Conditional Operator (? :) - Ternary operator (has three operands)

Nesting of ternary operator is possible. 

The operators are left associative for same precedence.
If assignment is there then it right associative - a = b = c = d

class Test {
	
	static double price = 10.5;
	
	public static void main(String[] args){
		double price = 20.6;
		
		if(checkPrice()){
			SOP("It is too costly");
		}
		else{
			SOP("It is not costly");
		}
	}
	
	public static boolean checkPrice(){
		boolean result = (price > 15) ? true : false;
		return result;
	}
}

O/P = It is not costly


----------------------------------


class Test {
	
	static double price = 10.5;
	
	public static void main(String[] args){
		double price = 20.6;
		
		if(checkPrice(price)){					//argument is passed.
			SOP("It is too costly");
		}
		else{
			SOP("It is not costly");
		}
	}
	
	public static boolean checkPrice(){
		boolean result = (price > 15) ? true : false;
		return result;
	}
}

O/P = It is too costly


-------------------------------


class Test {
	
	static double price = 10.5;
	
	public static void main(String[] args){

		int a = 10, b = 20, c = 30, d = 40;
		int result = (a < b) ? c : (c < d) ? d : (a > b) ? (a + b);		//syntax in not right. CE, not proper declaration of ternary operator
		
		SOP(result);		
	}
}


-------------------------------


class Test {
		
	public static void main(String[] args){

		int a, b, c, d;
		
		a = b = c = 20;
		
		a += (b += c) / 10;							// a += 40 /10 	b=40 => a += 4 => 24 
		
		SOP(a + ":" + b + ":" + c);		24:40:20
	}
}



-------------------------------


class Test {
		
	public static void main(String[] args){

		int i = 0;
	
		i += i++ + ++i + i++ + ++i;			// => i = i + (i++ + ++i + i++ + ++i)	=> i = 0 + (0 + 2 + 2 + 4)	=> 8
	
		SOP(i);		//8
	}
}


-------------------------------


class Test {
		
	public static void main(String[] args){

		int x = 10;
		
		x = ++x;			//1. Pre increment x value (x = 11)
							//2. Consider x value for assignment (11)
							//3. Perform assignment
		x = ++x;
		x = ++x;
		x = ++x;
		
		SOP(x);	//14
	}
}




-------------------------------


class Test {
		
	public static void main(String[] args){

		int x = 10;
		
		x = x++;				//1. Consider x value 10 for assignment (10), (Observe it is just considering and not actually assigning. Its post increment, so first use the value then increment.)  
								//2. Post increment x value (x = 11) 
								//3. Perform assignment with old considered value x = 10, now here again x becomes 10 from 11 due to actual assignment. 
								// 	 Assignment has less precedence, so it will be always performed last.
		x = x++;
		x = x++;
		x = x++;
		
		SOP(x);		//10
	}
}



-------------------------------


class Test {
		
	public static void main(String[] args){

		int x = 10;
		
		x++;
		x++;
		x++;
		x++;
		
		SOP(x);		//
	}
}




-------------------------------


class Test {
		
	public static void main(String[] args){

		int x = 10;
		int y =	x++;
		
		SOP(y);		//10
		SOP(x);		//
	}
}


-------------------------------


class Test {
		
	public static void main(String[] args){

		int x = 10;
		int y =	10;
		
		y = x++;
		y = x++;
		y = x++;
		y = x++;
		
		SOP(y);		//13
		SOP(x);		//14
	}
}



---------------------------------------------------------------------------------------------------------------------------------------

21-11-19 - Session 26

Operator Precedence - 

++x => unary operator
a+b => binary
?: => ternary

First highest precedence is of unary operators, then binary, then ternary. 

= assignment has least precedence of all. Because assignment always happens at last. 


Precedence order:
1. parenthesis ()
2. x++ , x--	unary
3. ++x, --x, ~, !			//post increment and decrement has more priory than pre increment and decrement
4. new, type case
5. Arthematic *, /, %		//from here binary starts
6. Arthematic  + - 
7. >>, >>>, <<
8. comparision operators <, <=, >, >=, instanceof
9. Equality ==, !=
10. Bitwise &
11. Bitwise ^
12. Bitwise |
13. &&
14. ||
15. ?:						//Ternary
16. Assignment =, +=, *=, .........




 -----------------------------------
 
 class Test {
		
	public static void main(String[] args){

		SOP(m1(1) + m1(2) * m1(3) / m1(4) * m1(5) + m1(6));		//Before applying any operator all operands will be evaluted from left to right.	
																// 1 + 2 * 3 / 4 * 5 + 6 => 1 + 6 / 4 * 5 + 6 =>		1 + 1(integral division)* 5 + 6 => 1 + 5 + 6 => 12
	}
	
	public static int m1(int i){
		
		SOP(i);
		return i;
	}
}

O/P	-	1
		2
		3
		4
		5
		6
		12
		
Evalution of operands: 
- The is operator precedence but there is no operand precedence
- Before applying any operator all operands will be evaluted from left to right.
- If multiple operator with same precedence then from left to right


----------------------------------------

Flow control: 

All flow control statements are divided in three category - 
	- Selection statement
		
		1. if - else
		2. switch
	
	- Iterative statement				//collection cursors concept
		
		1. for
		2. while
		3. do-while
		4. for-each
		
	- Transfer statement:
		
		1. break
		2. continue
		3. return
		4. try-catch-finally
		5. assert (1.4 version)
		
		
if-else: 
		if(b){		//argument should be boolean type, if we are using any thing else, then CE
			acton if b is true
		}
		else{
			acton if b is false
		}

---------------------------------------------------------

int x = 0;

if(x){				//CE, Invalid, argument to if statement is always boolean. But we provided int.
	SOP("Hello");
}
else{
	SOP("Hi");
}


---------------------------------


int x = 10;

if(x = 20){				//CE, invalid. It is assignment not comparision.
	SOP("Hello");
}
else{
	SOP("Hi");
}


---------------------------------


int x = 10;

if(x == 20){				//Comparision
	SOP("Hello");
}
else{
	SOP("Hi");
}

O/P = Hi



---------------------------------

boolean b = false;

if(b = true){				//Valid, even if we are using assignment, we are assigning it to boolean type
	SOP("Hello");
}
else{
	SOP("Hi");
}

O/P = Hello


---------------------------------

boolean b = false;

if(b == false){				//valid
	SOP("Hello");
}
else{
	SOP("Hi");
}

O/P = Hello


---------------------------------

boolean b = true;

int i = 10;
int j = 20;

if(b = (i == j)){			
	SOP("Hello");
}
else{
	SOP("Hi");
}

O/P = Hi


-------------------------------

if(b)
	SOP("Hello");		// if we have only one statement the {} is options. In case of loops also. We can't take declarative statement without braces.
	
-------------------------------
	
if(true)
	SOP("Hello");
	
O/P - Hello
-------------------------------
	
if(true);		//Valid, it is called empty statement.

-------------------------------
	
if(true)
	int x = 10;		//Invalid. CE. Internally it becomes two line I think. It is local varaible declaration which can be used inside blocks{}, after completing that line we cannot use it, because there are no blocks, so CE. 	
	

-------------------------------
	
if(true)
{
	int x = 10;		//Valid
}	
	

We can't take declarative statement without braces.


---------------------------------------------------------------------------------------------------------------------------------------

22-11-19 - Session 27


switch statement - 

if-else vs switch- 
	if-else when only one or two options are there, if lots of options are there then switch.
	Performance wise there isn't any difference, just readibily will improve.
	
public static String m1(int x){

	String result = null;
	if(x < 5){
		result = "RED";
	}
	else if(x = 5){
		result = "ORANGE";
	}
	else{
		result = "GREEN";
	}
}

Which of the following code replaces if-else ladder presents inside m1() method?
A) result = (x < 5) ? "RED" : (x == 5) ? "ORANGE" : "GREEN";
B  result = (x > 5) ? "GREEN" : (x < 5) ? "RED" : "ORANGE";
C) result = (x == 5) ? "ORANGE" : (x < 5) ? "RED" : "GREEN";
D) All of these 

------------------------------------------------------------


Syntax : 

switch(x){
	
	case 1:
		SOP("JAN");
		break;
		
	
	case 1:
		SOP("JAN");
		break;
		
			....
	
	default:
		
		SOP("default action");
}


The argument types for switch - 
	Allowed -  
	
		1. byte, short, char, int (- all of them have fixed range.)
				
		2. From 1.5 version onward, auto-boxing and autoUnboxing concept came. Because of these primitive to wrapper and wrapper to primitive conversion was done internally. 
		Thus Byte, Short, Character, Integer are also allowed from 1.5 version onward. 
		
		3. After 1.5 version we have a Enum concept (ENUM is nothing but a group of constants. ENUM will provide more performance than normal class). So after 1.5 version onwards, ENUM is also allowed. 
	
		4. From 1.7 version onwards, String type is also allowed. While comparing with case labels it will always use equals() method, which is meant for content comparision.
		
		(byte, short, char, int, Byte, Short, Character, Integer, Enum, String)
		
		
	Not allowed - 
		- boolean, long, float, double (int range is -2147483648 to 2147483648, so if we pass int, these many cases are possible. more than these options are not required, thats why long is not allowed. Between 0 to 1 we can have infinite number of options for float and double, so not allowed. For boolean allowed values are true and false, so only two cases are possible, so why don't we use if statement. So boolean is not allowed.)
				
		- Boolean, Short, Float, Double => not allowed even after 1.5 version 
		
		(boolean, long, float, double, Boolean, Short, Float, Double)

for if only boolean is allowed. 


Eg- 
	
enum Beer{
	KF, KO, RC, FO;
}

class Test {
		
	public static void main(String[] args){
	
		Beer b = Beer.KO
	
		switch(b){
		
			case KO:
				SOP("Good");
				break;
				
			
			case KF:
				SOP("nice");
				break;
				
					....
			
			default:				
				SOP("other brands");
		}
	}
}


--------------------------------------

class Test {
		
	public static void main(String[] args){
	
		switch(args[0]){
		
			case "JAVA":
				SOP("It is evergreen, slowly going down");
				break;
			
			case "Phython":
				SOP("Most trending language");
				break;
				
			case "DevOps":
				SOP("Number one technology to settle your life");
				break;
			
			case default:
				SOP("We cannot predict");
				break;
		}
	}
}


For switch case {} braces are mandatory. 
For try-catch-finally also {} braces are mandatory

Inside switch both cases and default are optional. 



----------------

int x = 10;

switch(x){

	case 10:
		SOP(10);
}


----------------

int x = 10;

switch(x){

	default:
		SOP("default");
}



----------------

int x = 10;

switch(x){

}


Above all snippets are valid. 



----------------

int x = 10;

switch(x){
	
	SOP("Hello");			//Invalid, every statement inside switch should be under some case or default.
}



---------------------------------------------------------------------------------------------------------------------------------------

23-11-19 - Session 28


----------------

int x = 10;

switch(x){

}

Valid
----------------

byte b = 10;

switch(b){

}

Valid
----------------

boolean b = true;

switch(b){

}

Invalid
----------------

int x = 10;

switch(x){

	SOP("Hello");
}

Invalid

--------------------------------------

class Test {
		
	public static void main(String[] args){
		
		int x = 10;
		int y = 20;
		
		switch(y){
		
			case 10:
				SOP("10");
			
			case y:
				SOP("20");
		}
	}
}

Invalid - every case lable should be constant expression i.e. normal variables are not allowed for case labels. 


--------------------------------------

class Test {
		
	public static void main(String[] args){
		
		int x = 10;
		final int y = 20;
		
		switch(y){
		
			case 10:
				SOP("10");
			
			case y:
				SOP("20");
		}
	}
}

Now it is allowed, coz y is final and at compile time itself y at case will be replaced with 20.



--------------------------------------

class Test {
		
	public static void main(String[] args){
		
		int x = 10;
		
		switch(x + 1){			//expression is allowed. 10 + 1 = 11
		
			case 10:
				SOP("10");
			
			case 10+20+30:		//allowed, it is constant expression
				SOP("20");
		}
	}
}

Compiles and runs fine but no output, because default case is not defined. 



--------------------------------------

class Test {
		
	public static void main(String[] args){
		
		byte b = 10;
		
		switch(b){			
		
			case 10:
				SOP(10);
			
			case 100:
				SOP(100);
				
			case 1000:				// This case is never possible, because byte range is extending, so CE.
				SOP(1000);
		}
	}
}


Case label value should be in the range. 



--------------------------------------

class Test {
		
	public static void main(String[] args){
		
		byte b = 10;
		
		switch(b + 1){			//return type will be - max(int, type of a, type of b ) => max(int, byte, int) => int 
		
			case 10:
				SOP(10);
			
			case 100:
				SOP(100);
				
			case 1000:
				SOP(1000);
		}
	}
}

Code compiles and runs fine but No output. 




--------------------------------------

class Test {
		
	public static void main(String[] args){
		
		int x = 'a';
		
		switch(x){			
		
			case 97:						//This case is similar to case 'a', so CE, duplicate case label.
				SOP(97);
			
			case 98:
				SOP(98);
				
			case 99:
				SOP(99);
				
			case 'a':
				SOP("a");
		}
	}
}



Which of the following are valid about case label inside switch statement?
A) It can be expression but should be constant expression.
B) The value should be in the range of switch argument type.
C) Duplicate case labels are not allowed.
D) All of these

Answer - D




--------------------------------------

class Test {
		
	public static void main(String[] args){
		
		String s = "1234";
		
		switch(x){			
		
			case "1234":		
				SOP(1234);
			
			case 10:					//Invalid, CE. Case label should of String type, this is int. 
				SOP(10);		
		}
	}
}



Fall through inside switch - Within the switch if any case matches, then from that case onward all the statements will be executed until break is encountered or switch is completed.

class Test {
		
	public static void main(String[] args){
		
		int x = 0;
		
		switch(x){			
		
			case 0:		
				SOP(0);
			
			case 1:					
				SOP(1);

			case 2:					
				SOP(2);

			default:					
				SOP("default");				
		}
	}
}

O/P = 012default


----------------------------------


class Test {
		
	public static void main(String[] args){
		
		switch(x){			
		
			case 1:
			case 2:			
			case 3:	
				SOP("Quater - 4");
				break;
				
			case 4:
			case 5:			
			case 6:	
				SOP("Quater - 1");
				break;
				
			case 7:
			case 8:			
			case 9:	
				SOP("Quater - 2");
				break;
				
			case 10:
			case 11:			
			case 12:	
				SOP("Quater - 3");
				break;				
		}
	}
}

This is how fall through is useful.






---------------------------------------------------------------------------------------------------------------------------------------

25-11-19 - Session 29

default case: 
	We can use default Atmost once - Either once or zero times.
	We can take default case anywhere.
	


class Test {
		
	public static void main(String[] args){
		
		switch(x){			
			
			default: 
				SOP("default");
				
			case 0;
				SOP(0);
				break;

			case 1;
				SOP(1);
				
			case 2;
				SOP(2);
		}
	}
}


if x = 0 :	(JVM will go from top to bottom, when default is encounters it tell it to wait until there is any match, if no match then it will execute.)
	0

if x = 1 : 
	12	(after 2 end of switch will be encountered)
	
if x = 3 : 
	default0	//IMPORTANT: First JVM will ignore or ask default to wait to check if any match is there, no match is there in this case so default is case will execute and from there it will continue to execute until it encounters break or end of switch, thus 0 will also print. 

Which of the following is TRUE about default case inside switch statement?
A) We can define default case at most once.
B) We can place default case anywhere.
C) default case will be executed if and only if no other case matched
D) default case should be last case
E) We can define multiple default cases inside same switch

Answer - A, B, C 

---------------------------------------

To compile below code successfully, which of the following lines we can be placed at line - 1 :

class Test {
		
	public static void main(String[] args){

		//LINE 1
		
		switch(x){			
		
			case "10";
				SOP("10");
				
			case "20";
				SOP("20");
				
			default: 
				SOP("Default");		
		}
	}
}
 
A) int x = 10;
B) byte x =10;
C) short x = 10;
D) Integer x = new Integer(10);
E) String x = "10";

Answer - E - Because case labels are String, compulsorily we need to take String 

---------------------------------------

To compile below code successfully, which of the following lines we can be placed at line - 1 :

class Test {
		
	public static void main(String[] args){

		//LINE 1
		
		switch(x){			
			
			
		}
	}
}


A) int x = 10;
B) byte x =10;
C) short x = 10;
D) Integer x = new Integer(10);
E) String x = "10";
F) boolean x = true;
G) long x = 10;
H) double x = 10.0;

Answer - A, B, C, D, E

-------------------------------------

class Test {
		
	public static void main(String[] args){

		String[] beers = {"KF", "KO", "RC", "FO"};
		double price = 0;
		
		for(String beer : beers){
			
			switch(beer){					
				case "KF":
				case "K0":
					price += 150.0;
					
				case "RC":
				case "FO":
					price += 75.0;		
			}
		}
		
		SOP("The total price: " + price);					//The total price: 600.0
	}
}



-------------------------------------

class Test {
		
	public static void main(String[] args){

		String[] beers = {"KF", "KO", "RC", "FO"};
		double price = 0;
		
		for(String beer : beers){
			
			switch(beer){					
				case "KF":
				case "K0":
					price += 150.0;
					break;
					
				case "RC":
				case "FO":
					price += 75.0;		
					break;
			}
		}
		
		SOP("The total price: " + price);					//The total price: 450.0
	}
}


-------------------------------------


class Test {
		
	public static void main(String[] args){
	
		L1:
		{
			SOP("The total price: " + price);					
			SOP("The total price: " + price);					
			SOP("The total price: " + price);					
		}

		L2:
		{
			SOP("The total price: " + price);					
			SOP("The total price: " + price);					
			SOP("The total price: " + price);					
		}
	}
}


This is allowed, its a labeled class

-------------------------------------


class Test {
		
	public static void main(String[] args){

		String[] beers = {"KF", "KO", "RC", "FO"};
		double price = 0;
		
		for(String beer : beers){
			
			switch(beer){					
				case "KF":
				case "KO": RC						//THIS IS VALID, There is no CE error, Here RC acts as a label. The value "RC" and lable RC both are different. 
					price += 150.0;
					break;
					
				case "FO":
					price += 75.0;		
					
				default:
					price += 60.0;
			}
		}
		
		SOP("The total price: " + price);					//The total price: 495.0, not 435.0 becasue there is no break for case "FO"
	}
}


-------------------------------------

class Test {
		
	public static void main(String[] args){

		String s = "";
		char ch = 'f' - 'a';			//This will be evaluated to 5
		
		switch(ch){						//ch - 5
		
			case 4|5:				//At comiple time this will be replace with - case 5:		This will be matched and all below statements will execute.
				s += "Apple-";
				
			case 4&5:				//At comiple time this will be replace with - case 4:
				s += "Banana-";
			
			case 4^5:				//At comiple time this will be replace with - case 1:
				s += "Orange-";
		}
		
		SOP(s);					
	}
}


a	-	97
b	- 	98
c	- 	99
d	-	100
e	-	101
f	-	102

O/P = Apple-Banana-Orange-




---------------------------------------------------------------------------------------------------------------------------------------

26-11-19 - Session 30


Iterative Statements:
- while
- do-while
- for
- for-each

for - if we know number of iteration in advance

while - when we don't know number of records

while(b){	//should be boolean type. 

}

while(1){		//this will give CE, int type, should be boolean type

}

----------------------------
Which of the following don't have CE - 

while(true)
	SOP("Hello");

//valid

----------------------------

while(true);
	
//valid
----------------------------

while(true)
	int x = 10;
	
//invalid - without {} braces we can't have declarative statements	

----------------------------

while(true){
	
	int x = 10;
}
	
// valid


----------------------------
Snippet - 1

while(true){
	
	SOP("Hello");
}

SOP("Hi");

//Invalid - As while will execute infinite times, SOP("Hi") is unreachable, so CE

----------------------------
Snippet - 2

while(false)
	
	SOP("Hello");
}

SOP("Hi");

//Invalid, because compiler nows it is always false, so loop body will never get chance, thus CE, {} is unreachable

----------------------------
Snippet - 3

int a = 10, b = 20;

while(a < b)
	
	SOP("Hello");
}

SOP("Hi");

//Valid


----------------------------
Snippet - 4

int a = 10, b = 20;

while(a > b)
	
	SOP("Hello");
}

SOP("Hi");

//Valid


----------------------------
Snippet - 5

final int a = 10, b = 20;

while(a < b)
	
	SOP("Hello");
}

SOP("Hi");

//InValid, every final variable is replaced at compile time so it becomes while(10 < 20) at compile time which compiler knows is true, so it will go infinite and SOP("Hi"); will not get chance, so CE


----------------------------
Snippet - 6

final int a = 10, b = 20;

while(a > b)
	
	SOP("Hello");
}

SOP("Hi");

Invalid - {} unreachable.


-----------------------------------------------

do-while - execute atleast once. 

do{

}while(b);		//semi colon is mandatory

here also {} are option, only one statement is allowed and it should not be declarative statement. 

-----------------------

Snippet - 1

do	
	SOP("Hello");
while(true);

//Valid

-----------------------

Snippet - 2

do;				//obsserve ; In this case ; is valid body statement and it will be executed
while(true);

Valid
-----------------------

Snippet - 3

do					//no ;	we are not defining loop body. 
while(true);

/Invalid
-----------------------

Snippet - 4

do	
	int x = 10;		
while(true);

//Invalid

-----------------------

Snippet - 5

do
{	
	int x = 10;
}
while(true);

-----------------------

do while(true)
SOP("Hello");
while(false);

O/P - Infinite times Hello

do 
	while(true)
		SOP("Hello");
while(false);


------------------------

try{
	1000 lines
}
catch(Exception e){
	20000 lines
}
finally {
	30000 lines
}

This whole try-catch-fanally is internally in one line - so we can take it under while without {}

while(true)
	try{
		1000 lines
	}
	catch(Exception e){
		20000 lines
	}
	finally {
		30000 lines
	}


---------------------------------------------------------------------------------------------------------------------------------------

27-11-19 - Session 31


-----------------------

Snippet - 1

do
{	
	SOP("Hello");
}
while(true);
SOP("Hi");

Invalid, CE - SOP("Hi") will become unreachable.

-----------------------

Snippet - 2

do
{	
	SOP("Hello");
}
while(false);
SOP("Hi");


Valid, as the condition is false, here in case of do-while loop body will execute atleast once.



-----------------------

Snippet - 3

int a = 10, b = 20;

do
{	
	SOP("Hello");
}
while(a < b);
SOP("Hi");

//Valid, a and b are normal varaibles so compiler doesn't know at compile time if it is true or false, so no CE


-----------------------

Snippet - 4

int a = 10, b = 20;

do
{	
	SOP("Hello");
}
while(a > b);
SOP("Hi");

//VALID

-----------------------

Snippet - 5

final int a = 10, b = 20;

do
{	
	SOP("Hello");
}
while(a < b);
SOP("Hi");

As it is final, now compiler know it is true always, so SOP("Hi") is unreachable, so CE.

-----------------------

Snippet - 6

int a = 10, b = 20;

do
{	
	SOP("Hello");
}
while(a > b);
SOP("Hi");

//Valid



---------------------------

Which of the following modifications required independently to compile Test class?
A) Remove final keyword at Line-1
B) Use break statement at Line-2
C) Remove Line-3
D) None of these

Answer - A, B, C

class Test{
	
	public static void main(String[] args){
		final int a = 10, b = 20;		//Line 1
		
		do{
		
			SOP("Hello");
			//Line-2
			
		}while(a < b);
		
		SOP("Hi");	//Line-3
		
	}
}				//This code as it is won't compile - Without break and variables are final(value will be replaced at Compile time and compiler will know its always true and so infinite loop will occur and Line-3 will be unreachable), so CE - SOP("Hi") unreachable

Without final - will compile

class Test{
	
	public static void main(String[] args){
		int a = 10, b = 20;		
		
		do{
		
			SOP("Hello");

		}while(a < b);
		
		SOP("Hi");	
		
	}
}



break at Line-2 - VALID

class Test{
	
	public static void main(String[] args){
		final int a = 10, b = 20;		
		
		do{
		
			SOP("Hello");
			break;					//break is there and variables are final so NO CE, compiler knows duw to break there won't be infinite loop
			
		}while(a < b);
		
		SOP("Hi");	
		
	}
}

Remove Line-3 - WIll compile because now unreachable code is not there

class Test{
	
	public static void main(String[] args){
		final int a = 10, b = 20;		//Line 1
		
		do{
		
			SOP("Hello");
			//Line 2
			
		}while(a < b);
		
	}
}

----------------------------------

for loop - 

for(intitalization_section; conditional_section; increment_decrement_section){
	
	Body
}

All sections are optional

Flow - 
1. initialization_section
2. conditional_section, if true then
3. Body
4. increment_decrement_section
5. again conditional_section and so on

initialization_section only once


Which of the following are allowed in the initialization_section - 
- int i = 0; 	//valid
- int i = 0, j = 0; 	//valid
- int i = 0, String s = "durga";	//Invalid, becasue int i = 0 is one statement and String s = "durga" is another, ; is required between them
- int i = 0, int j = 0;		//invalid

In initialization section it is not possible to declare multiple variables of different data type. 


-----------------------

for(int i = 0; boolean b = true;)		//invalid , in conditional_section declarations are not allowed

//static varaibles we can't direclare inside main or any where, we need to declare it at class level. 

------------------------------

public static void main(String[] args){

	int i = 0;

	for(SOP("Hello"); i < 3; i++){
		
		SOP("Hi");
	}			
}

In initialization_section we can take any valid java statement, including SOP, So its valid - O/P - HelloHiHiHi	



------------------------------

conditional_section: here we can take any valid expression, but should be of boolean type.
It is optional, we are not writing any expression it then the compiler will place true value.



------------------------------


public static void main(String[] args){

	for(int i = 0 ; ; i++){
		
		SOP(i + ",");
	}			
}

//Will print infinite times

------------------------------


public static void main(String[] args){

	for(byte b = 0 ; ; b++){
		
		SOP(b + ",");
	}			
}

because of b++ means b = (byte)(b+1), because of internal type casting, b value will be in byte range only. 
Answer - It will print 0,1,2,3,... Infinite times but all values within the byte range only. 


------------------------------


public static void main(String[] args){

	for(byte b = 0 ; ; b = b + 1){
		
		SOP(b + ",");
	}			
}


//This won't compile because b + 1 is of int type and we can't assign it to byte type b


---------------------------------
increment_decrement_section:   we can take any valid java statement, including SOP

public static void main(String[] args){

	int i = 0;

	for(SOP("Hello"); i < 3; SOP("Hi")){
		
		i++;
	}			
}

O/P - HelloHiHiHi

-----------------------

for(;;){
body
}

//body will execute infinite times


for(;;);	//here ; will become body, will execute infinite times



---------------------------------------------------------------------------------------------------------------------------------------

28-11-19 - Session 32

Which of the following cause CE - 

-------------------------

Snippet - 1

for(int i = 0; true; i++){

	SOP("Hello");
}
SOP("Hi");


//CE - unreachable SOP("Hi")
-------------------------

Snippet - 2

for(int i = 0; false; i++){

	SOP("Hello");
}
SOP("Hi");

//CE - loop body is unreachable

-------------------------

Snippet - 3

for(int i = 0; ; i++){

	SOP("Hello");
}
SOP("Hi");

CE - by default it will be true

-------------------------

Snippet - 4

int a = 10, b = 20;
for(int i = 0; a < b; i++){

	SOP("Hello");
}
SOP("Hi");

O/P - Hello infinite times, normal variables, compiler doesn't know it will be true always

-------------------------

Snippet - 5

int a = 10, b = 20;
for(int i = 0; a > b; i++){

	SOP("Hello");
}
SOP("Hi");

O/P - Hi


-------------------------

Snippet - 6

int a = 10, b = 20;
for(int i = 0; a > b; i++){

	SOP("Hello");
}
SOP("Hi");

CE - compiler will know it will false always



for-each loop or enhanced for loop:
	- 1.5 version
	- specially design loop for arrays and collections

int[] a = {10,20,30,40};

for(int x : a){
	SOP(x);
}


-------------------------------

for(int i = 0; i < a.lenght; i++)		//invalid, ArrayIndexOutOfBoundException

for(int x : int[] a)	//Invalid syntax

for(var x : a)			//VALID
{
	SOP(x);
}


-------------------------------


int[][] x = {{10,20,30},{40,50,60}};

A)

	for(int i = 0; i < x.length; i++){
		for(int j = 0; j < x[i].lenght; j++){
			SOP(x[i][j]);
		}
	}


B)

	for(int[] x1 : x){
		
		for(int x2 : x1){
			
			SOP(x2);
		}
	}


C)

	for(var x1 : x){				//int[] changed to var
		
		for(var x2 : x1){			//int to var
			
			SOP(x2);
		}
	}


D)

	for(var i = 0; i < x.length; i++){
		for(var j = 0; j < x[i].lenght; j++){
			SOP(x[i][j]);
		}
	}
	
	

-------------------------------


int[][][] x = {{{10,20},{30,40}},{{50,60},{70,80}}};

A)	Check if right....

	for(int i = 0; i < x.length; i++){
		for(int j = 0; j < x[i].lenght; j++){
			for(int k = 0; k < x[i][j].lenght; k++){
				SOP(x[i][j]);
			}
		}
	}


B)

	for(int[][] x1 : x){
		
		for(int[] x2 : x1){
			
			for(int x3 : x2){
				SOP(x3);
			}			
		}
	}
	

C)

	for(var x1 : x){
		
		for(var x2 : x1){
			
			for(var x3 : x2){
				SOPa(x3);
			}			
		}
	}
	
------------------------------

We cann't replace normal general purpose loop like below with for each - 

	for(int i = 0; i < 10; i++){
		SOP("Hello");
	}

It is applicable only for arrays and collections. 	
	
--------------------------------


int[] x = {10,20,30,40};
for(int i = x.length - 1; i >=0 ;i--){
	SOP(x[i]);
}
	
reserve order. 


By using normal for-loop we can retrieve elements either in original order or in reverse order. But by using enhanced for-loop we can retrieve elements only in original order but not in reverse order. 	

class Test{

	public static void main(String[] args){	
		String x = "-";
		for(String s : args){
			
			SOP(s+x);
			x += x;
		}
	}
}

java Test Phython Java DevOps	
O/P	- Python-Java--DevOps----

----------------------

class Test{

	static public void main(String... durgastring){			String... is converted to String[] internally
		
		for(var string : durgastring){
			
			SOP("Hello..Take care about type of string");
		}
	}
}

What is the type of 'string' ?
A) String
B) String[]

Answer - type of 'string' is String 



---------------------------------------------------------------------------------------------------------------------------------------

29-11-19 - Session 33

Consider the array:

int[] x = {10,20,30,40,50,60};

To print all array elements in the original order, which of the following loop can be used?
A) standard for loop
B) enhanced for loop 
C) Either standard for loop or enhanced for loop
D) Neither standard for loop nor enhanced for loop

Answer - C

To process all array elements in the reverse order, which of the following loop can be used?
A) standard for loop
B) enhanced for loop 
C) Either standard for loop or enhanced for loop
D) Neither standard for loop nor enhanced for loop

Answer - A


To process alternative array elements in the original order, which of the following loop can be used?
A) standard for loop
B) enhanced for loop 
C) Either standard for loop or enhanced for loop
D) Neither standard for loop nor enhanced for loop

Answer - A

Enhanced for loop can be used to process all elements only in the original order
To process alternative elements we can't use enhanced for loop

We can't use enhanced for loop to process elements in reverse order. For this use standard for loop. 

------------------

Iterable:

for(eachitem x : target){

}


In for each loop the target should be iterable object. If the corresponding class implements java.lang.Iterable interface then it is called Iterable. It came in 1.5v. It contains only one method - public Iterator iterator();
All Array related class and collection classes already implements Iterable interface. 

We can also create our own Iterable Object. 

------------------

Transfer Statements:
- break
- continue
- assert
- try-catch-fanally

- We can use break -
	1. Inside switch statement to stop fall through
	2. Inside loops to break loop execution
	3. Inside labeled block
	
	class Test{
		static public void main(String... durgastring){		//sequence of static public doesn't matter
		
			int x = 10;
			
			l1:
			{
				System.out.println("Begin");
				
				if(x==10)
					break l1;
				System.out.println("End");
			}	
			
			System.out.println("Outside of labeled block");
				
		}
	}

	O/P => Begin
		   Outside Of labeled block
	
	------------------------------------------------
	
	class Test{
		static public void main(String... durgastring){		
		
			int x = 10;
			
			if(x == 10)
			{
				System.out.println("Hello-");
				break;
			}	
			else{
				System.out.println("Hi-");
			}
			
			System.out.println("HelloHi");				
		}
	}

	Answer: CE break outside switch or loop 
	
- continue
	To skip remaining statement in the current iteration and continue for the next iteration.
	
	class Test{
		static public void main(String... durgastring){		
		
			int x = 10;
			
			if(x == 10)
			{
				System.out.println("Hello-");
				continue;
			}	
			else{
				System.out.println("Hi-");
			}
			
			System.out.println("HelloHi");				
		}
	}

	Answer: CE continue outside of loop
	
	1. We can use continue statements only inside loops, if we are using any where else we will get CE
	
------------------------------------------------------

- labeled break and labeled continue statements - 
	In the nested loops to break or continue a particular loop, then we should go for labeled break and continue statements. 
	
	class Test{
		static public void main(String... durgastring){		
			
			l1:
			for(int i = 0; i < 3; i++){
				
				for(int j = 0; j < 3; j++){
					
					if(i=j)
						break l1;
					
					SOP(i + ":" + j);
				}	
			}

		}
	}

	O/P => no output
	
-------------------------

	
	class Test{
		static public void main(String... durgastring){		
			
			l1:
			for(int i = 0; i < 3; i++){
				
				for(int j = 0; j < 3; j++){
					
					if(i=j)
						continue l1;
					
					SOP(i + ":" + j);
				}	
			}

		}
	}

	O/P => 1:0
		   2:0
		   2:1


-------------------------

	
	class Test{
		static public void main(String... durgastring){		
			

			int x = 0;
			
			do{
				x++;
				
				SOP(x);
				
				if(++x < 5)		//here obeserve at last
					continue;					//It will go to conditional check 
				
				x++;
				
				SOP(x);
			
			}while(++x < 10);

		}
	}

	O/P = 1 4 6 8 10
	1 4 6 8 10 
	0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10



-------------------------

	
	class Test{
		static public void main(String... durgastring){		
			

			int x = 0;
			
			for(int j = 0; j < 3; j++){
				
				if(i == 10){
					break;
					SOP("Hello-");
				}			
				
				SOP("Hi-");
			}
			SOP("HelloHi");
		}
	}

	CE - SOP("Hello-"); is unreachable

---------------------------------------------------------------------------------------------------------------------------------------

02-12-19 - Session 34


public class Test{

	public static void main(String[] arg){
	
		String[] vowels={"a", "e", "i", "o", "u"};
		int i = 0;
		String output = "";
		
		for(String v : vowels){
			i++;
			if(i==4)
				break;
			output = output + v;
		}	
		SOP(output);
	}
}

O/P => aei

---------------------------------------


public class Test{

	static int result=100;
	
	public static int calculate(){
		for(int i = 0; i < 3; i++){
			result += i;
		}
		
		return result;
	}

	public static void main(String[] args){
		int result = calculate();
		calculate();
		result = calculate();
		SOP("The result : " + result);
	}
}

O/P => 109

---------------------------------------


public class Test{

	static int result=100;
	
	public static int calculate(){
		for(int i = 0; i < 3; i++){
			result += i;
		}
		
		return result;
	}

	public static void main(String[] args){
		int result = calculate();
		calculate();
		calculate();
		SOP("The result : " + result);
	}
}

O/P => 103


---------------------------------------


public class Test{
	
	public static int calculate(){
	
		int result=100;
	
		for(int i = 0; i < 3; i++){
			result += i;
		}
		
		return result;
	}

	public static void main(String[] args){
		calculate();
		calculate();
		int result = calculate();
		SOP("The result : " + result);
	}
}

O/P => 103


---------------------------------------


public class Test{

	public static void main(String[] args){
		
		String[] fruits = {"Apple", "Banana", "Orange"};
		
		for(int i = 0; i < fruits.length(); i++){
			switch(fruits[i]){
			
				case "Apple":
					SOP("Apple");
					continue;
				
				case "Banana":
					SOP("Banana");
					i = i-1;				//after this loop i++ will execute
					continue;
				
				default:
					SOP("Fruits are injurious to health");
			}
		}		
	}
}

O/P => 
Apple
Banana
Banana
Banana
Banana
Banana
... infinite



---------------------------------------


public class Test{

	public static void main(String[] args){
		
		String[] fruits = {"Apple", "Banana", "Orange"};
		
		for(int i = 0; i < fruits.length(); i++){
			switch(fruits[i]){
			
				case "Apple":
					SOP("Apple");
					break;						//break is there, it will only represent inner switch... 
				
				case "Banana":
					SOP("Banana");
					i = i-1;				//after this loop i++ will execute
					break;
				
				default:
					SOP("Fruits are injurious to health");
			}
		}		
	}
}

O/P => 
Apple
Banana
Banana
Banana
Banana
Banana
... infinite



---------------------------------------


public class Test{

	public static void main(String[] args){
		
		int[][] x = {{10,20},{40,50},{70}};		
		
		for(int i = 0; i < 3; i++){
			for(int j = 0; j > i + 3; j++){						//j>1+3
				x[i][j] = 0;
			}
		}
		//Line 1
	}
}

At Line 1 content of array is - 
same original content


----------------------------------------



public class Test{

	public static void main(String[] args){
		
		int i = 10;
		
		while(i > 0){
			SOP(i);
			i -= 3;
		}
	}
}

O/P = 10741

which of the following will produce the same result?
A) 
	for(int i = 0; i > 0; i=i-3){
		SOP(i);
	}
	
B)
	int i = 10;
	
	do{
		SOP(i);
		i -= 3;
	}while(i > 0);

C)	

	int i = 10;
	
	do{
		
		i -= 3;
		SOP(i);	
	}while(i > 0);

D)
	for(int i = 10; i > 0; i++){
		SOP(i);
		
		i -= 4;
		if(i<0){
			break;
		}
	}

Answer - ABD



---------------------------------------------------------------------------------------------------------------------------------------

03-12-19 - Session 35

Declaration and Access Modifiers:

Java Source File Structure: 

- Java source file can contain maultiple classes

Suppose a .java file has:
	
	class A{
	
	}
	class B{
	
	}
	class C{
	
	}

We can use any name for above java source file, its not like the class which has main() method only that class name we have to use. Its not like that. 


Suppose we have a file Durga.java:
	class A{
	
	}
	class B{
	
	}
	class C{
	
	}

If we compile above file, for every class separate .class files will be generated. 3 .class file will be generated. There won't be any Durga.class file, because we don't have any class named durga. 

***A java program or source file can contain any number of classes but atmost one should be public i.e either one or zero public class are allowed.

***If there is a public class, then name of source file and public class must match. Else we will get CE. (This is because public class will be accessible outsite, if we keep same filename it will be more meaningful, readable)

If there is no public class we can use any name for source file.

---------------------------------

Filename - B.java
	class A{
	
	}
	public class B{
	
	}
	public class C{
	
	}
	//CE

----------------------------------

Durga.java 

class A{
	
	public static void main(String[] args){
		SOP("In A main()");
	}
}


class B{
	
	public static void main(String[] args){
		SOP("In B main()");
	}
}


class C{
	
	public static void main(String[] args){
		SOP("In C main()");
	}
}


class D{
	
}

Now here it won't give any compile time error. It will generate 4 .class files as we have four classes. 
We can compile one source file or java program with multiple classes in it, but we can run only one .class file. Whichever .class we execute that main() method will get the chance. 


-------------------------------------

import statements - 

2 types of import: 
	- explicit class import	
		import java.util.ArrayList

	- implicit clas import
		import java.util.*
		
	recommended to use first one. Even if we use second one, it WON'T load all the classes in that package, as java is dynamic, when class is referred then only it will get loaded. So no memory problems n all, still first approach is recommended becasue readibily will be improved. 
	
--------------------------------------

import java.util.*;
import java.sql.*;

class Test{
	
	public static void main(String[] args){
		
		Date d = new Date();
	}
}

//Compile time error - reference to Date is ambiguous



---------------------------------------------------------------------------------------------------------------------------------------

03-12-19 - Session 36


class Test{
	
	public static void main(String[] args){
		
		String[] s = new String[4];
		s1[1] = "Sunny";
		s1[2] = "Bunny";
		s1[3] = "Chinny";
		
		for(String s1: s){
			SOP(s1.length);
		}		
	}
}

// We will get NullPointerException.. Becasue s1[4] is null and s1.length() i.e null.lenght()


--------------------------------------

class Test{
	
	public static void main(String[] args){
		
		String[] s = {"Sunny", "Bunny", "Chinny"};
				
		//Line 1
	}
}

Which code should be inserted at Line 1 to print the following output - ChinnyBunnySunny to the console? 
Answers - 
 1- 
	for(int i = s.lenght - 1; i >= 0; i--){
		SOP(s[i]);
	}
 
 2- 	
	int i = s.lenght - 1;
	while(i >= 0){
		SOP(s[i]);
		i = i - 1;
	}

 3- 
	int i = s.lenght - 1;
	do{
		SOP(s[i]);
	}while(--i >= 0);


-------------------------------------------------------



class Test{
	
	public static void main(String[] args){
		
		String[] s = {{"A", "B"}, {"C", "D"}};
				
		for(int i = s.lenght-1 ; i>=0; i--){
			
			for(int j = 0; j < s[i].length; j++){
				
				SOP(s[i][j]);
			}
		}
	}
}

O/P - CDAB



-------------------------------------------------------

class Test{
	
	public static void main(String[] args){
		
		String[] s = {{"A", "B"}, {"C", "D"}};
				
		for(int i = 0; i < s.lenght; i++){
			
			for(int j = s[i].lenght-1; j >= 0; j--){
				
				SOP(s[i][j]);
			}
		}
	}
}

O/P - BADC


-------------------------------------------------------

class Test{
	
	public static void main(String[] args){
		
		int x = 0
		
		if(x++ < 1){
			
			x += 10;
		}
		else{
			x += 20;	
		}
		
		SOP(x);
	}
}

O/P - 11


-------------------------------------------------------

class Test{
	
	public static void main(String[] args){
		
		int i = 10;
		int j = 10;
				
		if(i++ < ++j){
			
			i += 10;
		}
		else{
			j += 20;	
		}
		
		SOP(i + ":" + j);
	}
}

O/P - 21:11




---------------------------------------------------------------------------------------------------------------------------------------

04-12-19 - Session 37


	
--------------------------------------

import java.util.*;
import java.sql.*;

class Test{
	
	public static void main(String[] args){
		
		Date d = new Date();
	}
}

//Compile time error - reference to Date is ambiguous

	
--------------------------------------

import java.util.Date;
import java.sql.*;

class Test{
	
	public static void main(String[] args){
		
		Date d = new Date();
		SOP(d.getClass().getName());
	}
}

//No compile time error because it will consider explicit class import from java.util.Date

While resolving the class name compiler will gives precedence in the following order:
1. Explicit class import.
2. Classes present in current working directory.
3. Implicit class import


-----------------------------------------------------------

Now suppose we have our own class Date in current working directory - Date.java

class Date{
	public String toString(){
		return "This Date class is developed by Durga";
	}
}

And we have our Test.java in same directory as - 

import java.sql.*;	//observe
class Test{
	
	public static void main(String[] args){
		
		Date d = new Date();
		SOP(d);	//This Date class is developed by Durga
	}
}

Now according to precedence it will consider Classes present in current working directory i.e. our custom Date.class

-------------------------------------------------------------

Pattern class present in java.util.regex package. To use Pattern class in our program which of the following import statements can be used independently?
A. import java.*;					//all classes in java package will be available, but class in subpackages won't be available
B. import java.util.*;
C. import java.util.regex.*;
D. import java.util.regex.Pattern;

Answer - C, D

Whenever we are importing a package, all classes and interfaces in that package are by available but not classes and interfaces in sub package.
To use sub package class we need to write import till sub package level.

-------------------------------------------
In our program there is no need to import below packages -
1. java.lang		- String, System 
2. default package - package in which we are working or program is present
	Whenever we are using any class from default package (current working directory), it is not required to write import statement for that class. 
	

There one sub package present in java.lang package - reflect package
	java.lang.reflect.Method class provides information about, and access to, a single method on a class or interface. The reflected method may be a class method(static) or an instance method (including and abstract method)

	java.lang.Class
	
	import java.lang.reflect.Method;		//here we will have to add this import compulsarily, because reflect is a sub package in java.lang
	class Test{
		
		public static void m1(){
		
		}
		
		public static void m2(){
		
		}
		
		public static void main(String[] args){
		
			Method[] m = Test.class.getDeclaredMethods(); //Test.class is of Class type and Class has getDeclaredMethods() method. Every class has a implicit variable named with 'class' and it is of Class type
			
			for(Method m1 : m){
				SOP(m1.getName());
			}
		}
	}	

	//Every class has a implicit variable named with 'class' and it is of Class type, like - 
	
	class Test{
	
		static Class class;				//Check methods and propeties in java.lang.Class online 
		
		public static void main(String[] args){
		
		}
	}	

	---------
	
	class Test{
		
		public static void main(String[] args){
			
			Test t = new Test();
			t.getClass().getDeclaredMethods();					//t.getClass()	- this returns implicit 'class' Class object. getClass() method is coming from Object class. 
		}
	}	
	
-------------------------------------------------------------

1) 
	import statements..
	import java.util.ArrayList;

	class A{
		
		short names...
		ArrayList l = new ArrayList();
	}

2)

	class A{
		
		fully qualified names
		java.util.ArrayList l = new java.util.ArrayList();
	}

Will there be any difference between the both at compile time? - Yes, in 2) complete info is available at that line itself, in 1) compiler will have to go and check import statements, so more number of import statements more will be the compile time. There won't be any difference in execution time(runtime). 




---------------------------------------------------------------------------------------------------------------------------------------

05-12-19 - Session 38

class Test{

	public static void main(String[] args){
		
		final int a = 10, b = 20;  //Line-1
		
		do{
			SOP("Hello");
			//Line-2
		}while(a < b);
		
		SOP("Hi");		//Line-3
	
	}
}

Which of the following modifications required independently to compile the above code?

In above code Line-3 is unreachable statement and it will cause compile time error. 

A) Remove final keyword at Line-1
B) Use break statement at Line-2
C) Remove Line-3
D) None of these

Answer - ABC

--------------------------

static import - 

Java 1.5 version
	- for-each
	- var-agrs methods
	- Generics
	- Queue
	- Autoboxing and Auto unboxing
	- co-varient return types
	- Annotations
	- enum
	- static import
	- StringBuilder
	etc..
	
In Math class all methods like sqrt(), max(a,b), random(), etc are static methods. 
Now to use these static methods we use code like - 

SOP(Math.sqrt(4));
SOP(Math.max(10,20));
SOP(Math.random());

here developer needs to use Math.method every where for static methods everywhere. So we have static import, using which we don't have to use class name everywhere. 
Using static import we don't have to use class name.

eg - 
import static java.lang.Math.sqrt;		//obsert its import static and not static import. 

or

import static java.lang.Math.*;

Usually we can access static members by using class name. But if we write static import then it is not required to use class name, we can access static members directly. 
 
This applicable for static variables as well not just methods - 


class Test{

	public static void main(String[] args){
		
		SOP(Math.sqrt(4));		
	}
}

Answer - 2.0, because the return type of Maths.sqrt() method is double. 

class Test
{
	static String name = "durga";
}

Test.name.length()	=> 5

class System
{
		static PrintStream out = ...;
}
System.out.println()

System is a class
out is a static variable in System class of type PrintStream 
println() is the method present in PrintStream class.

Now,

import static java.lang.System.out;
class Test{

	public static void main(String[] args){
		
		out.println("Hello");		//observe
		out.println("Hi");		
	}
}

------------------------
out vs err: 

Some concepts of redirection in Linux - 

$ cat 
	hello	- typed using keyboard
	hello	- printed to terminal 
	
In above case the input stream is keyboard and output stream is terminal, hence whatever is typed is displayed back to terminal

$ cat 1>output.txt
	hello 	- typed using keyboard

In above case output stream is changed to output.txt file, hence whatever is typed will go output.txt

$ cat 0<input.txt 1>output.txt 2>error.txt
	Standard input device => input.txt
	Standard ouput => output.txt
	Standard error => error.txt
	
$ cat 0<input.txt 1>output.txt
	Standard input device => input.txt
	Standard ouput => output.txt
	But error messages will be displayed to console.

$ cat 0<input.txt
	Standard input device => input.txt
	But output and error messages will be displayed to console.

---------------

return type of print and println both are void. 

--------------

import static java.lang.Integer.*;
import static java.lang.Byte.*;

class Test{

	public static void main(String[] args){
		
		out.println(MAX_VALUE);		//Compile time error, ambiguity for MAX_VALUE. Btye and Integer both have MAX_VALUE
	}
}

---------------

import static java.lang.Integer.MAX_VALUE;
import static java.lang.Byte.*;

class Test{

	public static void main(String[] args){
		
		out.println(MAX_VALUE);		//No error now. It will display Integer.MAX_VALUE. Explicit import will get higest priority.
	}
}


---------------

import static java.lang.Integer.MAX_VALUE;
import static java.lang.Byte.*;

class Test{

	static int MAX_VALUE = 999;

	public static void main(String[] args){
		
		out.println(MAX_VALUE);		//Our test class MAX_VALUE will be printed, due to scope. 
	}
}

While resolving static members compiler will always give precedence in the following order -
1. Current class static members
2. Explicit static import members
3. Implicit static import members

--------------------------------

Which of the following are meaningful - 

A) import java.lang.Math.*;						//Invalid, because Math is class name and not Package name

	normal import ->
		import package.*;
		import package.class;
		
	static import ->
		import static package.classname.*;			//all static members in that class
		import package.class.staticmember;

B) import static java.lang.Math.*;				//Valid
C) import java.lang.Math;						//Valid
D) import static java.lang.Math;				//Invalid, because in Math class which static member not specified
E) import static java.lang.Math.sqrt.*;			//Invalid, because * after static member sqrt
F) import java.lang.Math.sqrt;					//Invalid, because we cannot specify static members using just import
G) import static java.lang.Math.sqrt();			//Invalid, no need of ()
H) import static java.lang.Math.sqrt;			//Valid

Answer - B C H 

---------------------------------------

Package statement:
	a group of related things
	It is an encapsulation mechanism to group related classes and interfaces into a singlt unit. 

	eg - group all classes and interfaces related to database.
			for all file operations - java.io
			for every program - java.lang


Because of packages we can have class with same names but in different packages, like-
java.util.Date
java.sql.Date

java.util.List
java.swt.List

Because of package we can also have security - 

class Test{
}

Above Test class is accessible only inside current package (as access modifier is default)





---------------------------------------------------------------------------------------------------------------------------------------

06-12-19 - Session 39

For package names we should use Internet domain name in reverse. Advantage is unique way of identification. 

package com.durgasoft.ocajp11;
public class Test{

	public static void main(String[] args){
		
		System.out.println("Hello");
	}
}

Now, javac Test.java will generate the Test.class file and place that .class file will be placed in the current working directory or package. But it should be part of this package - com.durgasoft.ocajp11
We can do this by => javac -d . Test.java			// . means current working directoy, -d means specify where to place generated .class files. Now using this cmd Test.class file will be placed in com.durgasoft.ocajp11

To execute will have to specify the package compulsarily => java com.durgasoft.ocajp11.Test


eg-
	javac -d E: Test.java	- This will place Test.class file in E drive com.durgasoft.ocajp11 package. Destination directory E: should be there, else we will get error. 
	
	Now suppose we need to run it from D drive - 
	
	D:\durgaclasses> java -cp E: com.durgasoft.ocajp11.Test				-cp means classpath, we need to keep class as public 


------------------------------------

package pack1;
package pack2;

public class Test{

	public static void main(String[] args){
		
		System.out.println("Hello");
	}
}

Compile time error, in any java source file we can take atmost one package statement i,e  we cannot take more than one package statements. Test.java:2: error: class, interface, or enum expected. package pack2. 


------------------------------------
import java.util.*;
package pack1;

public class Test{

	public static void main(String[] args){
		
		System.out.println("Hello");
	}
}

Compile time error, first non comment statement should be package statement if it is available.

The following is correct order of java statements in java source file -
1. package statement (Atmost once)
2. import statement (Any number)
3. class or interface or enum declarations (Any number)

class, interface and enum can be declared in any order.

----------------------------

Consider the following java source files - 

Test1.java
----------
package pack1;

Test2.java
----------
import java.util.*;

Test3.java
----------
package pack1;
import java.util.*;

Test4.java
----------
public class test4{

}

Among these which of the java source files can be compiled successfully?

A) Test1.java
B) Test2.java
C) Test3.java
D) Test4.java
E) All of the above

Answer - E

Note:  An empty file is a valid java program.


---------------------------------------------------------------------------------------------------------------------------------------

06-12-19 - Session 40

Class modifiers - 
	Whether this class can be accessible from anywhere or not
	Whether child class creation is possible or not
	Whether object creation is possible or not
	
	Allowed modifiers for top level classes - public, <default> if we don't specify any thing, final, abstract and strictfp

private class Test{		//CE: modifier private not applicable here. 

}	

public class means we can access from anywhere 
final class means child class creation is not possible
abstract class means we cannot create object

public class Test{	
	
	private int x = 10;
	
	....
}	
variable x can be accessed only within Test class 

If we make class private, it doesn;t have any meaning, its unlogical

For inner classes allowed modifiers are - public, private, <default>, protected, abstract, final, strictfp, static 

public class Test{	
	
	private class Inner{		//this private inner class means that we can access this class only inside Test
	
	}
	....
}

Inner class concept is in next level certification.

-------------------------


private class Test{

	public static void main(String[] args){
		
		int i = 0;
		for(int j = 0; j < 3; j++){
			i = i + j;
		}
		
		SOP(i);
	}
}

What is result?
A. 3
B. 6
C. 8
D. COmpilation Fails

Answer - D


-------------------------


private class Test{

	private static class A{		//We need to take this class as static, or else we won't be able to access it from static are i.e. main() method as it will be instance member without static
		public void m1(){
			SOP("A");
		}	
	}

	protected static class B{
		public void m2(){
			SOP("B");
		}	
	}
	
	public static void main(String[] args){
		A a = new A();
		B b = new B();
		
		a.m1();
		b.m2();
		SOP("C");
	}
}

Answer -  ABC


--------------------------
access specifiers vs access modifiers:

	In other languages like C, C++ be have below terminology - 
		public, private, protected and default => access specifiers
		final, static, .. => access modifier
	But in java there is no such terminology, everything is condisered as access modifier. There is no word called access specifier. 	
	
---------------------------
public classes: We can access public classes from anywhere.

A.java
-------
package pack1;
class A{
	public void m1(){
		SOP("A");
	}		
}

B.java
------
package pack2;
import pack1.A;

class B{
	public static void main(String[] args){
		A a = new A();
		a.m1();
	}		
}

javac -d . A.java	- compiles fine
javac -d . B.java	- compile time error: A is not public in pack1; cannot be access from import pack1.A; As A is not public.


Default classes: We can access such classes only inside current package. It is also called package level access or package private access. 

*No import statement is required for classes present in same package. 


final modifier: 
	Applicable for classes, methods and variables
	
final method: final method means overriding is not possible

final class: No one is allowed to extend it, means child class creation is not possible. Every method inside final class is always final. Every variable present inside final class is NOT always final.

	final class Test{
		100 methods  
	}

	class Child extends Test{		//CE: cannot inherit from final parent
	
	}

	--------
	
	final class Test{
		static int x = 10;
		
		public static void main(String[] args){
			SOP(x);		//10
			x=999;		// we can change variable in final class. It can be non final.
			SOP(x);		//999
		}	
	}

Advantage of final keyword: 
	Security
	Unique behavior for all, as no one can change
	
	But Inheritance, Polymophism => missing
	
We can't override final methods, but we can overload. 



---------------------------------------------------------------------------------------------------------------------------------------

06-12-19 - Session 41
	
Abstract modifier: 
	Applicable only for classes and methods, not for variables

Abstract Methods: 
	abstract method has only declaration and not implementation. 
	Child class is responsible for providing implementation.
	If a class contains a abstract method, then compulsarily the class should also be abstract. 

	
abstract class Vehicle{
	
	public abstract int getNoOfWheels();	// if we comment this, then childs may or may not implement this method. But we declare it, then compulsarily childs will have to implement it. 	
}

class Bus extends Vehicle{
	
	public int getNoOfWheels(){
		return 6;
	}
}

class Auto extends Vehicle{
	
	public int getNoOfWheels(){
		return 3;
	}
}

class Test{
	public static void main(String[] args){
			
		Vehicle v1 = new Bus();				//polymorphism
		SOP(v1.getNoOfWheels());//6, if getNoOfWheels() is not present in Vehicle, then we will get compile time error, it should be present. At run time the runtime object's method will be called, i.e. Bus
		
		Vehicle v2 = new Auto();
		SOP(v2.getNoOfWheels());			//3
	}	
}

Hence we need to declare abstract method in Parent, even though there is no implementation, else chances are there for above 2 CE

------------------------


abstract class Vehicle{
	
	public abstract int getNoOfWheels();	// if we comment this, then childs may or may not implement this method. But we declare it, then compulsarily childs will have to implement it. 	
}

class Bus extends Vehicle{
	
	public int getNoOfWheels(){
		return 6;
	}
}

class Auto extends Vehicle{
	
}

class Test{
	public static void main(String[] args){
			
		Vehicle v1 = new Bus();	
		SOP(v1.getNoOfWheels());
		
		Vehicle v2 = new Auto();
		SOP(v2.getNoOfWheels());		
	}	
}


CE: abstract method implementation not given in child Auto

------------------


abstract class Vehicle{
	
		
}

class Bus extends Vehicle{
	
	public int getNoOfWheels(){
		return 6;
	}
}

class Auto extends Vehicle{
	public int getNoOfWheels(){
		return 3;
	}
}

class Test{
	public static void main(String[] args){
			
		Bus b = new Bus();	
		SOP(b.getNoOfWheels());
		
		Auto a = new Auto();
		SOP(a.getNoOfWheels());		
	}	
}
//Now its valid, coz we are not using Parents reference. 

------------------------------

**abstract method never talks about implementation, if any modifier talks about implementation, then it will become enemy to abstract and that combination will become illegal.
	
	Below combinations are illegal:
	abstract
		final				//talks about implementation
		static				//class level method needs to have implementation
		synchronized		//method will be executed by only one thread at a time, so needs implementation
		native				//means implementation is already available in other language like C, C++
		strictfp			//all floating-point should follow some standard, so its talking about implementation
		private				//If parent class method is abstract private, then how will child access it to provide implementation	

default keyword and <default> modifier meaning and concept is completly different. default keyword came in 1.8 and is used only in interfaces. 

Abstract class: 
	Partially implemented class is called abstract class. 
	For abstract class it is not possible to create object of that class
	
Abstract class vs Abstract method:
	If a class contains at-least one abstract method then compulsory class should be declared as abstract, otherwise we will get CE. 
	An abstract class can contain zero number of abstract methods also. 
	
	eg - HttpServlet, Adapter classes



---------------------------------------------------------------------------------------------------------------------------------------

06-12-19 - Session 42

Abstract class vs Abstract method:
	If a class contains at-least one abstract method then compulsory class should be declared as abstract, otherwise we will get CE. 
	An abstract class can contain zero number of abstract methods also. 
	
	eg - HttpServlet, Adapter classes

To create a servlet we have three ways - 
	public class MyOwnServlet implements Servlet
	public class MyOwnServlet extends GenericServlet
	public class MyOwnServlet extends HttpServlet			//common approach
	{
		doGet(){
		
		}
		doPost(){
		
		}	
	}

	We are sending GET Request, but our servlet class doesn't contain doGet() method (only doPost() is there), what will happem?
	- HttpServlet i.e. parents doGet() will be called. HttpServlet's doGet() is implemented in such a way that it just provides a error message. So in HttpServlet methods are just implemented to provide error messages. 

Adapter class:
	
	interface inf{
		
		void m1();
		void m2();
		...
		void m1000();
	}

	class Test implement inf{
		
		void m3{
			100 lines...
		}
		
		//here I will have to give default implementation for rest of remaining 999 methods or make this class also abstract. 	
	}

	To solve above problem in comment - 
	
	abstract class Adapter implements inf{		//abstract because empty implementation, no need to create object, no use to user
		void m1(){}
		void m2(){}
		...
		void m1000(){}
	}
	
	Now we can extend Adapter,
	
	class Test extend Adapter{
		
		void m3{
			100 lines...
		}
	}		// advatange is just the required method will be implemented. We can use Adapter for mutiple classes. So its very helpful when we have multiple implementation classes. 
	
	class Demo extend Adapter{
		
		void m44{
			10 lines...
		}
	}

-------------------

Which of the following are TRUE?
A. An abstract class should contains atleast one abstract method. 
B. An abstract class contains both abstract and concrete methods
C. An abstract class can contains zero number of abstract methods.
D. If every method present inside a class is abstract, then only we should declare class as abstract
E. If a class contains atleast one abstract method, then we should declare class as abstract
F. If abstract class does not contain any abstract method, then instantiation is possible for that class

Answer - BCE

For any method if we are not providing implementation then we should declare that method as abstract.

public abstract void m1(){}		//invalid, abstract method should not contain body

------------

abstract class Parent{

	public abstract void m1();
	public abstract void m2();
}

class Child extends Parent{
	public void m1(){}		
}

Above is invalid, because child class is responsible to provide implementation for every parent class abstract method. If child class unable to provide implementation for atleast one abstract method of parent then the child class should be declared as abstract. In this case next level child class is responsible to provide implementation.

-------------

final vs abstract:
- We should override abstract methods in child classes to provide implementation. But we cannot override final methods. Hence final and abstract is illegal combination for methods.
- For abstract class, we should create child class to provide implementation. But for final classes child class creation is not possible. Hence abstract final is illegal combination for classes also.
	
  Inside abstract class can there be final method? And inside final class can there be a abstract method?

- Abstract class can contain final methods
- final class can't contain abstract methods.




---------------------------------------------------------------------------------------------------------------------------------------

06-12-19 - Session 43

strictfp modifier - not part of exam
- strictfp means Strict floating point
- We can use this modifier for classes and methods but not variables. 
- Version 1.2

SOP(10/3);	
	Windows => 3.33333333335
	Linux => 3.333333
	Max =>	3.33

The way of representing floating point varies from platform to platform. 

If we are using strictfp, then all floating-point operations will have to follow IEEE 754 standard. 

If a method declared with strictfp, then all floating point calculations in that method will follow IEEE 754 standard so that we will get platform independent results. 

If a class is declared as strictfp then every concrete method in that class has to follow IEEE 754 standard so that we will get platform independent results. 

abstract-final illegal for method and class.

strictfp vs abstract:
- strictfp method always talks about implementation. But abstract method never talk about implementation. Hence abstract-strictfp is illegal for methods
- abstract-strictfp IS LEGAL for classes, because when strictfp is applied to class it will make all CONCRETE method to follow standard. Its not applicable for abstract methods in that class. Its legal even if we have no concrete methods. 
	
	abstract strictfp class Test{
	
		public abstract void m1();
		
		public void m2(){
		
		}
		
		public void m3(){
		
		}
	}	//VALID
 
top level class modifiers:
	public
	default
	final
	abstract
	strictfp

Member Modifiers:
- public

package pack1;
class A{
	
	public void m1(){
		....
	}
}

package packB;
import pack1.A;
class B{
	public static void main(String[] args){
		
		A a = new A();
		a.m1();		//We can't access A class because that class has default access specified. We will get CE error while compiling B
	}
}
So if BOTH member and class is visible i.e public then only we can access them from outside of package


------------------


- default members:
	- can be accessed only within the current package, but not from outside the package


package pack1;
public class A{
	
	void m1(){
		....
	}
}

package pack2;
import pack1.A;
class B{
	public static void main(String[] args){
		
		A a = new A();
		a.m1();		//We can't access m1() from A, becasue m1() is not public (even though now class A is public)
	}
}


------------------

private member:  If member is private then we can access that member within the same class only


package pack1;
public class A{
	
	private void m1(){
		....
	}
}

package pack1;
import pack1.A;
class B{
	public static void main(String[] args){
		
		A a = new A();
		a.m1();		//same package but still CE
	}
}

Why private methods cannot be declared as abstract?
- private methods cannot be accessed to child class, but abstract methods should be accessible to child. 

-----------------------

protected modifiers:
- If a member declared as protected then we can access that member from anywhere within the same package and from outside of package only in child classess
	protected = > <default> + kids
	
	
	
B.java
------

package pack1;
class A{
	
	protected void m1(){
		....
	}
}

public class B extends A{
	public static void main(String[] args){
		
		A a = new A();
		a.m1();
		
		B b = new B();
		b.m1();
		
		A a1 = new B();
		a1.m1();
	}
}

A and B are in same package. 

Within the same package we can access protected member either by using parent reference or by child reference.

All method calls are valid. 

A.java
-------

package pack1;
public class A{
	
	protected void m1(){
		....
	}
}

B.java
------

package pack2;
import pack1.A;

public class B extends A{
	public static void main(String[] args){
		
		A a = new A();
		a.m1();		//Invalid. CE.
		
		B b = new B();
		b.m1();		//Valid
		
		A a1 = new B();
		a1.m1();		//Invalid. CE.
	}
}

From outside of the package, we can access protected members only in child classes and we should use CURRENT CHILD CLASS REFERENCE ONLY i.e. to access protected member from outside package, we cannot use parent reference. 

protected means highly recommended to override, in the worst scenarios only bring this method.
abstract means you should override to provide implementation.


A.java
-------

package pack1;
public class A{
	
	protected void m1(){
		....
	}
}

B.java
------

package pack2;
import pack1.A;

class B extends A{

}

public class C extends B{
	public static void main(String[] args){
		
		A a = new A();
		a.m1();		//Line-1	Invalid
		
		B b = new B();
		b.m1();		//Line-2	InValid	current child class reference only
		
		A a1 = new B();
		a1.m1();		//Line-3	Invalid
		
		A a2 = new C();
		a2.m1();		//Line-4		InValid
		
		B b1 = new C();
		b1.m1();		//Line-5		InValid current child class reference only
		
		C c = new C();
		c.m1();			//Line-6		Valid, current child class reference only
		
	}
}

A is outside package, B and C in same package

From outside of the package, we can access protected members only in child classes and we should use CURRENT CHILD CLASS REFERENCE ONLY i.e. to access protected member from outside package, we cannot use parent reference. 

Only Line-6 is valid



---------------------------------------------------------------------------------------------------------------------------------------

06-12-19 - Session 44

class Dog implements Cloneable{

}

class Test implements Cloneable{

	public static void main(String[] args) throws Exception{
		
		Dog d1 = new Dog();
		Dog d2 = (Dog) d1.clone();		//Line-1
		
		Test t1 = new Test();
		Test t2 = (Test) t1.clone();	//Line-2
	}
}

Object class clone() method is protected. 

Object -> java.lang -> protected clone()

Dog, Test -> D:\durgaclasses		-> both are child of Object, so from outside package we can call clone() in child classes, but by using current child reference only. So Line-1 is Invalid and causes CE. 



class Dog implements Cloneable{

}

class Test{

	public static void main(String[] args) throws Exception{
		
		Test t1 = new Test();
		Test t2 = (Test) t1.clone();	//Line-2
	}
}

Line-2 will cause Runtime Exception - CloneNotSupportedException, because its not implementing Cloneable interface. To use clone() class needs to implement Cloneable

-----------

class Dog implements Cloneable{

}

class Test implements Cloneable{

	public static void main(String[] args) throws Exception{
		
		Dog d1 = new Dog();
		d1.finalize();	//Invalid, same reason as above
	}
}

finalize is Object class protected method. 

---------------

Why Object's class clone() is protected?
- protected means highly recommended to override and in worst case scenarios only use protected method.
- Object class clone() method meant for shallow cloning, but most of the times our requirement is for deep cloning, so its recommended to override it for deep cloning. 

- finalize() method is executed just before destroying an object, GC calls finalize() method to perform clean up activities. 
- Object class finalize() method has emppty implementation. Becasue our custom object implementation and clean up activity is know by us, how will Object class know about it. Hence it is also recommended to be overridden by us.  

-------------------------

final variables: 

class Test{
	
	int x;
	
	public static void main(String[] args){
		Test t = new Test();
		SOP("t.x : " + t.x);		//no need to initialize, output is 0. For instance and static variables JVM provides default value.
	}
}

---------------


class Test{
	
	final int x;
	
	public static void main(String[] args){
		Test t = new Test();
		SOP("t.x : " + t.x);	//CE, if instance or static variables are final, then compulsarily we should provide initialization explicitly
	}
}

Rule: For final instance variables, we should perform initialization before construction completion.

Where we can perform initialization for instance variable?
1. At the time of declaration
2. Inside instance block, executed for every object creation before constructor
3. Inside constructor

(Not in static block, because from static area we can't access instance variables directly. We need tp create the object and then using object access that instance variable. But static block is executed at the time of class loading, at that point we don't have object.)

If we are performing initialization anywhere else, we will get compile time error.

class Test{
	
	final int x;
	
	{				//instance block					
		x = 20;
	}
	public static void main(String[] args){
		Test t = new Test();
		SOP("t.x : " + t.x);	//20
	}
}

Final static varibales:
----------------------


class Test{
	
	static int x;
	
	public static void main(String[] args){
		SOP("x : " + x);	//0
	}
}

----------------

class Test{
	
	static final int x;
	
	public static void main(String[] args){
		SOP("x : " + x);	//CE
	}
}

--------------

For final static variables compulsarily we should perform initialization explicitly before class loading completion. 
1. At the time of declaration
2. Inside static block

If we are performing initialization any where else we will get compile time error.

class Test{
	
	static final int x = 10;
	
	public static void main(String[] args){
		SOP("x : " + x);	//10
	}
}

----------------


class Test{
	
	static final int x;
	
	static{
	
		x = 20;
	}
	
	public static void main(String[] args){
		SOP("x : " + x);	//20
	}
}

--------------



---------------------------------------------------------------------------------------------------------------------------------------

06-12-19 - Session 45


final local variables:
----------------------

class Test{
	
	public static void main(String[] args){
		
		int x;
		SOP("Hello");	//This is valid, because we are not using that local variable, No CE
	}
}

----------------------

class Test{
	
	public static void main(String[] args){
		
		final int x;
		SOP("Hello");	//Now also it is valid, because we are not using it anywhere.
	}
}

For local variables, JVM won't provide any default values, compulsary we should perform initialization explicitly before using that local variable. If we are not using local variable then we are not required to perform initialization explicitly. 

Even the local variable final, rule is same. 


----------------------

class Test{
	
	public static void main(String[] args){
		
		final int x;
		SOP(x);	//error: variable x might not have been initialized
	}
}

-----------------------

Consider the folloing code snippets. Which of the following cause CE - 

Code snippet - 1
----------------

class Test{
	int x;
}
//Valid


Code snippet - 2
----------------

class Test{
	final int x;
}
//Invalid - instance variable is declared as final, so compulsarily we need to perform initialization


Code snippet - 3
----------------

class Test{
	static int x;
}
//Valid

Code snippet - 4
----------------

class Test{
	final static int x;
}
//Invalid - if static variable is declared as final, compulsarily we need to perform initialization

Code snippet - 5
----------------

class Test{
	
	public void m1(){
		int x;
	}
}

//Valid

Code snippet - 6
----------------

class Test{
	public void m1(){
		final int x;
	}
}

//Valid

--------------------

The only applicable modifier for local varaible is final. If we are using any other modifier then we will get CE.


Inside main() method which of the following declarations are allowed?
A. private int x = 10;
B. public int x = 10;
C. protected int x = 10;
D. transient int x = 10;
E. volatile int x = 10;
F. final int x = 10;
G. static int x = 10;

Answer - F

---------

class Test{

	public static void main(String[] args){
		private int i = 0;
		
		for(int j = 0 ; j < 3; j++){
			i = i +j;
		}
	}
}

CE, local varaible cannot be private

----------------

class Test{
	
	public static void main(String[] args){
		m1(20,20);		//actual arguments
	}
	
	public static void m1(final int x, int y){		//formal parameters		//Line-1
		
		x = 100;			//Line-2
		y = 200;
		
		SOP(x + " : " + y);
	}
}

CE, because we are performing reassignment for final variable x

The formal parameters of a method are simplt acts as local variables of that method and local variables can be declared as final. If the formal parameter declared as final, then inside that method we cannot perform reassignment. 

To compile above code we can remove final from Line-1, or comment Line-2



---------------------------------------------------------------------------------------------------------------------------------------

06-12-19 - Session 46


static modifier:
----------------
We can use static for variables(check, only instance not local), methods and blocks.

We cannot declare top level class with static, but we can declare innner class as static.

In the case of instance variable, for every object a separate copy will be created. But in the case of static varibales, at class level only one copy will be created and shared by every object of that class. 

Which of the following can be declared with the static modifier?
A. Variables
B. Methods
C. Blocks
D. Top level classes
E. Inner Classes

Answer - A, B, C, E


----------------

class Test{
	
	static int x = 10;
	int y = 20;
	
	public static void main(String[] args){
		
		Test t1 = new Test();
		t1.x = 888;
		t1.y = 999;
		
		Test t1 = new Test();
		
		SOP(t2.x + " : " + t2.y);		//888 : 20
	}	
}

-------------------------

We can access instance variables directly from instance area, but we cannot access directly from static area. Or non-static variables cannot be accessed from static context. 
But static variables can be accessed directly from both static and non-static areas. 


Consider the following 4 declarations:
1. int x = 10;
2. static int x = 10;
3. 
	public void m1(){
		
		SOP(x);
	}
4.
	public static void m1(){
		
		SOP(x);
	}

Within the same class which of these declarations are allowed simultaneously?

A. 1 and 3
B. 1 and 4
C. 2 and 3
D. 2 and 4
E. 1 and 2
F. 3 and 4

Answer - A, C, D

B - invalid - instance cannot be accessed into static area.
E - instance and static with same name not allowed
F - Two method with same signature are not allowed in the same class 


----------------

class Test{
	
	public static void main(String[] args){
			
		SOP("String[] args");	
	}

	public static void main(int[] args){
			
		SOP("int[] args");	
	}		
}

A. String[]
B. int[]
C. Compilation Fails
D. An exception is thrown at runtime

Answer - A

Overlaoding concept applicable for static methods including main method, but JVM will always call String[] argument main method only. 

-------------------------

Parent.java
----------

public class Parent{
	
	public static void main(String[] args){
			
		SOP("parent main method");	
	}
}

class Child extends Parent{
	
}

Now if we try to run Child what will happen? - java Child

A. Parent class main will be executed
B. Exception is thrown at runtime
C. Compilation fails
D. Compiles and runs but no output 

Answer - A

Inheritance concept applicable for static method including main method. Hence while executing child class, if child class does not contains main method parent class main method will be executed. 


-------------------------

Parent.java
----------

public class Parent{
	
	public static void main(String[] args){
			
		SOP("parent main method");	
	}
}

class Child extends Parent{
	public static void main(String[] args){
			
		SOP("Child main method");	
	}
}

Now if we try to run Child what will happen? - java Child

A. Parent class main will be executed
B. Child class main will be executed
B. Exception is thrown at runtime
C. Compilation fails

Answer - B

Overrriding concept is not applicable for static methods and it is method hiding. 

------------------

native modifier - not related to exam
	applicable only for methods
	native methods means the method which is implemented in non-java

synchronized keyword - not required for exam
		applicable only for methods and blocks
		if method or block declared as synchronized then it will be executed by only one thread at a time
		
transient - not in exam 
	At the time of serialization, if we don't want to save the value of a variable to meet security constraints then we should go for transient.
	
	class Account implement Serializable{
	
		String username="durga";
		transient String pwd = "anushka";	//now instead of 'anushka' default value of String null will be stored in the file
		
		...
	}

volatile modifier - not in exam 
If a variable is declared as volatile, then for every thread a separate local copy of the variable will be created. 
why it is deprecated - because creating separate copy for each thread will cause performance issues. 

------------

We have to use extends first and then implements, becasue, because of extends all parent available methods will be method available and using implements it will tell him how many implementations he need to provide. 



---------------------------------------------------------------------------------------------------------------------------------------

06-12-19 - Session 47

Interface: 
----------
Any Service Requirement Specification (SRS)






























