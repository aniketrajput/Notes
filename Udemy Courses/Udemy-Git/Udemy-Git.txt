
Section 1: Introduction and Getting Started

Git Overview

	Git is a Version Control System(VCS) or Source Control Management(SCM) System.
	
	An version controlled artifact can be a file (text, binary) or even a directory.
	
	Git is a collaboration platform for developers, designers and various professionals.
	
	Git stores different versions of artifacts during it's lifetime.
	
	Git also allows us to compare different versions of a particular artifact.
	
	
How git works - Part 1

	3 main states of artifact - 

		Modified - Here, the artifact goes through change made by the user. We have changed the artifact but have not committed it to git database yet.

		Staged - Here, the user/developer adds the artifact to Git index or staging area. Staged means we have marked modified files in its current version to go into a next commit snapshot. Snapshot means state of an artifact at any point of time. This is achieved by the 'git add' command. 

		Committed - Here, the artifact gets safely stored in Git database locally and add it to commit history. It is acheived by git commit command. 
		
		Check Diagram - C:\Users\inarajp\Desktop\Notes\Udemy-Git\git-repsoitory-stages.jpg


How git works - Part 2

	3 sections of a Git project.
	
	Working directory - This is the root directory of your Git project. 
	
	staging area - Also called index, this is where all related changes are build up. This is the section where changes in artifact are marked for commit. 
	
	Commit area - This is where all artifacts are stacked safely in Git Database. This where committed files are stored. The .git directory is where git stores committed artifacts and mata-data for your project. 


	The commited files are stored by .git directory. 
	

Git Setup on Windows (Lab)
 
	
	inarajp@VI204875 MINGW64 ~
		$ git version
		git version 2.26.0.windows.1


Section 3: Setting up a Git Repository

12. Basics and Introduction - setting up a Git
Repository

	Configure author name and email address.
	
	In this section we will learn how to configure author name and email address. 
	
	Here author is the repository user. 
	
	This is optional but preferable step.
	
	3 ways of setting up Git repository - 
	
	- From scratch
		We will create a repository from absolutely blank state.
		This will intialize the repository and create .git directory that contain all the meta data for project.
		
	- Existing Project
		This means we have an existing project with all the files and directories which is unversioned. 
		Here we will convert an existing unversioned project to a git repository. 
		We will initilize it with cmd - git init. It will create .git directory and hence bring it under version control. 
		
	- By Copying
		We will copy an existing Git repository from GitHub
		Creating a repository by copying a repository from central repository. This is called cloning. 
		We will use both https and ssh protocols to clone a project.
	

13. Git Help system (Lab)

	Type 'git help'. We can see list of git commands.
	
	$ git help
	usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
			   [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
			   [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
			   [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
			   <command> [<args>]

	These are common Git commands used in various situations:

	start a working area (see also: git help tutorial)
	   clone             Clone a repository into a new directory
	   init              Create an empty Git repository or reinitialize an existing one

	work on the current change (see also: git help everyday)
	   add               Add file contents to the index
	   mv                Move or rename a file, a directory, or a symlink
	   restore           Restore working tree files
	   rm                Remove files from the working tree and from the index
	   sparse-checkout   Initialize and modify the sparse-checkout

	examine the history and state (see also: git help revisions)
	   bisect            Use binary search to find the commit that introduced a bug
	   diff              Show changes between commits, commit and working tree, etc
	   grep              Print lines matching a pattern
	   log               Show commit logs
	   show              Show various types of objects
	   status            Show the working tree status

	grow, mark and tweak your common history
	   branch            List, create, or delete branches
	   commit            Record changes to the repository
	   merge             Join two or more development histories together
	   rebase            Reapply commits on top of another base tip
	   reset             Reset current HEAD to the specified state
	   switch            Switch branches
	   tag               Create, list, delete or verify a tag object signed with GPG

	collaborate (see also: git help workflows)
	   fetch             Download objects and refs from another repository
	   pull              Fetch from and integrate with another repository or a local branch
	   push              Update remote refs along with associated objects

	'git help -a' and 'git help -g' list available subcommands and some
	concept guides. See 'git help <command>' or 'git help <concept>'
	to read about a specific subcommand or concept.
	See 'git help git' for an overview of the system.

	
	If we type 'git help -a', it will give list of various sub commands. 

	$ git help -a
	See 'git help <command>' to read about a specific subcommand

	Main Porcelain Commands
	   add                  Add file contents to the index
	   am                   Apply a series of patches from a mailbox
	   archive              Create an archive of files from a named tree
	   bisect               Use binary search to find the commit that introduced a bug
	   branch               List, create, or delete branches
	   bundle               Move objects and refs by archive
	   checkout             Switch branches or restore working tree files
	   cherry-pick          Apply the changes introduced by some existing commits
	   citool               Graphical alternative to git-commit
	   clean                Remove untracked files from the working tree
	   clone                Clone a repository into a new directory
	   commit               Record changes to the repository
	   describe             Give an object a human readable name based on an available ref
	   diff                 Show changes between commits, commit and working tree, etc
	   fetch                Download objects and refs from another repository
	   format-patch         Prepare patches for e-mail submission
	   gc                   Cleanup unnecessary files and optimize the local repository
	   gitk                 The Git repository browser
	   grep                 Print lines matching a pattern
	   gui                  A portable graphical interface to Git
	   init                 Create an empty Git repository or reinitialize an existing one
	   log                  Show commit logs
	   merge                Join two or more development histories together
	   mv                   Move or rename a file, a directory, or a symlink
	   notes                Add or inspect object notes
	   pull                 Fetch from and integrate with another repository or a local branch
	   push                 Update remote refs along with associated objects
	   range-diff           Compare two commit ranges (e.g. two versions of a branch)
	   rebase               Reapply commits on top of another base tip
	   reset                Reset current HEAD to the specified state
	   restore              Restore working tree files
	   revert               Revert some existing commits
	   rm                   Remove files from the working tree and from the index
	   shortlog             Summarize 'git log' output
	   show                 Show various types of objects
	   sparse-checkout      Initialize and modify the sparse-checkout
	   stash                Stash the changes in a dirty working directory away
	   status               Show the working tree status
	   submodule            Initialize, update or inspect submodules
	   switch               Switch branches
	   tag                  Create, list, delete or verify a tag object signed with GPG
	   worktree             Manage multiple working trees

	Ancillary Commands / Manipulators
	   config               Get and set repository or global options
	   fast-export          Git data exporter
	   fast-import          Backend for fast Git data importers
	   filter-branch        Rewrite branches
	   mergetool            Run merge conflict resolution tools to resolve merge conflicts
	   pack-refs            Pack heads and tags for efficient repository access
	   prune                Prune all unreachable objects from the object database
	   reflog               Manage reflog information
	   remote               Manage set of tracked repositories
	   repack               Pack unpacked objects in a repository
	   replace              Create, list, delete refs to replace objects

	Ancillary Commands / Interrogators
	   annotate             Annotate file lines with commit information
	   blame                Show what revision and author last modified each line of a file
	   count-objects        Count unpacked number of objects and their disk consumption
	   difftool             Show changes using common diff tools
	   fsck                 Verifies the connectivity and validity of the objects in the database
	   gitweb               Git web interface (web frontend to Git repositories)
	   help                 Display help information about Git
	   instaweb             Instantly browse your working repository in gitweb
	   merge-tree           Show three-way merge without touching index
	   rerere               Reuse recorded resolution of conflicted merges
	   show-branch          Show branches and their commits
	   verify-commit        Check the GPG signature of commits
	   verify-tag           Check the GPG signature of tags
	   whatchanged          Show logs with difference each commit introduces

	Interacting with Others
	   archimport           Import a GNU Arch repository into Git
	   cvsexportcommit      Export a single commit to a CVS checkout
	   cvsimport            Salvage your data out of another SCM people love to hate
	   cvsserver            A CVS server emulator for Git
	   imap-send            Send a collection of patches from stdin to an IMAP folder
	   p4                   Import from and submit to Perforce repositories
	   quiltimport          Applies a quilt patchset onto the current branch
	   request-pull         Generates a summary of pending changes
	   send-email           Send a collection of patches as emails
	   svn                  Bidirectional operation between a Subversion repository and Git

	Low-level Commands / Manipulators
	   apply                Apply a patch to files and/or to the index
	   checkout-index       Copy files from the index to the working tree
	   commit-graph         Write and verify Git commit-graph files
	   commit-tree          Create a new commit object
	   hash-object          Compute object ID and optionally creates a blob from a file
	   index-pack           Build pack index file for an existing packed archive
	   merge-file           Run a three-way file merge
	   merge-index          Run a merge for files needing merging
	   mktag                Creates a tag object
	   mktree               Build a tree-object from ls-tree formatted text
	   multi-pack-index     Write and verify multi-pack-indexes
	   pack-objects         Create a packed archive of objects
	   prune-packed         Remove extra objects that are already in pack files
	   read-tree            Reads tree information into the index
	   symbolic-ref         Read, modify and delete symbolic refs
	   unpack-objects       Unpack objects from a packed archive
	   update-index         Register file contents in the working tree to the index
	   update-ref           Update the object name stored in a ref safely
	   write-tree           Create a tree object from the current index

	Low-level Commands / Interrogators
	   cat-file             Provide content or type and size information for repository objects
	   cherry               Find commits yet to be applied to upstream
	   diff-files           Compares files in the working tree and the index
	   diff-index           Compare a tree to the working tree or index
	   diff-tree            Compares the content and mode of blobs found via two tree objects

	
	To access git guide => git help -g

	$ git help -g

	The common Git guides are:
	   attributes          Defining attributes per path
	   cli                 Git command-line interface and conventions
	   core-tutorial       A Git core tutorial for developers
	   cvs-migration       Git for CVS users
	   diffcore            Tweaking diff output
	   everyday            A useful minimum set of commands for Everyday Git
	   glossary            A Git Glossary
	   hooks               Hooks used by Git
	   ignore              Specifies intentionally untracked files to ignore
	   modules             Defining submodule properties
	   namespaces          Git namespaces
	   repository-layout   Git Repository Layout
	   revisions           Specifying revisions and ranges for Git
	   submodules          Mounting one repository inside another
	   tutorial            A tutorial introduction to Git
	   tutorial-2          A tutorial introduction to Git: part two
	   workflows           An overview of recommended workflows with Git

	'git help -a' and 'git help -g' list available subcommands and some
	concept guides. See 'git help <command>' or 'git help <concept>'
	to read about a specific subcommand or concept.
	See 'git help git' for an overview of the system.

	We can access it like => git help tutorial	=> this will open up in browser
	
	We can also get help about a particular command, like for example 'git help init' => it will lauch the default browser and you can that command details.


14. Configuring author and email for a Git repository (Lab)

	inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git
	$ pwd
	/c/Users/inarajp/Desktop/temp/Udemy-Git

	inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git
	$ mkdir git-fast

	inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git
	$ cd git-fast


	git config --global --list will list any existing configuration.

	git config --global user.name "Aniket Rajput"	=> to configure user name
	
	git config --global user.email "aniketrajput90@gmail.com"
	
	All this user information is stored in .gitconfig file => vi ~/.gitconfig
	

15. Initializing an empty Git repository (Lab)

	$ ls -l
	total 0

	$ git init
	Initialized empty Git repository in C:/Users/inarajp/Desktop/temp/Udemy-Git/git-fast/myRepoFromScratch/.git/

	$ ls -al				//-al lists all the directories including the hidden directories
	total 4
	drwxr-xr-x 1 inarajp 1049089 0 Apr  9 17:41 ./
	drwxr-xr-x 1 inarajp 1049089 0 Apr  9 17:39 ../
	drwxr-xr-x 1 inarajp 1049089 0 Apr  9 17:41 .git/

	We can see .git directory, this means we have intialized an empty repository
	
	$ echo "this is my first file using echo command" >> firstFileUsingEcho.txt			//This will create a firstFileUsingEcho.txt file with given text
	
	$ cat firstFileUsingEcho.txt
	this is my first file using echo command

	We will create a second file using vi command => $ vi secondFileUsingVI.txt
	Then press i to enter some content, later press :wq, which will save the content and quit vi editor. If we press just :q then it will quit without saving.
	
	$ cat secondFileUsingVI.txt
	this is second file using vi editor

	$ ls -al
	total 10
	drwxr-xr-x 1 inarajp 1049089  0 Apr  9 18:01 ./
	drwxr-xr-x 1 inarajp 1049089  0 Apr  9 17:39 ../
	drwxr-xr-x 1 inarajp 1049089  0 Apr  9 17:41 .git/
	-rw-r--r-- 1 inarajp 1049089 41 Apr  9 17:44 firstFileUsingEcho.txt
	-rw-r--r-- 1 inarajp 1049089 36 Apr  9 18:01 secondFileUsingVI.txt
	

16. Convert existing unversioned project to a Git repository (Lab)

	We will need an existing project so we will download the project - www.initializr.com/
	
	//copy
		$ cp C:/Users/inarajp/Desktop/temp/initializr-verekia-4.0.zip .				//copy from C:/.... to current directory(.)


	//check if it is there	
		$ ls -l initializr-verekia-4.0.zip
		-rw-r--r-- 1 inarajp 1049089 61126 Apr  9 18:11 initializr-verekia-4.0.zip

	//unzip
		$ unzip initializr-verekia-4.0.zip
		Archive:  initializr-verekia-4.0.zip
		  inflating: initializr/index.html
		  inflating: initializr/css/main.css

	//remove
		$ rm initializr-verekia-4.0.zip
	
	//rename
		$ mv initializr/ myRepoFromExistingSource

	//cd 
		$ cd myRepoFromExistingSource/

	//check contents of dir
		$ ls -l

	//Initialize it
		$ git init
		Initialized empty Git repository in C:/Users/inarajp/Desktop/temp/Udemy-Git/git-fast/myRepoFromScratch/myRepoFromExistingSource/.git/

	We can now see .git directory in there.
	This means we have converted an unversioned project into a git repository.


17. Git Command Summary resource (setting
up a Git Repository)

	Git Command Summary resource (setting up a Git Repository)

	Configuring author and email

	# home directory
	$ pwd                                                            
	$ mkdir git-fast            
	$ cd git-fast
	$ pwd    
	$ git config --global --list     
	$ git config --global user.name "Bibhash Roy"
	$ git config --global --list
	$ git config --global user.email "bibhash@whitepeaksoft.com"
	$ git config --global --list

	# vi is the editor, ~ is the home directory
	$ vi ~/.gitconfig                                                
	$ cat .gitconfig



	Initializing an empty repository

	$ pwd
	$ mkdir myRepoFromScratch
	$ cd myRepoFromScratch
	$ pwd         
	   
	# notice the creation of .git directory                        
	$ git init   
						   
	# "ls -al" command lists all objects, including hidden                                             
	$ ls -al  
		  
	# without using any editor                                                                 
	$ echo "this is my first file in empty repository" >> firstFileUsingEcho.txt     
	$ ls
	$ cat firstFileUsingEcho.txt

	 # create the file and enter some contents
	$ vi  secondFileUsingVI.txt                                        
	$ ls
	$ cat secondFileUsingVI.txt



	Existing unversioned project to repository

	$ pwd

	 # copy the downloaded file
	$ cp /f/Bibhash/Downloads/initializr-verekia-4.0.zip .

	# unzipping will create a folder called "initilizr"     
	$ unzip initializr-verekia-4.0.zip                                        
	$ ls -al

	# remove copied file
	$ rm initializr-verekia-4.0.zip  

	# rename directory                                          
	$ mv initializr/ myRepoFromExistingSource    
				  
	# now we need to add source control to the unversioned repo "myRepoFromExistingSource"
	$ cd myRepoFromExistingSource  
			 
	# Initialized existing source                        
	$ git init            

	# .git folder can be seen with ls -al                                                               
	$ ls -al          

																   

	Command Summary - configuration & repository creation
	# Typically, youâ€™ll want to use the --global flag to set configuration options for the current user.
	# Define the author name to be used for all commits by the current user.
	$ git config --global user.name <name>    

	# Define the author email to be used for all commits by the current user.
	$ git config --global user.email <email>   

	# For listing all the global configuration at user level
	$ git config --global --list          
	   
	# Transforms the current directory into a Git repository; the command is same for creating repo from ..contd..
	# scratch or convert an existing unversioned code base to a git repository             
	$ git init                                                    

	Command Summary - Accessing Git Help system

	# general help
	$ git help

	# lists sub-commands
	$ git help -a

	# lists concept guides
	$ git help -g

	# read about a specific sub-command
	$ git help <command>

	# read about a specific concept
	$ git help <concept>


The name and location of the Git repository configuration file respectively are - .gitconfig, user's home directory


Section 4: Enter GitHub!

18. What is GitHub

	It is a Git repository with a web interface.
	It is web based Gir repository hosting service as git is a command-line based tool.
	
	Github has both free and paid plans. Private and Public. Public repositories can be downloaded by anyone.
	
	Other features - Documentation, bug tracking, etc. 
	

19. Another technique for creating Git repository on GitHub!

	We will be doing Clone from GitHub. We will be copying a git repository from Github to our local machine using the clone command.
	

20. What is fork and how to do it in GitHub(Lab)

	Forking is when you create a new project based on another project that already exists.
	Creating a project from another existing project. 
	So it is a sort of copying.
	
	If you find a project on github that you would like to contribute to you can fork the repository make the changes and release the revised project as a new repository. 
	If the original repository that we forked to create our new project gets updated, you can easily add those updates to your current fork.
	So basically fork will create a copy of the project and that copy will be in your account(you can see in github, not locally) and its completely yours.
	
	After fork that porject will come into our account and from there we can clone it into our local machine.
	
	It encourages outside contribution to projects on GitHub.
	
	
21. Copying a GitHub repository (Lab)
	
	Cloning a GitHub repository (remote) is basically downloading a code base (in the remote repository) to your own machine (local), so that you can make your own contribution to the code base.
	
	We will now clone the earlierly forked project to create a local git repository in our local machine.
	
	$ pwd
	/c/Users/inarajp/Desktop/temp/Udemy-Git/git-fast

	inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/git-fast
	$ git clone https://github.com/aniketrajput/hellogitworld.git
	Cloning into 'hellogitworld'...
	remote: Enumerating objects: 306, done.
	remote: Total 306 (delta 0), reused 0 (delta 0), pack-reused 306
	Receiving objects: 100% (306/306), 95.57 KiB | 102.00 KiB/s, done.
	Resolving deltas: 100% (70/70), done.

	inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/git-fast
	$ ls -l
	total 8
	drwxr-xr-x 1 inarajp 1049089 0 Apr  9 18:51 hellogitworld/
	drwxr-xr-x 1 inarajp 1049089 0 Apr  9 18:15 myRepoFromScratch/

	inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/git-fast
	$ cd hellogitworld/

	inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/git-fast/hellogitworld (master)		//here we can see master branch now.

	Branch is nothing but a separate line of development.
	

22. Command Summary resource (Enter GitHub)
	
	Command Summary resource (Enter GitHub)
	Copying a GitHub repository

	$ cd <project_directory>
	$ git clone https://github.com/<user>/<example_project>
	$ cd example_project
	$ ls -al
	
	
Section 5: Committing changes in Git

23. Basics and Introduction - committing changes in Git

	

24. Adding your changes in a Git Repository(Lab)

	
		$ git status
			On branch master

			No commits yet

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					myFirstFile.txt

			nothing added to commit but untracked files present (use "git add" to track)


	git status tells us the status of our working directory and the staging area. 
	
	Above it says its on branch master. 
	myFirstFile.txt is an untracked file. Untracked file means this file is not being tracked by git. Git will start strating a file, once we issue and 'git add' command.
	
	
		$ git add myFirstFile.txt
			warning: LF will be replaced by CRLF in myFirstFile.txt.
			The file will have its original line endings in your working directory

		$ git status
			On branch master

			No commits yet

			Changes to be committed:
			  (use "git rm --cached <file>..." to unstage)
					new file:   myFirstFile.txt

	
	Above add command indicates that issuing the 'git add' command has staged the file. 
	And it also says that whatever changes you have made in staging area needs to be committed. 
	
	We can also unstage/backtrack using below command - 
	
		
		$ git rm --cached myFirstFile.txt
			rm 'myFirstFile.txt'

		$ git status
			On branch master

			No commits yet

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					myFirstFile.txt

			nothing added to commit but untracked files present (use "git add" to track)



25. Committing your changes in a Git Repository (Lab)

		
		$ git add myFirstFile.txt
			warning: LF will be replaced by CRLF in myFirstFile.txt.
			The file will have its original line endings in your working directory

		$ git status
			On branch master

			No commits yet

			Changes to be committed:
			  (use "git rm --cached <file>..." to unstage)
					new file:   myFirstFile.txt


	commit command => git commit -m "some message"		(-m option indicates the commit message, it helps us to identify all our commits in commit history)
		
		$ git commit -m "my first commit"
			[master (root-commit) b3b7c6b] my first commit
			 1 file changed, 1 insertion(+)
			 create mode 100644 myFirstFile.txt

	So above we can see that we are in master branch. 
	We can also see a commit id b3b7c6b, every commit is identified by an commit id. 
	We can also see a commit message. 
	
		
		$ git status
			On branch master
			nothing to commit, working tree clean
	

26. Command Summary resources(Committing changes in Git)

	Command Summary resources (Committing changes in Git)
	Adding your changes

	# home directory
	$ pwd                          
	$ cd git-fast
	$ ls
	$ cd myRepoFromScratch
	$ ls

	# create a file and add some content
	$ vi demoFile1                    
	$ cat demoFile1
	$ git status
	$ git add demoFile1
	$ git rm --cached demoFile1
	$ git status



	Committing changes

	 # home directory
	$ pwd                              
	$ git status
	$ git add demofile1
	$ git status
	$ git commit -m "our first commit in this course"
	$ git status



	Command Summary - add and commit

	$ git add
	$ git commit -m "message goes here"



	The "git add" commands adds the file to: insex or staging area.
	
	The entire process involve 3 steps in the following order: modify a file -> add changes to staging area -> commit to git database
	
	Which are the valid commands for committing a file where file name is <file-name>?
	All of the below achieve the same thing - 
		=> git commit -m <file-name>			// I think it will commit everything, and all after -m will be considered as message
		=> git commit --message <file-name>		// I think it will commit everything, and all after --message will be considered as message. Have checked this. 	
		=> git commit <file-name>				//this command will open up the default editor for us to add a message for the commit
		
		
Section 6: Inspecting what's going on in a Git Repository	
	
27. Basics and Introduction - Inspecting what's going on!
	
	Here we will examine the various ways of inspecting status and history of git.
	
	We can achieve this using command => git status => tells us the status of working directory and staging area. It tells us which changes have been staged an which files are not being tracked by git. 
	
	git log => displays committed snapshots or commit history
	
	
28. How to check status in a Git Repository(Lab)	

		$ git add .				//adds all files

		$ ls -l
			total 2
			-rw-r--r-- 1 inarajp 1049089 13 Apr 10 18:03 demoFile1.txt
			-rw-r--r-- 1 inarajp 1049089 13 Apr 10 18:04 demoFile2.txt

		$ git status
			On branch master
			nothing to commit, working tree clean
		
		$ vi weightLossChart
		
		$ vi dietChart

		$ git status
			On branch master
			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					dietChart
					weightLossChart

			nothing added to commit but untracked files present (use "git add" to track)

		$ git status --long
			On branch master
			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					dietChart
					weightLossChart

			nothing added to commit but untracked files present (use "git add" to track)
	
	We can see that with option 'git status --long' there is not difference as compared to just 'git status'. This means --long option is default behavior.
	
		$ git status -s
			?? dietChart
			?? weightLossChart

	Option -s means short.
	?? indicactes that they are not tracked by git. 

		$git add weightLossChart
	
		$ git status -s
			A  weightLossChart
			?? dietChart
	
	Now we can see 'A' which means file has been added. 

		$ git commit -m "first commit for weightLossChart"
			[master c56f3c4] first commit for weightLossChart
			 1 file changed, 1 insertion(+)
			 create mode 100644 weightLossChart

		$ git status -s
			?? dietChart

		$ vi weightLossChart
		
		$ cat weightLossChart
		I want to shed 15 kg in 5 weeks.
		Exersize more.

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/myRepoFromScratch (master)
		$ git status -s
			M weightLossChart					//M colour is red
			?? dietChart

	Now we can see weightLossChart has 'M', which means it has beed modified.
	
		$ git add weightLossChart
			warning: LF will be replaced by CRLF in weightLossChart.
			The file will have its original line endings in your working directory

		$ git status -s
			M  weightLossChart				//colour is Green, indicating file has been added to staging area.
			?? dietChart

		
	Now we will rename weightLossChart to weightLossChart2

		$ mv weightLossChart weightLossChart2

		$ ls -l
		total 4
		-rw-r--r-- 1 inarajp 1049089 13 Apr 10 18:03 demoFile1.txt
		-rw-r--r-- 1 inarajp 1049089 13 Apr 10 18:04 demoFile2.txt
		-rw-r--r-- 1 inarajp 1049089 48 Apr 10 18:13 dietChart
		-rw-r--r-- 1 inarajp 1049089 48 Apr 10 18:21 weightLossChart2


		$ git status -s
			 D weightLossChart
			?? dietChart
			?? weightLossChart2
	
	Now we can see weightLossChart as 'D', which indicates Deleted 
	And we can see weightLossChart2 has ??, which means it is new file and is in unassigned status.
	
	
29. How to check commit history in Git Repository (Lab)

	If we see : in a git bash, press q and we will be out of it.
	
		$ vi demoFile3

		$ cat demoFile3
			This is a Demo File 3.

		$ git log
			commit c83734e4be5dcf0b9de3e596acf4326b92fed8bb (HEAD -> master)
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Fri Apr 10 18:46:10 2020 +0530

				Second commit for weightLossChart

			commit c56f3c4f91e1f1fff85699fb66b59009dd704e83
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Fri Apr 10 18:19:54 2020 +0530

				first commit for weightLossChart

			commit de3f23e7de7f4878a79574ac42077b05e7dce576
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Fri Apr 10 18:06:40 2020 +0530

				First Commit


	'git log' displays the entire history in default format. We can have a simple format. 
	
		$ git log --oneline
			c83734e (HEAD -> master) Second commit for weightLossChart
			c56f3c4 first commit for weightLossChart
			de3f23e First Commit

	As we can see above is much simpler format.
	
	We can also examine a commit history for a particular file - 
	
		$ git log demoFile1.txt
			commit de3f23e7de7f4878a79574ac42077b05e7dce576
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Fri Apr 10 18:06:40 2020 +0530

				First Commit

	Above we can see all the commits related to demoFile1.
	
		$ git log --oneline demoFile1.txt
			de3f23e First Commit


	We can filter the commit history as well, let say we want to view only the commit history that limited to some 4 commits => git log <since>..<until>
	
		$ git log de3f23e..c56f3c4
			commit c56f3c4f91e1f1fff85699fb66b59009dd704e83
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Fri Apr 10 18:19:54 2020 +0530

				first commit for weightLossChart


		$ git log de3f23e..c56f3c4 --oneline
			c56f3c4 first commit for weightLossChart

	Note that in filter commit history it doesn't include the <since> commit it.
	
	
	Now lets say we want to view last 3 commits => git log -n 3 --oneline	
	
		$ git log -n 2 --oneline
			c83734e (HEAD -> master) Second commit for weightLossChart			
			c56f3c4 first commit for weightLossChart

	
30. Command Summary resources (git status and git log)

	Command Summary resources (git status and git log)
	How to check your repo status

	# cd to /c/Users/HP-PC/git-fast/myRepoFromScratch
	$ pwd
	$ ls

	# start with a clean working directory
	$ git status                

	# create file and add some contents such as "I want to shed 15 kg 5 weeks"        
	$ vi weightLossChart    

	# create file and add some contents such as "I want to add more green vegetables to my diet"    
	$ vi dietChart                  
	$ git status           

	 # same as "git status" since "long" option is the default one (compare output)    
	$ git status --long        
	$ git status -s                                 # status "??" for untracked file
	$ git add weightLossChart
	$ git status -s                                 # status "A"
	$ git commit -m "1st commit for weightLossChart"
	$ git status -s     
	$ vi weightLossChart                 # make some changes to the file
	$ git status -s                              # status "M"
	$ git add weightLossChart  
	$ git status -s                                # status "M"
	$ git commit -m "2nd commit for weightLossChart"
	$ git status -s   
	$ mv weightLossChart weightLossChart2
	$ git status -s                             # status "D"



	How to check commit history

	# displays the entire commit history using the default formatting
	$ git log                

	# oneline condensed view of each commit history                      
	$ git log --oneline

	# Only display commits that include the specified file                             
	$ git log <file>          

	# Show only commits that occur between <since> and <until>. Both arguments can be either a commit ID ...contd.
	# a branch, name, HEAD, or any other kind of revision reference.                    
	$ git log <since>..<until>                     

	# Limit the number of commits by <limit>. For example, git log -n 3 will display only 3 commits.  
	$ git log -n <limit>                          



	Command Summary - status & log

	# provides a status report of the repo
	$ git status             

	# displays the entire commit history using the default formatting                       
	$ git log                

	 # oneline condensed view of each commit history                      
	$ git log --oneline           

	# Only display commits that include the specified file                 
	$ git log <file>     

	# Show only commits that occur between <since> and <until>. Both arguments can be either a commit ID, a branch
	# name, HEAD, or any other kind of revision reference.                        
	$ git log <since>..<until>                    

	# Limit the number of commits by <limit>. For example, git log -n 3 will display only 3 commits.
	$ git log -n <limit>          


Section 7: Git Branching basics

31. Peek into Git branching (Lab)

	We can think of branch as way to request a brand new working directory, staging area and project history. 
	New commits are recorded in the history of the current branch.
	
		$ git branch
			* master

		shows the available branches.
		
	If we want to create a particular branch - 
	
		$ git branch demobranch
		
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/myRepoFromScratch (master)
		$ git branch
			demobranch
			* master

	Now we have created a demo branch but we can see that it is still not active, a master branch is active.
	So if we want to make it active use below command - 
	
			$ git checkout demobranch
				Switched to branch 'demobranch'
				D       weightLossChart

			inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/myRepoFromScratch (demobranch)

	If we do git log -
	
		$ git log --oneline
			c83734e (HEAD -> demobranch, master) Second commit for weightLossChart
			c56f3c4 first commit for weightLossChart
			de3f23e First Commit

	We can see that the demobranch inherits the branch history from the master branch. 
	
	And if we make any new commits then those new commits will be recorded in the history of this demobranch. 
	
	Check diagram - real-world-branching-senarios.jpg
	
	Master branch - is a permanent branch which always reflect a production ready state. In other words, it is a main branch.
	
	There can be other branches such as Development branch.
	
	Development branch - is where a branch is always moving ahead, due to continious work of developers. 
	Once development branch has acquired enough features for a release, may be a pre-determined release that is approaching then the developer creates the Release branch of the Development branch. 
	
	Release branch - is a temporary supporting branch to support preparation of new production release. 
	Creating this branch starts the next release cycle, so no new features can be added after this point. 
	
	Feature branch - At the same time developers work on new features, they create new feature branches and commit on to them. 
	So these branches are created so the main line of development and the production ready master branch remains undisturbed.
	
	
	
Section 8: Undoing changes in a Git repository
	
32. Checking out commits in a Git repository - Part 1 (Lab)

	git checkout => can be used to do multiple things. 
					- We can use it to switch branches.
					- To checkout commits. 
					- To checkout files.
					
	So here we will see how to use git checkout to checkout commits.
	
	Syntax => git checkout <commit-id>
			This command will update all files in the working directory to match the specified commit id.
			
		$ ls
			demo-checkout-commit/  initializr/  initializr-verekia-4.0.zip  myRepoFromScratch/

		$ cp -rf initializr/* demo-checkout-commit/

		$ rm -rf initializr

		$ ls
		demo-checkout-commit/  initializr-verekia-4.0.zip  myRepoFromScratch/

		$ cd demo-checkout-commit/

		$ pwd
		/c/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit

		$ git init
			Initialized empty Git repository in C:/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit/.git/

		$ git status
			On branch master

			No commits yet

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					404.html
					apple-touch-icon.png
					browserconfig.xml
					css/
					favicon.ico
					humans.txt
					index.html
					js/
					robots.txt
					tile-wide.png
					tile.png

			nothing added to commit but untracked files present (use "git add" to track)

		$ git add .
			warning: LF will be replaced by CRLF in 404.html.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in browserconfig.xml.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in css/main.css.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in css/normalize.css.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in humans.txt.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/main.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/plugins.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/vendor/jquery-1.11.2.min.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/vendor/modernizr-2.8.3-respond-1.4.2.min.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory

		$ git status
			On branch master

			No commits yet

			Changes to be committed:
			  (use "git rm --cached <file>..." to unstage)
					new file:   404.html
					new file:   apple-touch-icon.png
					new file:   browserconfig.xml
					new file:   css/main.css
					new file:   css/normalize.css
					new file:   css/normalize.min.css
					new file:   favicon.ico
					new file:   humans.txt
					new file:   index.html
					new file:   js/main.js
					new file:   js/plugins.js
					new file:   js/vendor/jquery-1.11.2.min.js
					new file:   js/vendor/modernizr-2.8.3-respond-1.4.2.min.js
					new file:   robots.txt
					new file:   tile-wide.png
					new file:   tile.png

		$ git commit -m "all files commited"
			[master (root-commit) 795f391] all files commited
			 16 files changed, 1022 insertions(+)
			 create mode 100644 404.html
			 create mode 100644 apple-touch-icon.png
			 create mode 100644 browserconfig.xml
			 create mode 100644 css/main.css
			 create mode 100644 css/normalize.css
			 create mode 100644 css/normalize.min.css
			 create mode 100644 favicon.ico
			 create mode 100644 humans.txt
			 create mode 100644 index.html
			 create mode 100644 js/main.js
			 create mode 100644 js/plugins.js
			 create mode 100644 js/vendor/jquery-1.11.2.min.js
			 create mode 100644 js/vendor/modernizr-2.8.3-respond-1.4.2.min.js
			 create mode 100644 robots.txt
			 create mode 100644 tile-wide.png
			 create mode 100644 tile.png

		$ git status
			On branch master
			nothing to commit, working tree clean


	In order to demonstrate the git checkout commit, we will pick one file and commit it several times.
	We will use robots.txt file.
	
	git commit -am "1st commit for robot.txt" => this is called an express commit, means we don't have to do 'git add', instead we can directly execute this command. This is achieved using -a option.
	
	
		$ vi robots.txt

		$ git commit -am "1st commit for robot.txt"
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory
			[master 9e9633b] 1st commit for robot.txt
			 1 file changed, 2 insertions(+)

		$ git log --oneline
			9e9633b (HEAD -> master) 1st commit for robot.txt
			795f391 all files commited


		$ vi robots.txt

		$ git commit -am "2nd commit for robot.txt"
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory
			[master 5f64a06] 2nd commit for robot.txt
			 1 file changed, 1 insertion(+)

		$ vi robots.txt

		$ git commit -am "3rd commit for robot.txt"
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory
			[master 9fd98bb] 3rd commit for robot.txt
			 1 file changed, 1 insertion(+)

		$ vi robots.txt

		$ git commit -am "4th commit for robot.txt"
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory
			[master d69014a] 4th commit for robot.txt
			 1 file changed, 1 insertion(+)

		$ vi robots.txt

		$ git commit -am "5th commit for robot.txt"
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory
			[master 11508a5] 5th commit for robot.txt
			 1 file changed, 1 insertion(+)

		
		$ git log --oneline
			11508a5 (HEAD -> master) 5th commit for robot.txt				//this is the final commit and it is called HEAD
			d69014a 4th commit for robot.txt
			9fd98bb 3rd commit for robot.txt
			5f64a06 2nd commit for robot.txt
			9e9633b 1st commit for robot.txt
			795f391 all files commited

	HEAD points to the final/last commit in the commit history.
	
	So now we have realized that there is some incorrect code in 3rd commit and we want to revert all commits from there and go back to 2nd commit. 
	We can do it by => git checkout 5f64a06
	This command will update all files in working directory to match the specified commit. 
	The issuing of this command will put you in a detached HEAD state. 
	Checking out an old commit is a read-only operation. 
	Now the 2nd commit is our old operation. It is impossible to harm your repository while viewing an old revision.
	The current state of our project remains untouched in the master branch. 
	During the normal course of development the HEAD usually points to master or some other local branch but when you checkout an old version, HEAD no longer points to a branch, it points directly to a commit. This is called a detached HEAD state. 
	
		$ git checkout 5f64a06
			Note: switching to '5f64a06'.

			You are in 'detached HEAD' state. You can look around, make experimental
			changes and commit them, and you can discard any commits you make in this
			state without impacting any branches by switching back to a branch.

			If you want to create a new branch to retain commits you create, you may
			do so (now or later) by using -c with the switch command. Example:

			  git switch -c <new-branch-name>

			Or undo this operation with:

			  git switch -

			Turn off this advice by setting config variable advice.detachedHead to false

			HEAD is now at 5f64a06 2nd commit for robot.txt				//we can see HEAD is not at some branch its on a commit, this is detached HEAD
			
			
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit ((5f64a06...))			//here too we can see that we are on a commit.
		
	
	Now while we are in this state of the project we can make changes to any artifacts and we can still be assured that the current state of our project will be totally unaffected. 
	This also means that if we make any commit in that detached HEAD state then the commits will not be retained. 
	However if we want to retain the commits then we can see they have given some message. We can create a new branch to retain the commits. 
	

33. Checking out commits in a Git repository - Part 2 (Lab)
			
	
	As we earlier we were in detached HEAD state for 2nd commit. We can go back to our original state by using command => git checkout master
	
		$ git checkout master
			Previous HEAD position was 5f64a06 2nd commit for robot.txt
			Switched to branch 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit (master)

		$ git log --oneline
			11508a5 (HEAD -> master) 5th commit for robot.txt
			d69014a 4th commit for robot.txt
			9fd98bb 3rd commit for robot.txt
			5f64a06 2nd commit for robot.txt
			9e9633b 1st commit for robot.txt
			795f391 all files commited

	Now lets again get back to detached  HEAD state at 2nd commit 5f64a06

			$ git checkout 5f64a06
				Note: switching to '5f64a06'.

				You are in 'detached HEAD' state. You can look around, make experimental
				changes and commit them, and you can discard any commits you make in this
				state without impacting any branches by switching back to a branch.

				If you want to create a new branch to retain commits you create, you may
				do so (now or later) by using -c with the switch command. Example:

				  git switch -c <new-branch-name>

				Or undo this operation with:

				  git switch -

				Turn off this advice by setting config variable advice.detachedHead to false

				HEAD is now at 5f64a06 2nd commit for robot.txt

	Now in this detached HEAD state we can look at files, we can even compile the project, run test and also edit files without worrying about lossing the current state of the project. Whatever we do here will not be saved in our repository. 
	
		
		$ git log --oneline
			5f64a06 (HEAD) 2nd commit for robot.txt
			9e9633b 1st commit for robot.txt
			795f391 all files commited

	So now lets edit robot.txt and try to do a commit here.
	
		$ vi robots.txt

		$ cat robots.txt
			# www.robotstxt.org/

			# Allow crawling of all content
			User-agent: *
			Disallow:

			line 1....
			line 2....
			line 6....

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit ((5f64a06...))
		$ git commit -am "6th commit for robot.txt"
			[detached HEAD 915bee5] 6th commit for robot.txt
			 1 file changed, 1 insertion(+)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit ((915bee5...))			//we can see HEAD has changed here
		$ git log --oneline
			915bee5 (HEAD) 6th commit for robot.txt																	//New commit. We can see HEAD has changed here
			5f64a06 2nd commit for robot.txt
			9e9633b 1st commit for robot.txt
			795f391 all files commited

	Funny thing is if we do 'git checkout master' now, this 6th commit will vanish. 
	As said earlier nothing we do here will be permanent unless and until we create a branch out of it.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit ((915bee5...))
		$ git checkout master
			Warning: you are leaving 1 commit behind, not connected to
			any of your branches:

			  915bee5 6th commit for robot.txt

			If you want to keep it by creating a new branch, this may be a good time
			to do so with:

			 git branch <new-branch-name> 915bee5

			Switched to branch 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit (master)
		$ git log --oneline
			11508a5 (HEAD -> master) 5th commit for robot.txt
			d69014a 4th commit for robot.txt
			9fd98bb 3rd commit for robot.txt
			5f64a06 2nd commit for robot.txt
			9e9633b 1st commit for robot.txt
			795f391 all files commited


	We can see we are back at original state.

	We no longer see the 6th commit. So we will go back to detached HEAD state - 
	
		$ git checkout 5f64a06
			Note: switching to '5f64a06'.

			You are in 'detached HEAD' state. You can look around, make experimental
			changes and commit them, and you can discard any commits you make in this
			state without impacting any branches by switching back to a branch.

			If you want to create a new branch to retain commits you create, you may
			do so (now or later) by using -c with the switch command. Example:

			  git switch -c <new-branch-name>

			Or undo this operation with:

			  git switch -

			Turn off this advice by setting config variable advice.detachedHead to false

			HEAD is now at 5f64a06 2nd commit for robot.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit ((5f64a06...))
		$ cat robots.txt
			# www.robotstxt.org/

			# Allow crawling of all content
			User-agent: *
			Disallow:

			line 1....
			line 2....

	We can see that line 6.... which we added in 6th commit is no longer there, hence it confirms that whatever we do here will not be permanent until and unless we create a new branch.

		$ vi robots.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit ((5f64a06...))
			$ cat robots.txt
			# www.robotstxt.org/

			# Allow crawling of all content
			User-agent: *
			Disallow:

			line 1....
			line 2....
			line 6....

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit ((5f64a06...))
		$ git commit -am "6th commit for robot.txt"
			[detached HEAD e8cb9a7] 6th commit for robot.txt
			 1 file changed, 1 insertion(+)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit ((e8cb9a7...))
		$ git log --oneline
			e8cb9a7 (HEAD) 6th commit for robot.txt
			5f64a06 2nd commit for robot.txt
			9e9633b 1st commit for robot.txt
			795f391 all files commited

	Now we will create a new branch to retain the changes - 
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit ((e8cb9a7...))
		$ git checkout -b newBranch
			Switched to a new branch 'newBranch'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit (newBranch)
		$ git log --oneline
			e8cb9a7 (HEAD -> newBranch) 6th commit for robot.txt
			5f64a06 2nd commit for robot.txt
			9e9633b 1st commit for robot.txt
			795f391 all files commited


	Now we can see 6th commit retained on a newBranch.
	
	However if we switch back to master, offcourse the commit will not be visible but this time it is retained in newBranch.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit (newBranch)
		$ git checkout master
			Switched to branch 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit (master)
		$ git log --oneline
			11508a5 (HEAD -> master) 5th commit for robot.txt
			d69014a 4th commit for robot.txt
			9fd98bb 3rd commit for robot.txt
			5f64a06 2nd commit for robot.txt
			9e9633b 1st commit for robot.txt
			795f391 all files commited

	Here there is no sign of 6th commit, because it is retained in newBranch. As we know that git checkout commit would never modify the current state of project. 
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit (master)
		$ git checkout newBranch
			Switched to branch 'newBranch'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit (newBranch)
		$ cat robots.txt
			# www.robotstxt.org/

			# Allow crawling of all content
			User-agent: *
			Disallow:

			line 1....
			line 2....
			line 6....

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-checkout-commit (newBranch)
		$ git log --oneline
			e8cb9a7 (HEAD -> newBranch) 6th commit for robot.txt
			5f64a06 2nd commit for robot.txt
			9e9633b 1st commit for robot.txt
			795f391 all files commited


	So git checkout commit is an easy way to load saved snapshot/commits on to our machine and this command will update all files in working directory to match specified commit. 
	So once we do git checkout commit it would put you in a detached HEAD state. 
	Checking out old commit is a read only operation and it is impossible to harm your repository while viewing an old version.
	The current state of our project remains unaltered in the master branch. 
	During the normal course of the development, the HEAD will point to master or some other local branch. But when we checkout the previous commit HEAD no longer points to a branch but it points directly to a commit. And this is called a detached HEAD state.
	And whatever changes we make in the detached HEAD state is impermanent. We can retain our changes in our detached HEAD state only when we create a new branch using a - git checkout -b option.
	
	
34. Checking out files in a Git repository (Lab)

	In this lecture we will demonstrate how to use git checkout for files.
	
		$ pwd
			/c/Users/inarajp/Desktop/temp/Udemy-Git/Repositories

		$ mkdir undo-demo-git-repo

		$ git init
			Initialized empty Git repository in C:/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/.git/

		$ cd undo-demo-git-repo/

		$ git init
			Initialized empty Git repository in C:/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/undo-demo-git-repo/.git/

		$ vi checkoutfile

		$ git add checkoutfile
			warning: LF will be replaced by CRLF in checkoutfile.
			The file will have its original line endings in your working directory

		$ git commit -m "1st commit on checkoutfile"
			[master (root-commit) 15968e0] 1st commit on checkoutfile
			 1 file changed, 1 insertion(+)
			 create mode 100644 checkoutfile

		$ vi checkoutfile

		$ git commit -am "2nd commit on checkoutfile"
			warning: LF will be replaced by CRLF in checkoutfile.
			The file will have its original line endings in your working directory
			[master c1b6c49] 2nd commit on checkoutfile
			 1 file changed, 2 insertions(+)

		$ vi checkoutfile

		$ git commit -am "3rd commit on checkoutfile"
			warning: LF will be replaced by CRLF in checkoutfile.
			The file will have its original line endings in your working directory
			[master 66b5676] 3rd commit on checkoutfile
			 1 file changed, 1 insertion(+)

		$ vi checkoutfile

		$ git commit -am "4th commit on checkoutfile"
			warning: LF will be replaced by CRLF in checkoutfile.
			The file will have its original line endings in your working directory
			[master 68a3798] 4th commit on checkoutfile
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git log --oneline
			68a3798 (HEAD -> master) 4th commit on checkoutfile
			66b5676 3rd commit on checkoutfile
			c1b6c49 2nd commit on checkoutfile
			15968e0 1st commit on checkoutfile

		$ cat checkoutfile
			line 1
			line 2
			line 3
			line 4


	Syntax => git checkout <commit-id> <file-name>
	
			  git checkout c1b6c49 checkoutfile		//all the changes will be reverted to 2nd commit for that file. 
			
	Now this is quite different from what we did earlier when we did git checkout commit. In git checkout commit, the repository's current status is never changed. It always remains unaltered. However when we use above git checkout for file then there will be change in the current state of the project. 
	Also when we did git checkout commit in earlier lecture, it always ment that it is a particular commit which can involve change in multiple files.
	
		$ git checkout c1b6c49 checkoutfile
			Updated 1 path from ebd06d8

		$ git status
			On branch master
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   checkoutfile						//We can see that checkout command already add the file in the staging area, so no need fot git add command


		$ git log --oneline
			68a3798 (HEAD -> master) 4th commit on checkoutfile
			66b5676 3rd commit on checkoutfile
			c1b6c49 2nd commit on checkoutfile
			15968e0 1st commit on checkoutfile

		$ cat checkoutfile
			line 1
			line 2

	We can see changes has been modified for file checkoutfile. 
	We can see that checkout command already add the file in the staging area, so no need fot git add command. 
	At this point we can commit the changes with git commit command, but suppose we decide that we don't want this change and we want to again fallback => git checkout HEAD checkoutfile

		$ git checkout HEAD checkoutfile
			Updated 1 path from 01c6d56

		$ git status
			On branch master
			nothing to commit, working tree clean

		$ git log --oneline
			68a3798 (HEAD -> master) 4th commit on checkoutfile
			66b5676 3rd commit on checkoutfile
			c1b6c49 2nd commit on checkoutfile
			15968e0 1st commit on checkoutfile

		$ cat checkoutfile
			line 1
			line 2
			line 3
			line 4

	We can see the changes are now back in the file. 
	
	Now lets checkout the file back to 2nd commit and this time we will do a new commit for that state.
	
		$ git log --oneline
			68a3798 (HEAD -> master) 4th commit on checkoutfile
			66b5676 3rd commit on checkoutfile
			c1b6c49 2nd commit on checkoutfile
			15968e0 1st commit on checkoutfile

		$ git checkout c1b6c49 checkoutfile
			Updated 1 path from ebd06d8

		$ git status
			On branch master
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   checkoutfile

		$ git commit -m "5th commit on checkoutfile"
			[master 23d48f6] 5th commit on checkoutfile
			 1 file changed, 1 insertion(+), 2 deletions(-)

		$ git status
			On branch master
			nothing to commit, working tree clean

		$ git log --oneline
			23d48f6 (HEAD -> master) 5th commit on checkoutfile
			68a3798 4th commit on checkoutfile
			66b5676 3rd commit on checkoutfile
			c1b6c49 2nd commit on checkoutfile
			15968e0 1st commit on checkoutfile

		$ cat checkoutfile
			line 1
			line 2

	So git checkout commit file, checks out a previous version of a file. 
	This turns the file that resides in the working directory into an exact copy from the one in the commit-id and adds it into a staging area. 
	Checking out an old file does affects the current state of our repository. 
	So this usage serves as the way to revert back to an old version of an individual file. 
	

35. Reverting changes in a Git repository(Lab) 

	We will see how to use git revert command.
	
		$ git log --oneline
			23d48f6 (HEAD -> master) 5th commit on checkoutfile
			68a3798 4th commit on checkoutfile
			66b5676 3rd commit on checkoutfile
			c1b6c49 2nd commit on checkoutfile
			15968e0 1st commit on checkoutfile

		$ vi checkoutfile

		$ cat checkoutfile
			line 1
			line 2
			line 5					//newly added

		$ git status
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   checkoutfile

			no changes added to commit (use "git add" and/or "git commit -a")
		
		$ git add .

		$ git commit -m "commit prior to revert"
			[master f32e035] commit prior to revert
			 1 file changed, 1 insertion(+), 1 deletion(-)

		
		$ git log --oneline
			f32e035 (HEAD -> master) commit prior to revert
			23d48f6 5th commit on checkoutfile
			68a3798 4th commit on checkoutfile
			66b5676 3rd commit on checkoutfile
			c1b6c49 2nd commit on checkoutfile
			15968e0 1st commit on checkoutfile

	Now suppose this change which we made in above commit is undesirable and should be reverted. So here is where we can us git revert command - 
	
		git revert HEAD

		This will open up the default editor, so any changes if you want. After that commit will be done.  
		Any revert will automatically introduce a commit phase. 	
			
		$ git revert HEAD
			[master d40fb7f] Revert "commit prior to revert"
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git log --oneline
			d40fb7f (HEAD -> master) Revert "commit prior to revert"
			f32e035 commit prior to revert
			23d48f6 5th commit on checkoutfile
			68a3798 4th commit on checkoutfile
			66b5676 3rd commit on checkoutfile
			c1b6c49 2nd commit on checkoutfile
			15968e0 1st commit on checkoutfile

		$ cat checkoutfile
			line 1
			line 2

	We can see the changes have been reverted to earlier commit (with a new commit).
	
	Now instead of removing the commit from the project history, it actually tries to undo changes that was introduced by the commit and appends the new commit with the resulting content.
	Means instead of removing the old commit from commit history, it adds a new commit with our desired content.
	This prevents git from losing history. 
	
	

36. Resetting Git repository - Part1 (Lab)

	git-reset-demo-1	=> add few files and created few commit history
	git-reset-demo-2	=> Clone of git-reset-demo-1
	git-reset-demo-3	=> Clone of git-reset-demo-1
	git-reset-demo-4	=> Clone of git-reset-demo-1
	git-reset-demo-5	=> Clone of git-reset-demo-1

	git-reset-demo-1	=> 2 files => goldies-time-table, jimmys-time-table
							Both files have some 5 line.
							
							The way commit history was created is - he added 1 line in goldies-time-table and then in jimmys-time-table and then together committed it as a single commit.
							This was done 5 times. So logs has 5 commit history.
							
	Unlike git revert, git reset can be considered as dangerous way to undo changes. 
	When we undo changes using git reset, there is no way to retrive the original copy. It is a permanent undo. 
	It can be used to remove committed snapshot sometimes, although it is more often used to undo changes in staging area and the working directory. 
	In either case, it should only be used to undo local changes, and never reset snapshots that has been shared with other developers. 
	
	Syntax => git reset 
	
	
	Creating the infrastructure => 

		$ mkdir git-reset-demo-1

		$ ls
			demo-checkout-commit/  git-reset-demo-1/  initializr-verekia-4.0.zip  myRepoFromScratch/  undo-demo-git-repo/

		$ cd git-reset-demo-1

		$ git init
			Initialized empty Git repository in C:/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/git-reset-demo-1/.git/

		$ git status
			On branch master

			No commits yet

			nothing to commit (create/copy files and use "git add" to track)

		$ vi goldies-time-table

		$ vi jimmys-time-table

		$ git status
			On branch master

			No commits yet

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					goldies-time-table
					jimmys-time-table

			nothing added to commit but untracked files present (use "git add" to track)

		$ git add .
			warning: LF will be replaced by CRLF in goldies-time-table.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in jimmys-time-table.
			The file will have its original line endings in your working directory

		$ git status
			On branch master

			No commits yet

			Changes to be committed:
			  (use "git rm --cached <file>..." to unstage)
					new file:   goldies-time-table
					new file:   jimmys-time-table

		$ git commit -m "1st commit for goldies-time-table and jimmys-time-table"
			[master (root-commit) c9c0022] 1st commit for goldies-time-table and jimmys-time-table
			 2 files changed, 2 insertions(+)
			 create mode 100644 goldies-time-table
			 create mode 100644 jimmys-time-table

		$ git status
			On branch master
			nothing to commit, working tree clean

		
		.........
		.........
		.........
		
		$ vi goldies-time-table

		$ vi jimmys-time-table

		$ git commit -am "5th commit for goldies-time-table and jimmys-time-table"
			warning: LF will be replaced by CRLF in goldies-time-table.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in jimmys-time-table.
			The file will have its original line endings in your working directory
			[master 925acc5] 5th commit for goldies-time-table and jimmys-time-table
			 2 files changed, 2 insertions(+)

		$ cat goldies-time-table
			Goldie wakes up at 5 AM.
			Goldie brushes her teeth.
			Goldie gets ready for school.
			Goldie goes to school.
			Goldie comes back home from school.

		$ cat jimmys-time-table
			Jimmy wakes up at 8 AM.
			Jimmy brushes his theeth.
			Jimmy gets ready for school.
			Jimmy goes to school.
			Jimmy comes back home from school.

		$ git log --oneline
			925acc5 (HEAD -> master) 5th commit for goldies-time-table and jimmys-time-table
			ff3420b 4th commit for goldies-time-table and jimmys-time-table
			f26e9ba 3rd commit for goldies-time-table and jimmys-time-table
			ca4dd46 2nd commit for goldies-time-table and jimmys-time-table
			c9c0022 1st commit for goldies-time-table and jimmys-time-table

		$ vi jimmys-time-table

		$ git status
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   jimmys-time-table										//In red colour

			no changes added to commit (use "git add" and/or "git commit -a")

		$ git add jimmys-time-table
			warning: LF will be replaced by CRLF in jimmys-time-table.
			The file will have its original line endings in your working directory

		$ git status
			On branch master
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   jimmys-time-table									//In green colour


	We added a line in jimmys-time-table file and then added it to staging area. 
	Now lets say we don't want to keep that change we made and which is in staging area any more. 
	So we want to reset the change in staging area.
	
		$ git reset jimmys-time-table
			Unstaged changes after reset:
			M       jimmys-time-table					//M indicates file is in modified state. 

		$ git status
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   jimmys-time-table										//In red colour. File is in modified state. 

			no changes added to commit (use "git add" and/or "git commit -a")


	We can see that 'git reset jimmys-time-table' removed the file from staging area but leaves the working area unchanged (means changes are still there in working directory they are just not staged). 
	So this command unstages the file, without overriding any changes. 
	
	
		$ cat jimmys-time-table
			Jimmy wakes up at 8 AM.
			Jimmy brushes his theeth.
			Jimmy gets ready for school.
			Jimmy goes to school.
			Jimmy comes back home from school.
			Jimmy goes out to play.				//From this line we know that the changes is still there in working area


37. Resetting Git repository - Part2 (Lab)

	Here we will demonstrate another usage of reset command. 
	Earlier we say reset being use with respect to a particular file.
	We will use reset command now such that it will reset changes in multiple files. 
	
	Clone git-reset-demo-1 to git-reset-demo-2, git-reset-demo-3, git-reset-demo-4 and git-reset-demo-5
	
	We are now in git-reset-demo-2 repository =>
	
		$ git clone C:/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/git-reset-demo-1 .
			Cloning into '.'...
			done.

	
		$ git log --oneline
			925acc5 (HEAD -> master, origin/master, origin/HEAD) 5th commit for goldies-time-table and jimmys-time-table
			ff3420b 4th commit for goldies-time-table and jimmys-time-table
			f26e9ba 3rd commit for goldies-time-table and jimmys-time-table
			ca4dd46 2nd commit for goldies-time-table and jimmys-time-table
			c9c0022 1st commit for goldies-time-table and jimmys-time-table

	
	We can see that we have got the commit history as well from master.
	
	We cloned other repositories same way.
	
	We will now make changes in both file - 
	
		$ vi jimmys-time-table
		
		$ vi goldies-time-table

		$ cat jimmys-time-table
			Jimmy wakes up at 8 AM.
			Jimmy brushes his theeth.
			Jimmy gets ready for school.
			Jimmy goes to school.
			Jimmy comes back home from school.
			Jimmy goes out to play

		$ cat goldies-time-table
			Goldie wakes up at 5 AM.
			Goldie brushes her teeth.
			Goldie gets ready for school.
			Goldie goes to school.
			Goldie comes back home from school.
			Goldie goes out to play.

		$ git status
			On branch master
			Your branch is up to date with 'origin/master'.

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   goldies-time-table									//In red
					modified:   jimmys-time-table									//In red

			no changes added to commit (use "git add" and/or "git commit -a")

		$ git add .

		$ git status
			On branch master
			Your branch is up to date with 'origin/master'.

			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   goldies-time-table						//In green
					modified:   jimmys-time-table						//In green



	Now here to unstage changes from multiple file we need to execute git reset without any file reference => git reset
	
		$ git reset
			Unstaged changes after reset:
			M       goldies-time-table
			M       jimmys-time-table

		$ git status
			On branch master
			Your branch is up to date with 'origin/master'.

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   goldies-time-table									//In red
					modified:   jimmys-time-table									//In red

			no changes added to commit (use "git add" and/or "git commit -a")

	So git reset => resets the staging area to match the most recent commit. But these changes are there still in working directory. 
	
		$ cat goldies-time-table
			Goldie wakes up at 5 AM.
			Goldie brushes her teeth.
			Goldie gets ready for school.
			Goldie goes to school.
			Goldie comes back home from school.
			Goldie goes out to play.

		$ cat jimmys-time-table
			Jimmy wakes up at 8 AM.
			Jimmy brushes his theeth.
			Jimmy gets ready for school.
			Jimmy goes to school.
			Jimmy comes back home from school.
			Jimmy goes out to play

	
	Now we will see hot to use git reset using a hard option.
	
	The Hard option helps in not only unstage changes in staging area but also removes all the changes in working directory. 
	
	We will use git-reset-demo-2 only.
	
		$ git status
			On branch master
			Your branch is up to date with 'origin/master'.

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   goldies-time-table										//In red
					modified:   jimmys-time-table										//In red

			no changes added to commit (use "git add" and/or "git commit -a")

		$ git add .

		$ git status
			On branch master
			Your branch is up to date with 'origin/master'.

			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   goldies-time-table									//In Green
					modified:   jimmys-time-table									//In Green


	We again added changes in staging area.

		$ git reset --hard
			HEAD is now at 925acc5 5th commit for goldies-time-table and jimmys-time-table

		$ git log --oneline
			925acc5 (HEAD -> master, origin/master, origin/HEAD) 5th commit for goldies-time-table and jimmys-time-table
			ff3420b 4th commit for goldies-time-table and jimmys-time-table
			f26e9ba 3rd commit for goldies-time-table and jimmys-time-table
			ca4dd46 2nd commit for goldies-time-table and jimmys-time-table
			c9c0022 1st commit for goldies-time-table and jimmys-time-table

		$ git status
			On branch master
			Your branch is up to date with 'origin/master'.

			nothing to commit, working tree clean

	Here we can see that --hard option has not just unstaged the changes in staging area, but also removed them from the working directory.
	
	So git reset with --hard option will reset the staging area and working directory to match the most recent commit.
	This destroys all the uncommited changes.
	

Resetting Git repository - Part3 (Lab)

	Here we will be dealing with git reset and a particular commit id will have a soft option as well as hard option.
	
	We swicthed to git-reset-demo-3
	
		$ pwd
			/c/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/git-reset-demo-3

		$ git log --oneline
			925acc5 (HEAD -> master, origin/master, origin/HEAD) 5th commit for goldies-time-table and jimmys-time-table
			ff3420b 4th commit for goldies-time-table and jimmys-time-table
			f26e9ba 3rd commit for goldies-time-table and jimmys-time-table
			ca4dd46 2nd commit for goldies-time-table and jimmys-time-table
			c9c0022 1st commit for goldies-time-table and jimmys-time-table

		$ git reset ff3420b
			Unstaged changes after reset:
			M       goldies-time-table
			M       jimmys-time-table

		$ git log --oneline
			ff3420b (HEAD -> master) 4th commit for goldies-time-table and jimmys-time-table
			f26e9ba 3rd commit for goldies-time-table and jimmys-time-table
			ca4dd46 2nd commit for goldies-time-table and jimmys-time-table
			c9c0022 1st commit for goldies-time-table and jimmys-time-table

	
	Using git reset ff3420b => we reset to 4th commit and we can see that later the 5th commit is missing completely. 
	
	So git reset <commit-id> has not only removed the 5th commit from commit history but also unstaged the changes that we made in 5th commit and retained the changes in the working directory.
	
	Changes which were made in 5th commit are still there in working directory =>
	
		$ git status
			On branch master
			Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.
			  (use "git pull" to update your local branch)

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   goldies-time-table									//In red
					modified:   jimmys-time-table									//In red

			no changes added to commit (use "git add" and/or "git commit -a")


	We can again commit them, like one file each commit or all files at once. We are commiting one file at a time now, as earlier we had 2 files in single commit.

		$ git add jimmys-time-table

		$ git commit -m "1st commit - post reset - jimmys"
			[master 25907e0] 1st commit - post reset - jimmys
			 1 file changed, 1 insertion(+)

		$ git status
			On branch master
			Your branch and 'origin/master' have diverged,
			and have 1 and 1 different commits each, respectively.
			  (use "git pull" to merge the remote branch into yours)

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   goldies-time-table

			no changes added to commit (use "git add" and/or "git commit -a")


		$ git add goldies-time-table

		$ git commit -m "2st commit - post reset - goldie"
			[master 4ffd33f] 2st commit - post reset - goldie
			 1 file changed, 1 insertion(+)

		$ git status
			On branch master
			Your branch and 'origin/master' have diverged,
			and have 2 and 1 different commits each, respectively.
			  (use "git pull" to merge the remote branch into yours)

			nothing to commit, working tree clean

	
		$ git log --oneline
			4ffd33f (HEAD -> master) 2st commit - post reset - goldie
			25907e0 1st commit - post reset - jimmys
			ff3420b 4th commit for goldies-time-table and jimmys-time-table
			f26e9ba 3rd commit for goldies-time-table and jimmys-time-table
			ca4dd46 2nd commit for goldies-time-table and jimmys-time-table
			c9c0022 1st commit for goldies-time-table and jimmys-time-table

	
	Now we will see git reset commit with hard option.
	This is one of the most destructive command.
	
	We are in git-reset-demo-4 repository.
	
		$ pwd
			/c/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/git-reset-demo-4

		$ git log --oneline
			925acc5 (HEAD -> master, origin/master, origin/HEAD) 5th commit for goldies-time-table and jimmys-time-table
			ff3420b 4th commit for goldies-time-table and jimmys-time-table
			f26e9ba 3rd commit for goldies-time-table and jimmys-time-table
			ca4dd46 2nd commit for goldies-time-table and jimmys-time-table
			c9c0022 1st commit for goldies-time-table and jimmys-time-table

	Now suppose we want to remove commits 4ht and 5th completely from commit history and we also want to removed changes made in both these commits.
	
		$ cat jimmys-time-table
			Jimmy wakes up at 8 AM.
			Jimmy brushes his theeth.
			Jimmy gets ready for school.
			Jimmy goes to school.
			Jimmy comes back home from school.

		$ cat goldies-time-table
			Goldie wakes up at 5 AM.
			Goldie brushes her teeth.
			Goldie gets ready for school.
			Goldie goes to school.
			Goldie comes back home from school.

	So now we want to reset the commit to 3rd commit with hard option. 
	Which means noth only the 4th and 5th commit will disappear from commit history but also the changes related to these two commits will disappear from the corresponding artifact.
	
		$ git log --oneline
			925acc5 (HEAD -> master, origin/master, origin/HEAD) 5th commit for goldies-time-table and jimmys-time-table
			ff3420b 4th commit for goldies-time-table and jimmys-time-table
			f26e9ba 3rd commit for goldies-time-table and jimmys-time-table
			ca4dd46 2nd commit for goldies-time-table and jimmys-time-table
			c9c0022 1st commit for goldies-time-table and jimmys-time-table

		$ git reset --hard f26e9ba
			HEAD is now at f26e9ba 3rd commit for goldies-time-table and jimmys-time-table

		$ cat jimmys-time-table
			Jimmy wakes up at 8 AM.
			Jimmy brushes his theeth.
			Jimmy gets ready for school.

		$ cat goldies-time-table
			Goldie wakes up at 5 AM.
			Goldie brushes her teeth.
			Goldie gets ready for school.

		$ git log --oneline
			f26e9ba (HEAD -> master) 3rd commit for goldies-time-table and jimmys-time-table
			ca4dd46 2nd commit for goldies-time-table and jimmys-time-table
			c9c0022 1st commit for goldies-time-table and jimmys-time-table


	So the git reset commit with the hard option, moves the current branch tip backward to the commit id we are using and resets both the staging area and working directory.
	This destroys not only the uncommited changes but all commits after the commit id in question as well. 
	

39. Cleaning Git repository (Lab)

	We will talk about command - git clean
	
	This command will remove untracked files from our working directory. This command is not undoable.
	
	The git clean command is often executed along with the git reset with hard option. Resetting will only affect tracked files. So a separate command is important for cleaning up the untracked files.
	
	So this git clean command and git reset with hard option, together lets us to return to the working directory to the exact state of a particular commit. 
	
		$ mkdir git-clean-demo

		$ cd git-clean-demo

		$ pwd
			/c/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/git-clean-demo

		$ git init
			Initialized empty Git repository in C:/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/git-clean-demo/.git/

	Lets create empty files using touch command =>
	
		$ touch clean-demo-file

		$ touch clean-demo-tracked-file

		$ ls
			clean-demo-file  clean-demo-tracked-file
	
		$ git status
			On branch master

			No commits yet

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					clean-demo-file
					clean-demo-tracked-file

			nothing added to commit but untracked files present (use "git add" to track)

	Lets add the clean-demo-tracked-file to staging area and commit it.

		$ git add clean-demo-tracked-file

		$ git commit -m "commit tracked file"
			[master (root-commit) 5b660e9] commit tracked file
			 1 file changed, 0 insertions(+), 0 deletions(-)
			 create mode 100644 clean-demo-tracked-file

		$ git status
			On branch master
			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					clean-demo-file

			nothing added to commit but untracked files present (use "git add" to track)


	So we have one untracked and one tracked file.
	
	git clean -n => will perform the dry run of git clean, means it will just show you which files will be cleaned without actually removing it.
	
		$ git clean -n
			Would remove clean-demo-file

	git clean -f => removes untracked files from current directory. The -f or force flag is required unless the clean.requireForce configuration option is set to false. 
	Now clean.requireForce is usually set to true by default. 
	This command will not remove untracked folder and files specified by .gitignore file.
	
		$ git clean -f
			Removing clean-demo-file

		$ ls
			clean-demo-tracked-file

	git clean -f <path> => It will remove all the untracked file, but the operation is limitted only to a specific path. 

		$ mkdir clean-demo-dir

		$ cd clean-demo-dir

		$ touch clean-demofile-2

		$ cd ..

		$ git clean -f clean-demo-dir
		Removing clean-demo-dir/

		$ ls
		clean-demo-tracked-file

	
	git clean -df => d stands for directory. This command will remove both untracked files as well as untracked directories from the current directory.
	
		$ ls
			clean-demo-dir/  clean-demo-file-2  clean-demo-tracked-file

		$ git clean -df
			Removing clean-demo-dir/
			Removing clean-demo-file-2

	We can see that this command has removed untracked directory and untracked file.
	
	git clean -xf => This command will remove untracked files from current directory as well as any files that git usually ignores. Any file that is ignored by git is actually mentioned in .gitignore file. 

		$ vi .gitignore

		$ cat .gitignore
			clean-demo-file-5

		$ touch clean-demo-file-4

		$ touch clean-demo-file-5
		
		$ ls
			clean-demo-file-4  clean-demo-file-5  clean-demo-tracked-file

		$ git add .gitignore
			warning: LF will be replaced by CRLF in .gitignore.
			The file will have its original line endings in your working directory

		$ git commit -m "commiting .gitignore"
			[master 5959e9b] commiting .gitignore
			 1 file changed, 1 insertion(+)
			 create mode 100644 .gitignore
		
		$ ls -al
			total 13
			drwxr-xr-x 1 inarajp 1049089  0 Apr 13 14:21 ./
			drwxr-xr-x 1 inarajp 1049089  0 Apr 13 13:55 ../
			drwxr-xr-x 1 inarajp 1049089  0 Apr 13 14:23 .git/
			-rw-r--r-- 1 inarajp 1049089 18 Apr 13 14:20 .gitignore
			-rw-r--r-- 1 inarajp 1049089  0 Apr 13 14:21 clean-demo-file-4
			-rw-r--r-- 1 inarajp 1049089  0 Apr 13 14:21 clean-demo-file-5
			-rw-r--r-- 1 inarajp 1049089  0 Apr 13 13:57 clean-demo-tracked-file

	Now clean-demo-file-5 is mentioned in .gitignore file and still it will be removed along with untracked file.
	
		$ git clean -xf
			Removing clean-demo-file-4
			Removing clean-demo-file-5

		$ ls
			clean-demo-tracked-file

	Git would have ignored clean-demo-file-5 file in normal circumstances but as we used -xf option, it removed it.
	
	git clean command can also be useful for cleaning up a working directory after a build. So for example if we compile java application, it creates .class files, so we can remove them. We can add these files in .gitignore and then it will be removed it -xf option.
	
	Along with git reset, git clean is only git command that has a potential to permanently delete commits. 
	
	"git reset" command affects only tracked files whereas "git clean command" affects only untracked files
	
	

40. Command Summary (Undoing changes in
a Git repository)


	Command Summary (Undoing changes in a Git repository)
	LECTURE - Checking out commits in a Git repository - Part 1


	$ cd git-fast
	# created a fresh git repository named "demo-checkout-commit" using initializr.zip
	# Build up a commit history by modifying the file robots.txt, say 5 times and committing each time
	# Let us assume we have one commit whose id/hash is 91770af
	# the choice of commit id 91770af is arbitrary
	 
	# note where the HEAD is now (since HEAD will change later while doing a checkout)
	$ git log --oneline
	 
	# clear the screen
	# The command below will put you in a detached HEAD state.
	# HEAD no longer points to a branch; it points directly to a commit.
	$ git checkout 91770af


	LECTURE - Checking out commits in a Git repository - Part 2

	# you are in detached HEAD state and inside git repository (demo-checkout-commit)
	# You can see only commits till commit-id 91770af
	$ git log --oneline
	 
	# now edit and do a express commit for file robots.txt
	# note down your new commit id/hash (Say ID1)
	$ git log --oneline
	 
	$ git checkout master
	 
	# changes made in detached HEAD state is no more there
	# the new commit ID1 is not visible
	$ git log --oneline
	 
	# again you are in detached HEAD state
	$ git checkout 91770af
	 
	# the new commit ID1 is not visible which means earlier changes...
	# in detached HEAD state were not preserved
	$ git log --oneline
	 
	# now we want to retain our commit i.e, preserve our changes
	# make changes in the robots.txt and do an express commit
	 
	# create a branch named weird-experiment
	$ git branch  weird-experiment
	 
	$ git checkout master
	# the new commit id is not visible here
	# you can check the file robots.txt using cat command also
	$ git log --oneline
	 
	# new commit id is visible now
	# you can examine the file robots.txt using cat command
	$ git checkout weird-experiment


	LECTURE - Checking out files

	# cd to git repository (demo-checkout-commit) used in previous lecture
	$ git log --online
	 
	# Let us assume we have the commit-id 91770af
	 
	# step-2: examine the current contents of the file
	$ cat robots.txt
	 
	# now we will able to see the content of the file as at commit-id 91770af
	$ git checkout 91770af robots.txt
	 
	# this will show the file has been added to staging area
	$ git status
	 
	# step-5: examine the contents of the file (should be different from step-2)
	$ cat robots.txt
	 
	# if we do not want to revert back the file robots.txt
	$ git checkout HEAD robots.txt
	 
	# you will see a clean working directory
	$ git status
	 
	# now we want to revert back to previous version of robots.txt as at commit-id 91770af
	$ git checkout 91770af robots.txt
	$ git commit -am "reverting back file state to commit 91770af"
	 
	# clean working directory
	$ git status
	 
	 
	# file is reverted and the contents are as seen in step-5
	$ cat robots.txt  


	LECTURE - Reverting changes

	# cd into repository "undo-demo-git-repo"
	 
	# add the text say, "line 5"
	$ vim checkoutfile.txt
	 
	# modified stage visible
	$ git status
	 
	# commit the above change
	$ git commit -am checkoutfile.txt "commit message..."
	 
	$ git log --oneline
	$ cat checkoutfile.txt
	 
	# Now let's assume the earlier commit is a buggy one and so we will revert it
	# revert command introduces a new commit in a safe manner (opens the default editor)
	$ git revert HEAD
	 
	# check commit history - a new commit for revert
	$ git log --oneline
	 
	# note the change made earlier has been reverted "line 5" is not visible
	$ cat checkoutfile.txt


	LECTURE - Resetting Git repository - Part1

	# we are in repository git-reset-demo-1 with 2 files goldies-time-table and jimmys-time-table
	# the repository has an existing commit history
	 
	# now edit file jimmys-time-table and add a line at the end
	$ vim jimmys-time-table
	 
	# add the change to staging area
	$ git add jimmys-time-table
	 
	# change in staging area is visible
	$ git status
	 
	# undoes changes in staging area
	$ git reset jimmys-time-table
	 
	# changes in staging area is removed; file in modified state
	$ git status
	 
	# the changed in working directory is intact
	$ cat jimmys-time-table


	LECTURE - Resetting Git repository - Part2

	# we are in repository git-reset-demo-2 (this repo is clone of git-reset-demo-1)
	 
	# edit file and add one line at the end
	$ vim jimmys-time-table
	 
	# edit file and add one line at the end
	$ vim goldies-time-table
	 
	# files are in modified state
	$ git status
	 
	# add both files to staging area
	$ git add .
	 
	# changes visible in staging area
	$ git status
	 
	# "reset" command removes changes in staging area leaving the working directory intact
	$ git reset
	 
	# both files in modified state
	$ git status
	 
	#######################################
	# git reset demo using the --hard option
	# we are still in git-reset-demo-2 repository(this repo is clone of git-reset-demo-1)
	 
	# files are in modified state
	$ git status
	 
	# add both files to staging area
	$ git add .
	 
	# changes visible in staging area
	$ git status
	 
	# --hard option removes all changes in working directory and staging area
	$ git reset --hard
	 
	# the working directory is clean since all changes have been reset in working dir and staging
	$ git status


	LECTURE - Resetting Git repository - Part3

	# we are inside git-reset-demo-4 repository (this repo is clone of git-reset-demo-1)
	 
	# Let's say, we have 5 commits in the commit history
	# let' say, the 5th commit-id (HEAD) is 9166e4f and 4th commit-id is d21a539
	$ git log --oneline
	 
	# let's reset the repository to 4th commit-id
	$ git reset d21a539
	 
	# the 5th commit-id(9166e4f) has been removed from history and the HEAD is now at d21a539
	$ git log --oneline
	 
	# the files are in modified state and changes in staging area has been removed
	# the files are jimmys-time-table and goldies-time-table
	$ git status
	 
	# now we will commit the above changes in working dir in 2 smaller chunks
	$ git add jimmys-time-table
	$ git commit -m "commit message....."
	 
	# now only goldies-time-table changes are visible in modified state
	$ git status
	 
	$ git add goldies-time-table
	$ git commit -m "commit message....."
	 
	# clean working directory
	$ git status
	 
	$ git log --oneline


	# we are in git-reset-demo-5 repository (this repo is clone of git-reset-demo-1)
	 
	# let's say there are 5 commits
	$ git log --oneline
	 
	# now we will reset to the 3rd commit-id a53f51c (2 commits before HEAD) with the --hard option
	# this command will remove 4th & 5th commit-ids as well removed all changes in working dir and staging area
	$ git reset --hard a53f51c
	 
	# the 4th and 5th commit-ids has been removed from history
	$ git log --oneline
	 
	# examine the file contents to confirm things
	# the lines pertaining to 4th and 5th commit-ids has been removed
	$ cat goldies-time-table
	$ cat jimmys-time-table


	LECTURE - Cleaning Git repository

	$ cd git-fast
	$ mkdir git-clean-demo
	$ cd git-clean-demo
	 
	# create an empty repository
	$ git init
	 
	# create few empty files
	$ touch clean-demo-file
	$ touch clean-demo-tracked-file
	 
	$ git add clean-demo-tracked-file
	$ git commit -m "commit tracked file"
	 
	# shows clean-demo-file as an untracked file
	$ git status
	 
	# -n option allows to make a dry run of "git clean" command
	$ git clean -n
	 
	#################################################
	 
	# -f option (-f means force) removes untracked files from current directory
	# so this will remove clean-demo-file
	$ git clean -f
	 
	#################################################
	 
	$ mkdir clean-demo-dir
	$ cd clean-demo-dir
	 
	# create an untracked file
	$ touch clean-demofile-2
	 
	$ cd ..
	 
	# removes untracked file in path clean-demo-dir
	$ git clean -f clean-demo-dir/
	 
	#confirm untracked file cleaning
	$ cd clean-demo-dir
	 
	# "ls" produces no results meaning the untracked file was cleaned
	$ ls
	 
	#################################################
	$ cd ..
	$ ls
	$ touch clean-demo-file-2
	$ ls
	 
	# -df option cleans both untracked files and directories
	$ git clean -df
	$ ls
	 
	#################################################
	# create .gitignore file and add the file name "clean-demo-file-5"
	$ vim .gitignore
	$ git add .gitignore
	$ git commit -m "committing .gitignore file"
	 
	$ touch clean-demo-file-4
	$ touch clean-demo-file-5
	$ ls -al
	 
	# -xf option cleans all untracked files including those mentioned in .gitignore file
	$ git clean -xf
	 
	$ ls



Section 9: Pushing into GitHub

41. Basics and Introduction - pushing into GitHub!

	We will learn , git pull and git push.
	
	git pull => Allows developers to sync with remote repository
				Synchronize our local repository with our remote repository before we do anything using push command.
				
	git push => Developer pushes his local changes or commits into remote repository.
				It enables us to upload our local changes to remote repository.
				
	

42. Best practice - pulling changes from GitHub repository (Lab)
	
	We will demonstrate git pull.
	
	We will clone a repository from github into our local. 
	Then we will directly edit a file in github and commit it on github.
	We will then do 'git pull origin master' from our local to get the latest changes of remote to our local.
	
	git pull origin master => origin is a remote repository. master points to the master branch of the remote repository.
	
	When we clone a repository with git clone command it automatically creates a remote connection called 'origin' pointing back to the clone repository. 
	This is useful for developers, creating a local copy of a remote repository since it provides an easy way to pull upstream changes. 
	This behavior is also why most git project call there remote repository as origin. 
	Cloning generally sets up both the name origin and the master for you automatically. 
	git pull origin master => fetches a copy of the master branch from the original repository, here remote, and merges it with the current branch you have checkout. 
	
	Always issue a git pull command before issuing a git push. This will sync our repository with changes made by other developers.
	This is always a best practice.
	
		$ git clone https://github.com/aniketrajput/hello-world.git
			Cloning into 'hello-world'...
			remote: Enumerating objects: 7, done.
			remote: Total 7 (delta 0), reused 0 (delta 0), pack-reused 7
			Receiving objects: 100% (7/7), done.
			Resolving deltas: 100% (1/1), done.

		$ ls
		demo-checkout-commit/  git-reset-demo-1/  git-reset-demo-3/  git-reset-demo-5/  initializr-verekia-4.0.zip  undo-demo-git-repo/
		git-clean-demo/        git-reset-demo-2/  git-reset-demo-4/  hello-world/       myRepoFromScratch/

		$ cd hello-world/

		$ ls
		README.md

		$ git pull origin master
			remote: Enumerating objects: 6, done.
			remote: Counting objects: 100% (6/6), done.
			remote: Compressing objects: 100% (5/5), done.
			remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0
			Unpacking objects: 100% (6/6), 1.40 KiB | 25.00 KiB/s, done.
			From https://github.com/aniketrajput/hello-world
			 * branch            master     -> FETCH_HEAD
			   6e0773f..ff5a702  master     -> origin/master
			Updating 6e0773f..ff5a702
			Fast-forward
			 README.md  | 4 +++-
			 helloworld | 1 +
			 2 files changed, 4 insertions(+), 1 deletion(-)
			 create mode 100644 helloworld

		$ ls
			helloworld  README.md

		$ cat README.md
			# hello-world
			hello_world_repo

			Hello my name is Aniket Rajput.
			I am a software engineer.

			This is a demo hello-world project

	In the command "git pull origin master" => "origin" is the remote repository and "master" points to the master branch of the remote repository.
	
	Cloning generally sets up both the names "origin and master" for you automatically
	
	"git pull origin master" command fetches a copy of the master branch from the remote repository (origin), and merges it with the current branch you have checked out
	
	"git pull" may not matter much but it is an important command when you will be working in a team where multiple developers are involved since you need to be in sync with commits from other developers. So always issue a "git pull" command before issuing "git push".
	
	
43. Transferring your commits - pushing local changes into GitHub repository (Lab)	
	
	When we make any changes in local repository that we need to push to remote repository, we need to issue a git push command. 
	This is a command scenario where there is central repository where all developers need to push there changes.
	
	We will make change in a particular file in our local repository and we will then push that file to remote repository.
	
		$ ls
			helloworld  README.md

		$ vi helloworld

		$ cat helloworld
			Hello world!
			This change was made in local.

		$ git status
			On branch master
			Your branch is up to date with 'origin/master'.

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   helloworld

			no changes added to commit (use "git add" and/or "git commit -a")

		$ git add helloworld

		$ git commit -m "helloworld file updated to demonstrate push"
			[master cc7897f] helloworld file updated to demonstrate push
			 1 file changed, 1 insertion(+)

	Now to push => 
	
	git push origin master => origin referes to the remote repository, same as it was explained earlier. 
	master referes to a master branch of our local repository where we have made certain changes and these are the changes which we want to push back to the remote repository. 
	
	In the command "git pull origin master" => "origin" refers to the remote repository and "master" refers to the master branch of the local repository.
	
	After executing the 'git push origin master' command, it asks for github username and password.

		$ git push origin master
			Enumerating objects: 5, done.
			Counting objects: 100% (5/5), done.
			Delta compression using up to 8 threads
			Compressing objects: 100% (2/2), done.
			Writing objects: 100% (3/3), 351 bytes | 351.00 KiB/s, done.
			Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
			To https://github.com/aniketrajput/hello-world.git
			   ff5a702..cc7897f  master -> master


	Note that git push origin master command, works only if you have cloned rfom a server to which you have write access and if nobody has pushed in the meantime. 
	If you and someone else cloned at the same time and they pushed upstream and then subsiquently you pushed upstream, then your push will rightly be rejected. 
	You will have to pull your teams changes first and incorporate into yours, before you will be allowed to push your changes.
	
	
	"pull before push" allow us to synchronize our local repository with our remote repository!
	
	"git push origin master " command works only if you cloned from a server to which you have write access - which of the following is correct regard this statement:
	

44. Command Summary resource (Pushing into GitHub)

Command Summary resource (Pushing into GitHub)
	Command Summary - pull and push

	 
	$ git pull

	# cloning generally sets up both the names "origin and master" for you automatically
	$ git push origin master 

If we have a branch like test-branch. The we can switch to that branch using => git checkout test-branch. Then make our changes and push to that test-branch => git push origin test-branch


Section 10: GitHub via SSH

45. Basic and Introduction - GitHub via SSH

	We will learn how to communicate with github using SSH protocol.

	SSH means Secure Shell, also known as Secure Socket Shell. It is a unix based command interface and protocol for securely getting access to our remote computer. 
	
	SSH keys => are a way to identify trusted computers.
	This identification process doesn't involve passwords and is more secured than the password based authentication system.
	
	To achieve SSH authentication we need to generate public private key pair.
	
	Public key is meant to be shared publicly. It is made available to everyone via a publicly accessible repository or directory. This is sharable.
	
	Private key is meant to be kept securely to oneself. Never share it with anyone.
	
	Suppose Bob wants to send a data securely to Alice and want to be sure that only Alice will be able to read it, the he will encrypt the data with Alice Public key. 
	Only Alice has access to her corresponding private key and thus she is the only one to decrypt the encrypted data. 

	So far we communicated with github with https protocol. 


46. Do I already have SSH Keys (Lab)

	SSH key are usually generated in folder .ssh which is located in user's home directory.
	
	Check if we have .ssh folder in user's home directory => ls -l ~/.ssh
	Here ~ represents the user's home directory.
		
	
	$ ls -l ~/.ssh
	total 9
	-rw-r--r-- 1 inarajp 1049089 1679 Jan 25  2019 id_rsa	//This is the private key
	-rw-r--r-- 1 inarajp 1049089  398 Jan 25  2019 id_rsa.pub	//This is a public key
	-rw-r--r-- 1 inarajp 1049089  835 Feb  6  2019 known_hosts

	
	We can use the same keys or if you want to generate new key then we can delete this using => rm -rf .ssh
	
	By default the name of the public key file is one of the following - 
		- id_dsa.pub
		- id_ecdsa.pub
		- id_ed25519.pub
		- id_rsa.pub
		
	If we don't wish to use the existing keys to connect to github then we need to generate new ones.
	
	
47. Let's generate an SSH Key pair for local and GitHub usage (Lab)			

	We can use two types of keys RSA and DSA.
	Both of them are key generation algorithm. 
	
	RSA => stands for Ron Rivest, Adi Shamir, and Leonard Adleman
	
	RSA algorithm is widely used for secured data transmission and it can be used to generate public private key pair.
	
	RSA is one of the first practical public-key cryptosystem.
	 
	RSA key length - Minimum: 768 bits; default length: 2048 bits.Bigger the key length the more is the time required for decryption.

	
	DSA => stands for Digital Signature Algorithm. 
	
	DSA key length - is always 1024 bits. As RSA allows more we can have much better keys in RSA.
	
	SSH keygen program. It also generates .ssh directory in user's home directory which contains the key pair.

	ssh-keygen => it will generate key pairs with default values. 
	
	ssh-keygen -t rsa => -t defines the type of the key. So if we want dsa we can type dsa. We are generating rsa key in this case. 
	
	ssh-keygen -t rsa -b 4096 => -b determines the key length. 4096 will generate much stronger encrypted key pair. 
	
	ssh-keygen -t rsa -b 4096 -C "key pair geneneration demo" => -C is comment. This comment is very helpful if we have a multiple key pair, then it will help us distingush between different kwy pairs.
	
	After above command it asks for => Enter file in which to save the key (/c/Users/inarajp/.ssh/id_rsa): here we can provide some different location and we can also change the file default name
	Later it asks for password, we can just press enter for no password.
	
	The key fingerprint is the short sequence of bytes used to identify a longer public key.
	
	
	$ ssh-keygen -t rsa -b 4096 -C "key pair geneneration at temp"
	Generating public/private rsa key pair.
	Enter file in which to save the key (/c/Users/inarajp/.ssh/id_rsa): /c/Users/inarajp/Desktop/temp/ssh/id_rsa
	Enter passphrase (empty for no passphrase):
	Enter same passphrase again:
	Your identification has been saved in /c/Users/inarajp/Desktop/temp/ssh/id_rsa
	Your public key has been saved in /c/Users/inarajp/Desktop/temp/ssh/id_rsa.pub
	The key fingerprint is:
	SHA256:APimCM4Q2/UZdk4xI3gLxU7OX3Vq7nIDlhApZi58+Dg key pair geneneration at temp
	The key's randomart image is:
	+---[RSA 4096]----+
	|   ..+o +o       |
	|. . +.X.=o  . .  |
	| + + #.O . . o   |
	|+ . * X.o . o    |
	|=. o = .So +     |
	|.o. E . . + .    |
	|     .   . o     |
	|          . +    |
	|           o .   |
	+----[SHA256]-----+

	
48. SSH Agent and keys (Lab)

	In this lecture we will enable the ssh agent and add the ssh key to the agent.

	eval "$(ssh-agent -s)"	=> this command will start the ssh agent in the background.
	
	Now we need to add our ssh key to our ssh agent => ssh-add ~/.ssh/id_rsa
	Here ~ represents user's home directory, we will have to change that path. So we have added the public key to ssh agent.
	
	Errata: Lecture - SSH Agent and keys
	Dear Students,

	Please note that the video showed running the following command for adding SSH key to the agent:

	$ ssh-add ~/.ssh/id_rsa.pub

	The above command attempted to add the public key to the Agent and this will result in error in the latest versions of Git. Instead you should add the private key to the agent by running the following command:

	$ ssh-add ~/.ssh/id_rsa
	

50. Adding the SSH Key to GitHub account (Lab)

	Now that we have associated ssh agent with the private key we need to add the ssh key with the github account. In other words we need to associate ssh key with the github account.
	
	We can copy the public key using copy paste or using clip command => clip < ~/.ssh/id_rsa.pub
	
	Go to github and add the public key ther.
	

51. Checking your SSH connection with GitHub (Lab)
	
	ssh -T -p 443 git@ssh.github.com
	
		$ ssh -T -p 443 git@ssh.github.com
			The authenticity of host '[ssh.github.com]:443 ([192.30.253.122]:443)' can't be established.
			RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
			Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
			Warning: Permanently added '[ssh.github.com]:443,[192.30.253.122]:443' (RSA) to the list of known hosts.
			Hi aniketrajput! You've successfully authenticated, but GitHub does not provide shell access.

	
	ssh -T -p 443 git@github.com => This command is to be used if we have certain firewall issues and we cannot use pure ssh connection. 
	If we don't have any firewall issue and we are able to use pure ssh then we don't need to use this command, rather we can modify it as => ssh -T git@github.com 
		
	
	
52. Switching remote GitHub URL (Lab)

	We are in hello-world repository. 
	List our existing remote using => git remote -v (v stands for verbose)
	
		$ git remote -v
			origin  https://github.com/aniketrajput/hello-world.git (fetch)
			origin  https://github.com/aniketrajput/hello-world.git (push)

	Above command show that we were using the https protocol, which is secure version of http to communicate with github. 
	
	Since we want to communicate using SSH, we will switch from https to ssh using below command => git remote set-url origin git@github.com:aniketrajput/hello-world
	
	Here origin is remote reference for our github repository
	git@github.com:aniketrajput/hello-world => aniketrajput is username and hello-world is repository name.

		$ git remote set-url origin git@github.com:aniketrajput/hello-world

		$ git remote -v
			origin  git@github.com:aniketrajput/hello-world (fetch)
			origin  git@github.com:aniketrajput/hello-world (push)

		
	Now we can see that we have switched from https communication to ssh communication.
	
		$ git pull origin master
			remote: Enumerating objects: 3, done.
			remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3
			Unpacking objects: 100% (3/3), 341 bytes | 24.00 KiB/s, done.
			From github.com:aniketrajput/hello-world
			 * branch            master     -> FETCH_HEAD
			   cc7897f..95cc3de  master     -> origin/master
			Updating cc7897f..95cc3de
			Fast-forward
			 helloworld | 1 +
			 1 file changed, 1 insertion(+)


	We can see pull command works efficiently. 

		$ vi helloworld

		$ cat helloworld
			Hello world!
			This change was made in local.
			This is to test branching.
			This is to test ssh.

		$ git status
			On branch master
			Your branch is up to date with 'origin/master'.

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   helloworld

			no changes added to commit (use "git add" and/or "git commit -a")

		$ git add helloworld

		$ git status
			On branch master
			Your branch is up to date with 'origin/master'.

			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   helloworld


		$ git commit -m "testing ssh with push"
			[master 9a74991] testing ssh with push
			 1 file changed, 1 insertion(+)

		
		$ git push origin master
			Enumerating objects: 5, done.
			Counting objects: 100% (5/5), done.
			Delta compression using up to 8 threads
			Compressing objects: 100% (3/3), done.
			Writing objects: 100% (3/3), 335 bytes | 335.00 KiB/s, done.
			Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
			remote: Resolving deltas: 100% (1/1), completed with 1 local object.
			To github.com:aniketrajput/hello-world
			   95cc3de..9a74991  master -> master


	We can see that push is also done successfully, we can also confirm by going to github. 
	
	Now if we want to switch back from ssh to https, then we can do that using command => 
	
	First check status of our connection protocol vise => git remote -v => this will list our existing remotes. 

	Now to switch to https => git remote set-url origin https://github.com/aniketrajput/hello-world.git
	
	https://github.com/aniketrajput/hello-world.git => repository https url which we use for cloning. 
	

53. Changing passphrase of SSH Key pair (Lab)

	Now we have learnt that SSH is a public key authentication system and usage of password is not manadary here. However we can use password if we want. 
	
	Earlier while generating the keys we didn't opt for any password and hence it was an empty passphrase. 
	
	Now lets try to add a password to public-private key pair we genenerated earlier.
	
	ssh-keygen -p => This will ask for location, give same which we gave while geneneration. 
	And then enter passphrase.
	
	So now next time when we do push we would be prompted for password.


54. Command Summary (GitHub via SSH)
	
	Command Summary (GitHub via SSH)
	Checking existing SSH Keys

	$ ls -al ~/.ssh         # Lists the files in your .ssh directory, if they exist



	Generate an SSH Key

	# Generates public/private rsa key pair with default values - DON'T RUN THIS ONE
	$ ssh-keygen           

	 # 't' for type of key, 'b' for length of key, 'C' for comment for maintaining multiple keys                                
	$ ssh-keygen -t rsa -b 2048 - C "home machine"


			
	Enable SSH Agent & add the SSH Key to the agent

	# start the ssh-agent in the background
	$ eval "$(ssh-agent -s)"        

	# Add your SSH key to the ssh-agent    
	$ ssh-add ~/.ssh/id_rsa.pub           



	Testing SSH connection

	# Verify SSH connection; here 'git" is the user name; note that you cannot use your github user name such as 'william'
	$ ssh -T git@github.com                 

	# another alternative way to verify if firewall issues are present
	$ ssh -T -p 443 git@github.com          



	Remote URL switching and SSH push

	# List your existing remotes in order to get the name of the remote you want to change
	$ git remote -v      

	 # set remote URL
	$ git git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git       

	 # Verify new remote URL  
	$ git remote -v                                



	Changing passphrase

	# for changing password occasionally
	$ ssh-keygen -p          


Section 11: Custom Bash prompt in Git

55. An Introduction Custom Bash prompt in Git (Lab)

	If a file is already a tracked file, then we can do express commit.
	
	At the end of the course we have lecture for this. 


Section 12: Installing and Configuring default text editor for Git

56. Brief Overview of Git text editors (Lab)

	Every git installation has its default text editor. 	
	
	So if we try to commit without -m then we can see that the default text editor gets opened. 
	
	vim is a improved version of vi editor.
	
	We can configure text editors like notepad++ or sublime text. 
	
	If we want to view a git config file we can do => 
			cat .gitcofig or git config --global --edit


57. Installing and Configuring text editor(Sublime Text) for Git on Windows (Lab)

	He installed sublime.
	
	Updated Path enviornment variable by adding path to Sublime.
	
	Restarted bash.
	
	To check type - subl. This should open sublime.
	
	To configure as default text editor => 
	
	git config --global core.editor "'c:/programfiles-directory address-for-sublime' -w"
	
	Giving option -w will make sure that subl command not to exit until the file is closed. 

	Check the configuration => git config --global --list
	
	Following command worked for notepad++ =>
		
		$ git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"



60. Command Summary resource (Default text editor for Git )

	Command Summary resource (Default text editor for Git )
	Installing and Configuring text editor (Sublime Text) for Git on Windows
	# Specifying -w will cause the subl command to not exit until the file is closed
	$ git config --global core.editor "'c:/program files/sublime text 3/subl.exe' -w"



	Installing and Configuring text editor (Sublime Text) for Git on Linux
	# extract downloaded file - you can use "tar --help"...CONTD
	# to see the meaning of the options "xvzf"
	$ tar vxjf "sublime_text_3_build_3059_x32.tar.bz2"
	 
	# It is common to locate 3rd-party applications in..CONTD
	# the /opt/ directory, so move the extracted files there
	$ sudo mv sublime_text_3 /opt/
	 
	# make a Bash script which will allow us to execute..CONTD
	# Sublime Text 3 with a simple command
	$ cd /opt/sublime_text_3
	 
	# create file subl ; vim is improved vi
	$ vim subl
	 
	# add these 2 code lines to file subl
	# see below *** for command meaning
	#!/bin/sh
	exec /opt/sublime_text_3/sublime_text "$@"
	 
	# This allows anyone to read or execute the script, but only the owner can write to it.
	$ sudo chmod 755 subl
	 
	# moving to /usr/bin
	# This is the primary directory of executable commands on the system.
	$ sudo mv subl /usr/bin/
	 
	# Specifying -w will cause the subl command to not exit until the file is closed
	$ git config --global core.editor "subl -w"
	 
	# test to see whether sublime text is the default editor now
	$ git config --global --edit






	Installing and Configuring text editor (Sublime Text) for Git on Mac

	# Create the symlink
	$ ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" ~/bin/subl

	# # test to see whether sublime text is the default editor now
	$ git config --global core.editor "subl -n -w"

	** CONTD : means "continued"


Section 13: Installing and Configuring Diff and Merge tool for Git repository

61. Brief Overview of Git diff and merge tools(Lab)

	diff means difference.
	
		$ vi helloworld

		$ cat helloworld
			Hello world!
			This change was made in local.
			This is to test branching.
			This is to test ssh.
			Testing notepad++ for default editor.
			This line is for diff.

		$ git diff
			diff --git a/helloworld b/helloworld
			index 5c29a22..dc50859 100644
			--- a/helloworld
			+++ b/helloworld
			@@ -3,3 +3,4 @@ This change was made in local.
			 This is to test branching.
			 This is to test ssh.
			 Testing notepad++ for default editor.
			+This line is for diff.									//This line doesn't appear in staging area since we have not added it. So there is a difference between working directory and staging area, which is shown by this command.
			
	This can be visually illustrated using difftool command.
	
		$ git difftool
			Viewing (1/1): 'helloworld'
			Launch 'kdiff3' [Y/n]? y				//This shows the diff in the visual tool like kdiff3 or beyond compare.
		
	We have difftool configured already.
	
	Above we saw the difference between the working directory and staging area. This concept can be further extended to include differences between staging area and commit area or commit area and remote repository or working directory and commit area, etc. 
	Diff can involve more than one file.
	
	
	Check Simple merge diagram.
	

62. Installing Git Diff and Merge tool (p4merge) for Windows (Lab)
	
	We have installed p4merge.
	

63. Configuring Git Diff and Merge tool(p4merge) for Windows (Lab)

	We had kdiff3 as difftool, but we will change it and configure p4merge as merge and difftool.
	
	git config --global diff.tool p4merge => this will configure p4merge as difftool.
	
	git config --global difftool.p4merge.path "C:/Program Files/Perforce/p4merge.exe" => configure p4merge path
	
	git config --global difftool.prompt false => this command will actually prevent us from providing confirmation each time you launch the difftool from gitbash.

	git config --global merge.tool p4merge => configuring merge tool
	
	git config --global mergetool.p4merge.path "C:/Program Files/Perforce/p4merge.exe"	=> configure p4merge path
	
	git config --global mergetool.prompt false	=> prevents from confirmations.
	
		$ git config --global --list
			difftool.sourcetree.cmd='' "$LOCAL" "$REMOTE"
			mergetool.sourcetree.cmd=''
			mergetool.sourcetree.trustexitcode=true
			user.name=Aniket Rajput
			user.email=Aniket.Rajput@vanderlande.com
			filesystem.Oracle Corporation|1.8.0_231|-157191865.timestampresolution=1001 microseconds
			filesystem.Oracle Corporation|1.8.0_231|-157191865.minracythreshold=0 nanoseconds
			merge.tool=p4merge
			diff.guitool=kdiff3
			diff.tool=p4merge
			core.editor='C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin
			pull.rebase=false
			fetch.prune=false
			rebase.autostash=false
			mergetool.kdiff3.path=C:/Program Files/KDiff3/kdiff3.exe
			difftool.kdiff3.path=C:/Program Files/KDiff3/kdiff3.exe
			difftool.p4merge.path=C:/Program Files/Perforce/p4merge.exe
			difftool.prompt=false
			mergetool.p4merge.path=C:/Program Files/Perforce/p4merge.exe
			mergetool.prompt=false


Section 14: Git Comparison with Git Diff Tool (p4merge)

68. Viewing and Comparing changes - Git Working directory vs Staged (Lab)

	We will see how to use p4merge as difftool for comparision purposes.
	
	Comparision can be in multiple stages, as we know in local git repository there is a working directory, staging area and commit area. We have several artifact which are in different states, so obiviously there will be difference between them. 

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/business-venture (master)
		$ ls -l
			total 10
			-rw-r--r-- 1 inarajp 1049089 19 Apr 14 17:27 administration-doc
			-rw-r--r-- 1 inarajp 1049089 16 Apr 14 17:27 advertising-doc
			-rw-r--r-- 1 inarajp 1049089  7 Apr 14 17:27 hr-doc
			-rw-r--r-- 1 inarajp 1049089 20 Apr 14 17:28 majar-milestones
			-rw-r--r-- 1 inarajp 1049089 14 Apr 14 17:28 marketing-doc
			-rw-r--r-- 1 inarajp 1049089 24 Apr 14 17:28 product-development-doc
			-rw-r--r-- 1 inarajp 1049089 20 Apr 14 17:29 product-release-doc
			-rw-r--r-- 1 inarajp 1049089 20 Apr 14 17:29 product-testing-doc
			-rw-r--r-- 1 inarajp 1049089 14 Apr 14 17:30 purchases-doc
			-rw-r--r-- 1 inarajp 1049089 10 Apr 14 17:30 sales-doc

		$ git log --oneline
			5f7eabe (HEAD -> master) 1st commit for all docs

	To edit the file in notepad++ => notepad++ <file-name>
	
	Add a line in majar-milestones file. 
	
		$ git status
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   majar-milestones									//In red, not in staging area. Change in working directory. 

			no changes added to commit (use "git add" and/or "git commit -a")


	git diff		=> will give difference between working directory and staging area.


		$ git diff
			warning: LF will be replaced by CRLF in majar-milestones.
			The file will have its original line endings in your working directory
			diff --git a/majar-milestones b/majar-milestones
			index 0a1f2e8..6a7851b 100644
			--- a/majar-milestones
			+++ b/majar-milestones
			@@ -1,3 +1,4 @@
			 major milestone doc

			--- Formation of a public limited company - 10 June
			\ No newline at end of file
			+-- Formation of a public limited company - 10 June
			+-- Core team formed CEO, VPs, CTO - 16 July
			\ No newline at end of file

	
		$ git difftool
		warning: LF will be replaced by CRLF in majar-milestones.
		The file will have its original line endings in your working directory

		Will Open up the p4merge tool - left side is Staging Area and right side is Working Directory.
		The path of file in Staging area comes from Temp - C:\Users\inarajp\AppData\Local\Temp/z7X2vd_majar-milestones
	

69. Viewing and Comparing changes - Git Working directory vs Commit area (Lab)

	git diff HEAD	=> When we say commit area we are comparing between commit area and the last know commit(HEAD). 
	
	git difftool HEAD	=> Will open p4merge tool
	

70. Viewing and Comparing changes - Git Staging area vs Commit area (Lab)

		$ notepad++ majar-milestones

		$ git status
		On branch master
		Changes not staged for commit:
		  (use "git add <file>..." to update what will be committed)
		  (use "git restore <file>..." to discard changes in working directory)
				modified:   majar-milestones									//In red, add a line. Not staged.

		no changes added to commit (use "git add" and/or "git commit -a")

		$ git add majar-milestones
		warning: LF will be replaced by CRLF in majar-milestones.
		The file will have its original line endings in your working directory

		$ git status
		On branch master
		Changes to be committed:
		  (use "git restore --staged <file>..." to unstage)
				modified:   majar-milestones								//In green. Staged.


		$ vi majar-milestones				//add another line

		$ git status
		On branch master
		Changes to be committed:
		  (use "git restore --staged <file>..." to unstage)
				modified:   majar-milestones						//Stage, previous line

		Changes not staged for commit:
		  (use "git add <file>..." to update what will be committed)
		  (use "git restore <file>..." to discard changes in working directory)
				modified:   majar-milestones						//not staged, new line
				
				
	git diff --staged HEAD		=> --staged indicates the staging area.
	
	git difftool --staged HEAD		=> will open p4merge
	
	In above command instead of --staged we can also use --cached 

	git diff --cached HEAD

	git difftool --cached HEAD

	Even if we omit HEAD from above command it will work in same manner.
	
	git diff --cached

	git difftool --cached
	
	git diff --staged

	git difftool --staged
	

	All above commands gives same output
	

71. Viewing and Comparing changes - between Git Commits (Lab)

		$ git status
			On branch master
			nothing to commit, working tree clean

		$ git log --oneline
			c48410c (HEAD -> master) forming various departments
			15763d6 hiring and forming of the development team
			6a57ab6 core team formed
			3213ed7 Company formation done
			5f7eabe 1st commit for all docs

	We will inspect difference between HEAD and a commit prior to HEAD.
	
	git diff 15763d6 HEAD => 15763d6 is previous commit id.  
	
	git difftool 15763d6 HEAD => the left side will be of 15763d6 and right side of HEAD, just like in command.

	Alternate to above command we can also use => 	git difftool HEAD^ HEAD, where HEAD^ is HEAD -1 commit.
	
	Another alternative is => git difftool HEAD~1 HEAD => HEAD~1 also represents HEAD - 1 or commit prior to HEAD.
	
	Diff between any commits => $ git difftool 394e274 3213ed7 
	
								This command will open up p4merge and if there are multiple docs then it will firsdt show first doc, then when we exit it will automatically open second doc and so on.
			
	
	
		$ git diff 394e274 3213ed7
			diff --git a/majar-milestones b/majar-milestones
			index 36d9857..0a1f2e8 100644
			--- a/majar-milestones
			+++ b/majar-milestones
			@@ -1,8 +1,3 @@
			 major milestone doc

			--- Formation of a public limited company - 10 June
			--- Core team formed CEO, VPs, CTO - 16 July
			--- Hiring and forming development team
			--- Product development process launched
			--- Hiring and forming hr, administrative and purchase department
			--- Admin dept purchases office stationaries, purchase equipments
			+-- Formation of a public limited company - 10 June
			\ No newline at end of file
			diff --git a/marketing-doc b/marketing-doc
			index cc0e8e7..496d376 100644
			--- a/marketing-doc
			+++ b/marketing-doc
			@@ -1,2 +1 @@
			 marketing doc
			-We need to hire marketing manager
			diff --git a/sales-doc b/sales-doc
			index c76124a..b4c5a21 100644
			--- a/sales-doc
			+++ b/sales-doc
			@@ -1,3 +1 @@
			 sales doc
			-
			--- We will try to manage our salesforce under marketing manager

	
72. Viewing and Comparing changes - for a single file (Lab)	

	We will see diff but keep it restricted to a single file.
	
	If we do -> git difftool, it will show difference between working directory and staging area and if it involves more than one files, it will cycle through documents. 
	
	So if there are 100 files and I am intrested in only one particular file, then its a painful process to keep cycling through files until the required one comes. 
	For this git provides a solution, we can specify single file name we are intrested in. So even if there are multiple files merge tool will only show the specified file =>
		git difftool --(space)majar-milestones
		

73. Viewing and Comparing changes - Local vs Remote (Lab)

	We will examine difference between local and remote.
	
	There are two aspects for word remote - 
		- diff between local repository and remote repository
		- diff between master branch and another branch(such as feature branch, development branch, release, etc.)
		

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/business-venture (master)
		$ git remote -v
							//indicates that we don't have any remote repository
							
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/business-venture (master)
	
	
	git remote add origin https://github.com/aniketrajput/business-venture.git	=> This command will connect our local repository to remote repository.
	
		$ git remote add origin https://github.com/aniketrajput/business-venture.git

		$ git remote -v
			origin  https://github.com/aniketrajput/business-venture.git (fetch)
			origin  https://github.com/aniketrajput/business-venture.git (push)
	
	Now we can see that our local repository is associated with a remote repository.
	
	Now lets push all our changes to remote repository.
	
	Assignment: Create a new local repository. Add all out notes to it. With proper structure. And then create a remote repository. Map it to local and then push everything there.
	
	
		$ git push origin master
			Enumerating objects: 32, done.
			Counting objects: 100% (32/32), done.
			Delta compression using up to 8 threads
			Compressing objects: 100% (21/21), done.
			Writing objects: 100% (32/32), 2.51 KiB | 171.00 KiB/s, done.
			Total 32 (delta 11), reused 0 (delta 0), pack-reused 0
			remote: Resolving deltas: 100% (11/11), done.
			To https://github.com/aniketrajput/business-venture.git
			 * [new branch]      master -> master

	All files will be available in github now.
	
		$ vim majar-milestones

		$ cat majar-milestones
			major milestone doc

			-- Formation of a public limited company - 10 June
			-- Core team formed CEO, VPs, CTO - 16 July
			-- Hiring and forming development team
			-- Product development process launched
			-- Hiring and forming hr, administrative and purchase department
			-- Admin dept purchases office stationaries, purchase equipments
			-- Developed an MVP for demo
			-- Launching creation of Beta product

		$ git commit -am "Beta product creation launch"
			warning: LF will be replaced by CRLF in majar-milestones.
			The file will have its original line endings in your working directory
			[master a13285e] Beta product creation launch
			 1 file changed, 1 insertion(+)

		$ vim majar-milestones

		$ cat majar-milestones
			major milestone doc

			-- Formation of a public limited company - 10 June
			-- Core team formed CEO, VPs, CTO - 16 July
			-- Hiring and forming development team
			-- Product development process launched
			-- Hiring and forming hr, administrative and purchase department
			-- Admin dept purchases office stationaries, purchase equipments
			-- Developed an MVP for demo
			-- Launching creation of Beta product
			-- Beta product launched

	Now we all set to inspect our remote repository and local repository.

	
	git diff master origin/master		=> 1st master represents the master branch of local repository and origin/master represents master of remote github repository.
	
	$ git difftool master origin/master

		$ git diff master origin/master
			diff --git a/majar-milestones b/majar-milestones
			index 358f0c9..a219a71 100644
			--- a/majar-milestones
			+++ b/majar-milestones
			@@ -7,4 +7,3 @@ major milestone doc
			 -- Hiring and forming hr, administrative and purchase department
			 -- Admin dept purchases office stationaries, purchase equipments
			 -- Developed an MVP for demo
			--- Launching creation of Beta product				//Only file is being show. Actually there are two lines added. check below.
			
		$ cat majar-milestones
			major milestone doc

			-- Formation of a public limited company - 10 June
			-- Core team formed CEO, VPs, CTO - 16 July
			-- Hiring and forming development team
			-- Product development process launched
			-- Hiring and forming hr, administrative and purchase department
			-- Admin dept purchases office stationaries, purchase equipments
			-- Developed an MVP for demo
			-- Launching creation of Beta product
			-- Beta product launched

		$ git commit -am "Beta product launched"
			warning: LF will be replaced by CRLF in majar-milestones.
			The file will have its original line endings in your working directory
			[master 4d3b7e0] Beta product launched
			 1 file changed, 1 insertion(+)

		
		$ git diff master origin/master
			diff --git a/majar-milestones b/majar-milestones
			index a416469..a219a71 100644
			--- a/majar-milestones
			+++ b/majar-milestones
			@@ -7,5 +7,3 @@ major milestone doc
			 -- Hiring and forming hr, administrative and purchase department
			 -- Admin dept purchases office stationaries, purchase equipments
			 -- Developed an MVP for demo
			--- Launching creation of Beta product
			--- Beta product launched					//After commit both line are being seen now. 
		
	Now lets create one feature branch, add one line in a file and then switch back to master branch and then check the diff between this feature branch and master branch. 
	
		$ git checkout -b feature_branch
			Switched to a new branch 'feature_branch'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/business-venture (feature_branch)
		$ vim majar-milestones

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/business-venture (feature_branch)
		$ git commit -am "Releasing beta product"
			warning: LF will be replaced by CRLF in majar-milestones.
			The file will have its original line endings in your working directory
			[feature_branch d6454c8] Releasing beta product
			 1 file changed, 1 insertion(+)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/business-venture (feature_branch)
		$ git checkout master
			Switched to branch 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/business-venture (master)
		$ git diff feature_branch master
			diff --git a/majar-milestones b/majar-milestones
			index ad699ea..a416469 100644
			--- a/majar-milestones
			+++ b/majar-milestones
			@@ -9,4 +9,3 @@ major milestone doc
			 -- Developed an MVP for demo
			 -- Launching creation of Beta product
			 -- Beta product launched
			--- Release of Beta product

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/business-venture (master)
		$ git difftool feature_branch master

	
	Diff or differences can exists in artifacts between -
		- working directory and staging area
		- staging area and commit area
		- working directory and commit area
		- any two arbitrary commits
		- local and remote repositories
		- two branches (feature and develop, etc.)
		
		
Section 15: Deep Dive into few Git Commands


74. Git log command in-depth : Part 1 (Lab)

	git log --oneline --decorate => decorate options adds names of branches or tags of the commit that are shown.
	
	git log --oneline --decorate --graph => Will add a text graph on left side of commit messages.
	
	git log --oneline --decorate --graph --all => by --all option we can froce to show all commits regardless of the branch that has been checked out. 
	
	--oneline option shows commits in single line. 
	
	git log --stat => here along with ordinary git log information, git includes information as to which files were altered and the relative number of lines that were added or deleted from each of them 
	
		$ git log --stat
			commit 4d3b7e084076931a27bbf843f2c1734b3983e371 (HEAD -> master)
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Wed Apr 15 15:10:50 2020 +0530

				Beta product launched

			 majar-milestones | 1 +
			 1 file changed, 1 insertion(+)

			commit a13285e4723be000159a08147a6041ae7697bf93
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Wed Apr 15 15:04:18 2020 +0530

				Beta product creation launch

			 majar-milestones | 1 +
			 1 file changed, 1 insertion(+)

			commit 18cb1c561db27fc93492828ac24cb1255fb0b4b1 (origin/master)
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Tue Apr 14 18:30:42 2020 +0530

				building a MVP

			 majar-milestones | 1 +
			 1 file changed, 1 insertion(+)

			commit 394e274baa08e1ae2ad297a080e0f592947f06e1
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Tue Apr 14 18:29:53 2020 +0530

				added entries to marketing-doc and sales-doc

			 majar-milestones | 1 +
			 marketing-doc    | 1 +
			 sales-doc        | 2 ++
			 3 files changed, 4 insertions(+)

			commit c48410cf258899b8aa2437785a50c0d8f167a202
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Tue Apr 14 18:18:41 2020 +0530

				forming various departments

			 majar-milestones | 4 +++-
			 1 file changed, 3 insertions(+), 1 deletion(-)

			commit 15763d6f3411b0c52d4218aa3b590acc7ccd7e17
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Tue Apr 14 18:05:13 2020 +0530

				hiring and forming of the development team

			 majar-milestones | 3 ++-
			 1 file changed, 2 insertions(+), 1 deletion(-)

			commit 6a57ab6524c22a19bb0f554652f07c12a39d45fb
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Tue Apr 14 17:49:22 2020 +0530

				core team formed

			 majar-milestones | 3 ++-
			 1 file changed, 2 insertions(+), 1 deletion(-)

			commit 3213ed78010c5f651cfc6cef85631f27601893e3
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Tue Apr 14 17:40:16 2020 +0530

				Company formation done

			 majar-milestones | 2 ++
			 1 file changed, 2 insertions(+)

			commit 5f7eabe312e8dc6978462a11ac6c63f3ba198478
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Tue Apr 14 17:30:59 2020 +0530

				1st commit for all docs

			 administration-doc      | 1 +
			 advertising-doc         | 1 +
			 hr-doc                  | 1 +
			 majar-milestones        | 1 +
			 marketing-doc           | 1 +
			 product-development-doc | 1 +
			 product-release-doc     | 1 +
			 product-testing-doc     | 1 +
			 purchases-doc           | 1 +
			 sales-doc               | 1 +
			 10 files changed, 10 insertions(+)


		$ git log --stat --oneline -n 2
			4d3b7e0 (HEAD -> master) Beta product launched
			 majar-milestones | 1 +
			 1 file changed, 1 insertion(+)
			a13285e Beta product creation launch
			 majar-milestones | 1 +
			 1 file changed, 1 insertion(+)

	git log -p 	=> p stands for patch. It displays a patch representing each commit and it shows a full diff of each commit. It is a detailed view.
	
		$ git log -p -n 1
			commit 4d3b7e084076931a27bbf843f2c1734b3983e371 (HEAD -> master)
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Wed Apr 15 15:10:50 2020 +0530

				Beta product launched

			diff --git a/majar-milestones b/majar-milestones
			index 358f0c9..a416469 100644
			--- a/majar-milestones
			+++ b/majar-milestones
			@@ -8,3 +8,4 @@ major milestone doc
			 -- Admin dept purchases office stationaries, purchase equipments
			 -- Developed an MVP for demo
			 -- Launching creation of Beta product
			+-- Beta product launched

	Display a commit history but limit it to a specific directory => git log <name-of-directory>
	Will display commits related to specified directory.

	Search a commit for a specific string or a specific spring expression => git log --oneline --grep="quick-feature"
	Will search for all commit message with spring expression "quick-feature"
	
		$ git log --oneline --grep="MVP"
			18cb1c5 (origin/master) building a MVP


75. More lectures will be added in this section in future!	
	

Section 16: Git Branching and Merging techniques

	A git branch is an independent line of development.
	
	Check diagram. 
	
	We create a branch when we want to develop a new feature or do a bug fix. 
	Unstable code is never committed to the main or production code base.
	A new branch get its own working directory, index or staging area and commit history.
	Commits made in new branch are recorded in the history of new branch.
	
	
		$ ls -l
			total 31
			-rw-r--r-- 1 inarajp 1049089 1272 Apr  9 12:37 404.html
			-rw-r--r-- 1 inarajp 1049089 3959 Apr  9 12:37 apple-touch-icon.png
			-rw-r--r-- 1 inarajp 1049089  416 Apr  9 12:37 browserconfig.xml
			drwxr-xr-x 1 inarajp 1049089    0 Apr 16 10:33 css/
			-rw-r--r-- 1 inarajp 1049089  766 Apr  9 12:37 favicon.ico
			-rw-r--r-- 1 inarajp 1049089  191 Apr  9 12:37 humans.txt
			drwxr-xr-x 1 inarajp 1049089    0 Apr  9 12:37 img/
			-rw-r--r-- 1 inarajp 1049089 5115 Apr  9 12:37 index.html
			drwxr-xr-x 1 inarajp 1049089    0 Apr 16 10:33 js/
			-rw-r--r-- 1 inarajp 1049089   78 Apr  9 12:37 robots.txt
			-rw-r--r-- 1 inarajp 1049089 3482 Apr  9 12:37 tile.png
			-rw-r--r-- 1 inarajp 1049089 1854 Apr  9 12:37 tile-wide.png
		
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-branching-2 (master)
		$ git branch -a				
		//check if there is any branch, -a option means local and remote. We can see that there is no master branch. Git will not create a master branch until you commit something. And there are no other branches.
		
	No files were committed or added till now. We will commit all file now. 	

		$ git status
			On branch master

			No commits yet

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					404.html
					apple-touch-icon.png
					browserconfig.xml
					css/
					favicon.ico
					humans.txt
					index.html
					js/
					robots.txt
					tile-wide.png
					tile.png

			nothing added to commit but untracked files present (use "git add" to track)

		$ git add .
			warning: LF will be replaced by CRLF in 404.html.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in browserconfig.xml.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in css/main.css.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in css/normalize.css.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in humans.txt.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/main.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/plugins.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/vendor/jquery-1.11.2.min.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/vendor/modernizr-2.8.3-respond-1.4.2.min.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory

		$ git commit -m "1st commit for all files"
			[master (root-commit) fdebf70] 1st commit for all files
			 16 files changed, 1024 insertions(+)
			 create mode 100644 404.html
			 create mode 100644 apple-touch-icon.png
			 create mode 100644 browserconfig.xml
			 create mode 100644 css/main.css
			 create mode 100644 css/normalize.css
			 create mode 100644 css/normalize.min.css
			 create mode 100644 favicon.ico
			 create mode 100644 humans.txt
			 create mode 100644 index.html
			 create mode 100644 js/main.js
			 create mode 100644 js/plugins.js
			 create mode 100644 js/vendor/jquery-1.11.2.min.js
			 create mode 100644 js/vendor/modernizr-2.8.3-respond-1.4.2.min.js
			 create mode 100644 robots.txt
			 create mode 100644 tile-wide.png
			 create mode 100644 tile.png

	
		$ git branch -a
			* master		//Now we can see we have master branch and no other branch. 
			
		
		$ git branch small-feature

		$ git branch -a
			* master
			  small-feature
	
	How to rename a particular branch => git branch -m <old-name-of-branch> <new-name-of-branch> => -m specifies modification. 
		
		$ git branch -m small-feature quick-feature

		$ git branch -a
			* master
			  quick-feature


	If we just type => git branch, without -a option, then we will just get the local branches.
	
	To delete a particular branch => git branch -d <name-of-branch>
	
		$ git branch -d quick-feature
			Deleted branch quick-feature (was fdebf70).

		$ git branch -a
			* master

	We will recreate branch small-feature again. Modify a file humans.txt, commit it.
	
		$ git branch small-feature

		$ git branch -a
			* master
			  small-feature

		$ git checkout small-feature
			Switched to branch 'small-feature'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-branching-2 (small-feature)
		$ vim humans.txt

		$ git status
			On branch small-feature
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   humans.txt

			no changes added to commit (use "git add" and/or "git commit -a")

		$ git add .
			warning: LF will be replaced by CRLF in humans.txt.
			The file will have its original line endings in your working directory

		$ git commit -m "modified humans.txt"
			[small-feature 5a63939] modified humans.txt
			 1 file changed, 2 insertions(+)

	
	We will now switch to master branch and try to delete the small-feature branch.

		$ git checkout master
			Already on 'master'

		$ git branch -d small-feature
			error: The branch 'small-feature' is not fully merged.
			If you are sure you want to delete it, run 'git branch -D small-feature'.

	We can see we got an error. 
	The whole concept of branch is that we make a change on the branch and then once it is done, we merge it to the main branch. So now master is main branch. 
	However if we are sure we can execute => git branch -D small-feature, to force delete the branch. 

		$ git branch -D small-feature
			Deleted branch small-feature (was 5a63939).


77. Git Branching deep dive: git checkout (Lab)
	
	Branches are just pointers to commits.
	
	Check diagram.
	
	So when we create a branch all git needs to do is create a new pointer. It doesn't need to change repository to any other way. The repository history reamins unchanged, all you get is a new pointer to current commit and this pointer is called branch. 
	
	So when we are on master branch the HEAD points to that commit and when we do check out for a another branch the HEAD will point to the commit of that branch.
	
	We will see switching of HEAD as we switch branches.
	
	
	So we are on master branch. We will modify two files and commit then separately. 
	
		$ git status
			On branch master
			nothing to commit, working tree clean

		$ vim humans.txt

		$ git commit -am "good humans - humans.txt"
			[master b8536aa] good humans - humans.txt
			 1 file changed, 2 insertions(+)

		$ vim robots.txt

		$ git commit -am "robot changing life - robots.txt"
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory
			[master f801828] robot changing life - robots.txt
			 1 file changed, 2 insertions(+)

		$ git log --oneline
			f801828 (HEAD -> master) robot changing life - robots.txt
			b8536aa good humans - humans.txt
			fdebf70 1st commit for all files

	
	Now we will create a new branch. 
	
	This command will create a new branch and all switch to that branch, so a simgle command to create a branch and switch to it => $ git checkout -b new-branch-1
	Above command means we are create a new branch, relative to the master branch. So the command will work same if we add 'master' to it => $ git checkout -b new-branch-1 master, this entire command means that we are creating this new branch based on master branch. 
	
		$ git checkout -b new-branch-1 master
			Switched to a new branch 'new-branch-1'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-branching-2 (new-branch-1)
		$ git log --oneline
			f801828 (HEAD -> new-branch-1, master) robot changing life - robots.txt
			b8536aa good humans - humans.txt
			fdebf70 1st commit for all files
	
	Above we can see we have same commits for new-branch-1 from that of master branch.
	So when we create a new branch that particular branch inherits commit history from its parent branch.
	
	Now we edited the humans.txt file and then commited it and again switched to master and compared the commits.
	
		$ vim humans.txt

		$ git commit -am "humans for good society - humans.txt"
			[new-branch-1 9f4222b] humans for good society - humans.txt
			 1 file changed, 2 insertions(+)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-branching-2 (new-branch-1)
		$ git log --oneline
			9f4222b (HEAD -> new-branch-1) humans for good society - humans.txt
			f801828 (master) robot changing life - robots.txt
			b8536aa good humans - humans.txt
			fdebf70 1st commit for all files

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-branching-2 (new-branch-1)
		$ git checkout master
			Switched to branch 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-branching-2 (master)
		$ git log --oneline
			f801828 (HEAD -> master) robot changing life - robots.txt
			b8536aa good humans - humans.txt
			fdebf70 1st commit for all files


	
	Now it is not always necessary that we create a branch off the master branch. 
	We can always create a branch based on any other branch. 
	
	So now we will create a new branch based on new-branch-1. 
	
		$ git checkout -b new-branch-2 new-branch-1
			Switched to a new branch 'new-branch-2'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-branching-2 (new-branch-2)
		$ git log --oneline
			9f4222b (HEAD -> new-branch-2, new-branch-1) humans for good society - humans.txt
			f801828 (master) robot changing life - robots.txt
			b8536aa good humans - humans.txt
			fdebf70 1st commit for all files

	We can see that the commit history for new-branch-2 is exactly same as new-branch-1.
		
		$ git log --oneline --decorate --graph --all
			* 9f4222b (new-branch-2, new-branch-1) humans for good society - humans.txt
			* f801828 (HEAD -> master) robot changing life - robots.txt
			* b8536aa good humans - humans.txt
			* fdebf70 1st commit for all files

	If we switch from master to new-branch-1 the HEAD will also switch.

		$ git checkout new-branch-1
			Switched to branch 'new-branch-1'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-branching-2 (new-branch-1)
		$ git log --oneline --decorate --graph --all
			* 9f4222b (HEAD -> new-branch-1, new-branch-2) humans for good society - humans.txt
			* f801828 (master) robot changing life - robots.txt
			* b8536aa good humans - humans.txt
			* fdebf70 1st commit for all files

	
		
		
		$ git log --oneline --decorate --graph --all
			* 7945f99 (new-branch-2) more responsible humans - humans.txt
			| * 0a5dc5d (HEAD -> new-branch-1) love robots - robot.txt
			|/
			* 9f4222b humans for good society - humans.txt
			* f801828 (master) robot changing life - robots.txt
			* b8536aa good humans - humans.txt
			* fdebf70 1st commit for all files


	Command "git branch -r" => displays only remote branches. 
	
	The git checkout command lets you navigate between the branches.
	Checking out a branch updates the files in the working directory to match the version stored in that branch.
	A branch is not a container for commits.
	Branches are just pointer to commit.
	

78. Git Merge using "fast-forward" (Lab)

	There are several types of git merge.
	
	We have a demo-merge repository. We did first commit with all files.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ ls -l
			total 31
			-rw-r--r-- 1 inarajp 1049089 1272 Apr  9 12:37 404.html
			-rw-r--r-- 1 inarajp 1049089 3959 Apr  9 12:37 apple-touch-icon.png
			-rw-r--r-- 1 inarajp 1049089  416 Apr  9 12:37 browserconfig.xml
			drwxr-xr-x 1 inarajp 1049089    0 Apr 16 12:04 css/
			-rw-r--r-- 1 inarajp 1049089  766 Apr  9 12:37 favicon.ico
			-rw-r--r-- 1 inarajp 1049089  191 Apr  9 12:37 humans.txt
			drwxr-xr-x 1 inarajp 1049089    0 Apr  9 12:37 img/
			-rw-r--r-- 1 inarajp 1049089 5115 Apr  9 12:37 index.html
			drwxr-xr-x 1 inarajp 1049089    0 Apr 16 12:04 js/
			-rw-r--r-- 1 inarajp 1049089   78 Apr  9 12:37 robots.txt
			-rw-r--r-- 1 inarajp 1049089 3482 Apr  9 12:37 tile.png
			-rw-r--r-- 1 inarajp 1049089 1854 Apr  9 12:37 tile-wide.png

		$ git status
			On branch master

			No commits yet

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					404.html
					apple-touch-icon.png
					browserconfig.xml
					css/
					favicon.ico
					humans.txt
					index.html
					js/
					robots.txt
					tile-wide.png
					tile.png

			nothing added to commit but untracked files present (use "git add" to track)

		$ git add .
			warning: LF will be replaced by CRLF in 404.html.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in browserconfig.xml.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in css/main.css.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in css/normalize.css.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in humans.txt.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/main.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/plugins.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/vendor/jquery-1.11.2.min.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/vendor/modernizr-2.8.3-respond-1.4.2.min.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory

		$ git commit -m "all files"
			[master (root-commit) e79127e] all files
			 16 files changed, 1022 insertions(+)
			 create mode 100644 404.html
			 create mode 100644 apple-touch-icon.png
			 create mode 100644 browserconfig.xml
			 create mode 100644 css/main.css
			 create mode 100644 css/normalize.css
			 create mode 100644 css/normalize.min.css
			 create mode 100644 favicon.ico
			 create mode 100644 humans.txt
			 create mode 100644 index.html
			 create mode 100644 js/main.js
			 create mode 100644 js/plugins.js
			 create mode 100644 js/vendor/jquery-1.11.2.min.js
			 create mode 100644 js/vendor/modernizr-2.8.3-respond-1.4.2.min.js
			 create mode 100644 robots.txt
			 create mode 100644 tile-wide.png
			 create mode 100644 tile.png

		$ git branch -a
			* master

	
	We will create a new branch and commit a file on it.
	
		$ git branch -a
			* master

		$ git checkout -b ff-branch master
			Switched to a new branch 'ff-branch'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (ff-branch)
		$ vim humans.txt

		$ git commit -am "humans responsiblity - ff-branch - humans.txt"
			warning: LF will be replaced by CRLF in humans.txt.
			The file will have its original line endings in your working directory
			[ff-branch b0281f5] humans responsiblity - ff-branch - humans.txt
			 1 file changed, 2 insertions(+)


		$ git log --oneline
			b0281f5 (HEAD -> ff-branch) humans responsiblity - ff-branch - humans.txt
			e79127e (master) all files

	Now we will switch to master branch again. It is good practice to do diff before merging with target branch. 
	Here target branch is master and we will merge or integrate ff-branch with master branch.
	
		$ git checkout master
			Already on 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ git diff master ff-branch
			diff --git a/humans.txt b/humans.txt
			index 5b037cf..f31189a 100644
			--- a/humans.txt
			+++ b/humans.txt
			@@ -13,3 +13,5 @@

				 HTML5, CSS3
				 jQuery, Modernizr
			+
			+#Humans have both indivual and collective responsibility.


	git merge <name-of-branch-we-want-to-merge-in-master-branch> 
	
	
		$ git merge ff-branch
			Updating e79127e..b0281f5
			Fast-forward
			 humans.txt | 2 ++
			 1 file changed, 2 insertions(+)

		
		$ git log --oneline --decorate --graph --all
			* b0281f5 (HEAD -> master, ff-branch) humans responsiblity - ff-branch - humans.txt			//we can see HEAD pointing to both branches. 
			* e79127e all files

	Remember Fast Forward merge can only happen if there are no changes in the target branch before we do the merge. 
	master is the target branch in our case now and we didn't do any changes in master branch. We switched to ff-branch, did commit on it and switched back to master for commit.
	
		$ git branch
		  ff-branch
		* master
		
		$ git branch -d ff-branch
			Deleted branch ff-branch (was b0281f5).

		$ git branch
			* master

		$ git log --oneline --decorate --graph --all
			* b0281f5 (HEAD -> master) humans responsiblity - ff-branch - humans.txt		//as we deleted the ff-branch, now we have only master branch
			* e79127e all files

	So the fact that we branched of from the master was not preserved by the git.
	
	
	Check the diagram of what we did till now. Check the animation. 
	
	Before fast forward merge => 	
	
							Feature (ff-branch)
							 |
				  - - B1 -- B2	
				 |	
	C0 -- C1 -- C2 
				 |
				Master 


	After fast forward merge => 
	
							Feature (ff-branch)
							 |	
	C0 -- C1 -- C2 -- B1 -- B2 
							 |
							Master 

	
	And when we delete the ff-branch then the pointer of Feature (ff-branch) is delete and there is no trace of branching => 

	
	C0 -- C1 -- C2 -- B1 -- B2 
							 |
							Master 



79. Git Merge using "NO fast-forward" (Lab)

	In this type of merge we will disable fast forward merge capability.
	
	In the process we will be able to preserve the fact that we have branched off. 
	
	$ git branch
		* master	//Now we have only master branch.
		
	We will create a new branch no-ff-branch and we will modify two files robot.txt and humans.txt and commit them separately.
	
		$ git checkout -b no-ff-branch
			Switched to a new branch 'no-ff-branch'

		$ vim robots.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (no-ff-branch)
		$ git commit -am "robot serves humans - no-ff-branch- robot.txt"
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory
			[no-ff-branch 97a22c5] robot serves humans - no-ff-branch- robot.txt
			 1 file changed, 1 insertion(+)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (no-ff-branch)
		$ vim humans.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (no-ff-branch)
		$ git commit -am "human as social being - no-ff-branch- humans.txt"
			[no-ff-branch 2553ab2] human as social being - no-ff-branch- humans.txt
			 1 file changed, 1 insertion(+)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (no-ff-branch)
		$ git log --oneline --decorate --graph
			* 2553ab2 (HEAD -> no-ff-branch) human as social being - no-ff-branch- humans.txt
			* 97a22c5 robot serves humans - no-ff-branch- robot.txt
			* b0281f5 (master) humans responsiblity - ff-branch - humans.txt
			* e79127e all files



	Switch to master and check diff between master and source branch(no-ff-branch)

		$ git checkout master
			Switched to branch 'master'

		$ git difftool master no-ff-branch

	We will not go ahead with merge. 
	
		$ git merge no-ff-branch --no-ff		//This will result in a merge commit and it will open up a default editor. Option --no-ff means disable fast forward merge.
			Merge made by the 'recursive' strategy.
			 humans.txt | 1 +
			 robots.txt | 1 +
			 2 files changed, 2 insertions(+)


	

		$ git log --oneline --decorate --graph
			*   f573ff2 (HEAD -> master) Merge branch 'no-ff-branch'					//This is a merge commit, which gets added in no-ff
			|\
			| * 2553ab2 (no-ff-branch) human as social being - no-ff-branch- humans.txt
			| * 97a22c5 robot serves humans - no-ff-branch- robot.txt
			|/
			* b0281f5 humans responsiblity - ff-branch - humans.txt
			* e79127e all files

	We can clearly see that a new merge commit is created and we can also see the branching. 
	In Jira also a separate commit is created for a merge.
	
	And now we are done with merge of no-ff-branch, we will simply delete this branch.
	
		$ git branch -d no-ff-branch
			Deleted branch no-ff-branch (was 2553ab2).

		$ git branch
		* master

		$ git log --oneline --decorate --graph
			*   f573ff2 (HEAD -> master) Merge branch 'no-ff-branch'
			|\
			| * 2553ab2 human as social being - no-ff-branch- humans.txt		//here we can see that the reference to no-ff-branch is removed after its deletion.
			| * 97a22c5 robot serves humans - no-ff-branch- robot.txt
			|/
			* b0281f5 humans responsiblity - ff-branch - humans.txt
			* e79127e all files


	The reference to branch no-ff-branch was removed after its deletion but the fact that we branched of is clearly seen and preserved. 
	
	Before merge Fast Forward Merge disabled (--no-ff) =>

		
							Feature (no-ff-branch)
							 |
				  - - B1 -- B2	
				 |	
	C0 -- C1 -- C2 
				 |
				Master 


	After merge => 
	
					Feature (no-ff-branch)
							 |
				  - - B1 -- B2	----
				 |					\
	C0 -- C1 -- C2 -- -- -- -- -- -- MC(Merge Commit) 
									  |
									Master

	
	And when we delete the no-ff-branch then the pointer of Feature (no-ff-branch) is delete But there is still a trace of branching => 

	
				  - - B1 -- B2	----
				 |					\
	C0 -- C1 -- C2 -- -- -- -- -- -- MC(Merge Commit) 
									  |
									Master

	MC is the HEAD now.
	

80. Git 3-way merge (Lab)

	Git 3-way merge is also sometimes called an automatic merge.

	Once we have finished working on an isolated branch, it is important to get it back to the main code base. 
	Depending upon the structure of our repository git has several algorithms to acompolish this.
	
	In Fast Forward merge it is possible to merge feature branch into master branch only if there is no prior work being done on the master branch prior to the merge. (But master branch may have been changed, other developers may have updated it by merging there own code)
	
	
	3-way merge, Before Merge =>	

		
							Feature
							 |
				  - - B1 -- B2	
				 |	
	C0 -- C1 -- C2 -- C3 -- C4 -- C5
								  |
								Master 
	
		(you can see here Master branch has kept being updated, before Feature branch merge. So Fast-forward not possible.)

	We can see there is no linear path for feature branch, there is a divert. In this case git has no choice but to combine them via 3-way merge.

	A 3-way merge uses a dedicated commit to tie together two histories. And this is known as the merge commit.

	
							Feature
							 |
				  - - B1 -- B2 --			Master	
				 |				  \			  |	
	C0 -- C1 -- C2 -- C3 -- C4 -- C5 -- -- -- MC (Merge Commit)
	

	
	Git uses 3 commits to generate the merge commit i.e commit at C2, B2 and C5.
	
	Many developers like to Fast-forward merges for small-features or bux fixes, while reserving 3-way merges for integration of longer running features.
	
	We will create a new branch 3wm-branch, edit index.html and commit it.
	
		$ git status
			On branch master
			nothing to commit, working tree clean

		$ git branch
		* master

		$ git checkout -b 3wm-branch
			Switched to a new branch '3wm-branch'

		$ ls -l
			total 31
			-rw-r--r-- 1 inarajp 1049089 1272 Apr  9 12:37 404.html
			-rw-r--r-- 1 inarajp 1049089 3959 Apr  9 12:37 apple-touch-icon.png
			-rw-r--r-- 1 inarajp 1049089  416 Apr  9 12:37 browserconfig.xml
			drwxr-xr-x 1 inarajp 1049089    0 Apr 16 12:04 css/
			-rw-r--r-- 1 inarajp 1049089  766 Apr  9 12:37 favicon.ico
			-rw-r--r-- 1 inarajp 1049089  294 Apr 16 13:22 humans.txt
			drwxr-xr-x 1 inarajp 1049089    0 Apr  9 12:37 img/
			-rw-r--r-- 1 inarajp 1049089 5115 Apr  9 12:37 index.html
			drwxr-xr-x 1 inarajp 1049089    0 Apr 16 12:04 js/
			-rw-r--r-- 1 inarajp 1049089  128 Apr 16 13:09 robots.txt
			-rw-r--r-- 1 inarajp 1049089 3482 Apr  9 12:37 tile.png
			-rw-r--r-- 1 inarajp 1049089 1854 Apr  9 12:37 tile-wide.png

		$ vim index.html

		$ git add .
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory

		$ git commit -m "modified index.html - 3wm-branch"
			[3wm-branch ee1f81e] modified index.html - 3wm-branch
			 1 file changed, 1 insertion(+), 1 deletion(-)


	Now we will switch back to master and we will edit another file so master should already progress in terms of commits and there is no linear path.

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (3wm-branch)
		$ git checkout master
			Switched to branch 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
			$ vim robots.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ git commit -am "robot are nice - master branch"
			[master e20d3d7] robot are nice - master branch
			 1 file changed, 1 insertion(+)

		
		$ git log --oneline --decorate --graph --all
			* e20d3d7 (HEAD -> master) robot are nice - master branch
			| * ee1f81e (3wm-branch) modified index.html - 3wm-branch
			|/
			*   f573ff2 Merge branch 'no-ff-branch'
			|\
			| * 2553ab2 human as social being - no-ff-branch- humans.txt
			| * 97a22c5 robot serves humans - no-ff-branch- robot.txt
			|/
			* b0281f5 humans responsiblity - ff-branch - humans.txt
			* e79127e all files


	We can see commits on 3wm-branch and also on master done now.
	
	Now we will merge. 
	
		$ git merge 3wm-branch -m "our first 3-way merge"
			Merge made by the 'recursive' strategy.			//reserving strategy indicates git algorithm it uses internally. 
			 index.html | 2 +-
			 1 file changed, 1 insertion(+), 1 deletion(-)
		
		$ git log --oneline --decorate --graph --all
			*   42f4191 (HEAD -> master) our first 3-way merge						//Merge Commit
			|\
			| * ee1f81e (3wm-branch) modified index.html - 3wm-branch
			* | e20d3d7 robot are nice - master branch
			|/
			*   f573ff2 Merge branch 'no-ff-branch'
			|\
			| * 2553ab2 human as social being - no-ff-branch- humans.txt
			| * 97a22c5 robot serves humans - no-ff-branch- robot.txt
			|/
			* b0281f5 humans responsiblity - ff-branch - humans.txt
			* e79127e all files

	Now we will delete the branch 3wm-branch. 
	
			$ git branch -D 3wm-branch
				Deleted branch 3wm-branch (was ee1f81e).


			$ git log --oneline --decorate --graph --all
			*   42f4191 (HEAD -> master) our first 3-way merge
			|\
			| * ee1f81e modified index.html - 3wm-branch			//3wm-branch reference is gone. 
			* | e20d3d7 robot are nice - master branch
			|/
			*   f573ff2 Merge branch 'no-ff-branch'
			|\
			| * 2553ab2 human as social being - no-ff-branch- humans.txt
			| * 97a22c5 robot serves humans - no-ff-branch- robot.txt
			|/
			* b0281f5 humans responsiblity - ff-branch - humans.txt
			* e79127e all files


	We can confirm the merge is done by checking the file we edited in the feature branch.
	
	When we delete a branch after it's merger, the fact that we have done a fast-forward merge is not preserved in the commit history

	Command "git merge <source-branch>" always does a fast-forward merge  =>  FALSE, we used same for 3-way merge also. 
	
	The 3-way merge name comes from the fact that Git uses three commits to generate the merge commit - the two branch tips and their common ancestor.
	
	
81. Resolving Git Merge Conflicts - Part 1(Lab)

	Merge conflict will occur, if the two branches we are trying to merge, both change the same part of the same file, git won't be able to figure out which version to use. 
	When such situation occurs, it stops right before he merge commit so that you can resolve the conflicts manually.
	
	Note that merge conflict will only occur in event of 3-way merge. 
	Its not possible to have conflicting changes in a Fast-forward merge. 
	
	So to demostrate the merge conflict, we will create a new branch called long-feature and then we will switch to long-feature branch and we will edit 404.html file at 3 place. 
	Then we will switch back to the master branch and we will again edit 404.html file at the exact those 3 places we did in long-feature branch, so that merge conflict occurs. 
	
		$ git status
			On branch master
			nothing to commit, working tree clean

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ git branch
			* master

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ git checkout -b long-feature
			Switched to a new branch 'long-feature'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (long-feature)
		$ git branch
			* long-feature
			  master

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (long-feature)
		$ vim 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (long-feature)
		$ git commit -am "modified 404.html in 3 line - long-feature branch"
			warning: LF will be replaced by CRLF in 404.html.
			The file will have its original line endings in your working directory
			[long-feature d96da95] modified 404.html in 3 line - long-feature branch
			 1 file changed, 3 insertions(+), 3 deletions(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (long-feature)
		$ git checkout master
			Switched to branch 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ notepad++ 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ git status
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   404.html

			no changes added to commit (use "git add" and/or "git commit -a")

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ git commit -am "modified 404.html in 3 line - master branch"
			[master 3637bbd] modified 404.html in 3 line - master branch
			 1 file changed, 3 insertions(+), 3 deletions(-)


		$ git log --oneline --decorate --graph --all
			* 3637bbd (HEAD -> master) modified 404.html in 3 line - master branch
			| * d96da95 (long-feature) modified 404.html in 3 line - long-feature branch
			|/
			*   42f4191 our first 3-way merge
			|\
			| * ee1f81e modified index.html - 3wm-branch
			* | e20d3d7 robot are nice - master branch
			|/
			*   f573ff2 Merge branch 'no-ff-branch'
			|\
			| * 2553ab2 human as social being - no-ff-branch- humans.txt
			| * 97a22c5 robot serves humans - no-ff-branch- robot.txt
			|/
			* b0281f5 humans responsiblity - ff-branch - humans.txt
			* e79127e all files

	Observe that the master branch has already divert. So we need to do 3-way merge.
	
		$ git difftool master long-feature

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ git merge long-feature
		Auto-merging 404.html
		CONFLICT (content): Merge conflict in 404.html
		Automatic merge failed; fix conflicts and then commit the result.

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master|MERGING)
		$ notepad++ 404.html

	
	Now if we open the conflict file we can find something like - 
	
		<<<<<<< HEAD
			<title>Oops - Page is gone</title>
		=======
			<title>404 Page</title>
		>>>>>>> long-feature

	It clear that its saying changes in HEAD are - <title>Oops - Page is gone</title> And changes in long-feature are - <title>404 Page</title>

	Now if the number of conflicting files is not too many then we can probabily resolve manually. However if conflicting files	are more we can use visual tool like p4merge.
	
	To open merge tool - git mergetool
	
	In p4merge window we can see that the middle window is the BASE or the origin page(what was the content before any branches made the change), left side window is Remote or version of page in long-feature branch and right side is Local or the master branch.
	To resolve conflict we just need to press buttons in lower window right side, depending upon which changes we want to keep.
	Once conflict is resolved save the file and exit.
	Now we need to do commit.
	
		$ git mergetool
			Merging:
			404.html

			Normal merge conflict for '404.html':
			  {local}: modified file
			  {remote}: modified file
		
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master|MERGING)
		$ git commit -am "resolved 3-way merge conflict"
			[master 1bb06ba] resolved 3-way merge conflict
		
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-merge (master)
		$ git status
			On branch master
			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					404.html.orig

			nothing added to commit but untracked files present (use "git add" to track)

	Now even though the conflict is resolved we can see that there is one untracked file called 404.html.orig.
	This file is genereted by git as a backup file. 
	So git keeps the backup of the merge conflict so that if something get lost, we can just revert the changes. 
	However there is a way to stop generation of such files.
	
	
		$ git log --oneline --decorate --graph --all
		*   1bb06ba (HEAD -> master) resolved 3-way merge conflict
		|\
		| * d96da95 (long-feature) modified 404.html in 3 line - long-feature branch
		* | 3637bbd modified 404.html in 3 line - master branch
		|/
		*   42f4191 our first 3-way merge
		|\
		| * ee1f81e modified index.html - 3wm-branch
		* | e20d3d7 robot are nice - master branch
		|/
		*   f573ff2 Merge branch 'no-ff-branch'
		|\
		| * 2553ab2 human as social being - no-ff-branch- humans.txt
		| * 97a22c5 robot serves humans - no-ff-branch- robot.txt
		|/
		* b0281f5 humans responsiblity - ff-branch - humans.txt
		* e79127e all files

	We can also open the file and check.
	

82. Resolving Git Merge Conflicts - Part 2(Lab)
	
	We have seen that after performing a merge conflict resolution, the original file with conflict markers are saved by git in a file with .orig extension.

		$ git status
			On branch master
			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					404.html.orig

			nothing added to commit but untracked files present (use "git add" to track)

	There are two way in which we can deal with such files. If we allow the file to generate but you don't want to track it. Then we need to add files with .orig extension in .gitignore file. 
	And if we don't want such files to be generated at all then we need to configure the .gitconfig file.
	
	We will first see how we can ignore all files with .orig extension =>
		
		
		$ notepad++ .gitignore

		$ cat .gitignore
			*.orig
		
		$ git status
			On branch master
			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					.gitignore

			nothing added to commit but untracked files present (use "git add" to track)

	We can see the file .orig has been ignored. 
	
		$ git add .gitignore

		$ git commit -m "creating .gitignore file to ignore temporary files generated during merge process"
			[master 35ceaf1] creating .gitignore file to ignore temporary files generated during merge process
			 1 file changed, 1 insertion(+)
			create mode 100644 .gitignore

		$ git status
			On branch master
			nothing to commit, working tree clean

	Now we will configure a .gitconfig file. 
	We will add a particular git configuration for that purpose => git config --global mergetool.keepBackup false
	So by default mergetool.keepBackup has value to true and hence it allows generation of temparory files during conflicts.
	
		$ git config --global mergetool.keepBackup false

		$ git config --global --list
			difftool.sourcetree.cmd='' "$LOCAL" "$REMOTE"
			mergetool.sourcetree.cmd=''
			mergetool.sourcetree.trustexitcode=true
			user.name=Aniket Rajput
			user.email=Aniket.Rajput@vanderlande.com
			filesystem.Oracle Corporation|1.8.0_231|-157191865.timestampresolution=1001 microseconds
			filesystem.Oracle Corporation|1.8.0_231|-157191865.minracythreshold=0 nanoseconds
			merge.tool=p4merge
			diff.guitool=kdiff3
			diff.tool=p4merge
			core.editor='C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin
			pull.rebase=false
			fetch.prune=false
			rebase.autostash=false
			mergetool.kdiff3.path=C:/Program Files/KDiff3/kdiff3.exe
			difftool.kdiff3.path=C:/Program Files/KDiff3/kdiff3.exe
			difftool.p4merge.path=C:/Program Files/Perforce/p4merge.exe
			difftool.prompt=false
			mergetool.p4merge.path=C:/Program Files/Perforce/p4merge.exe
			mergetool.prompt=false
			mergetool.keepbackup=false

	Henceforth git will not keep .orig files.
	
	
	A .gitignore file need to committed just like any other repository file
	
	A .gitignore file is created for the following purpose ignoring any files that need not be considered while adding to index or commiting the file. 


83. Introduction to Git Cherry Pick

	Defining "cherry-pick" => Cherry picking is the act of picking a commit from a branch and applying it to current working HEAD of another branch. 
	
	Use Cherry Pick judiciously.
	
	Cherry pick is not a best practice always. 
	git cherry-pick is a great utility tool but it should be judiciously used. 
	Cherry picking can cause duplicate commits. 
	In certain scenarios both cherry picking and traditional merges would work but then traditional merges are preferred over cherry pick.
	Having said that we will soon discuss few scenarios where cherry pick might be worth considering.
	
	Feature branch A 		    -- 7 -- 8 -- CP -- 9	
	by developer-1 	 		  /
							 /
	master			   1 -- 2 -- 3 -- 4 -- 5 -- 6
								  \
								   \ 
	Feature branch B 				 -- 10 -- 11 -- 
	by developer-2


	Now developer-2 wants to cherry-pick the commit from developer-1 branch (CP) after his commit-11 so that he can proceed.
	
	So after cherry-pick - 
	
	Feature branch A 		    -- 7 -- 8 -- CP -- 9	
	by developer-1 	 		  /
							 /
	master			   1 -- 2 -- 3 -- 4 -- 5 -- 6
								  \
								   \ 
	Feature branch B 				 -- 10 -- 11 -- CP12
	by developer-2
	

	The particular commit on the feature branch A will continue to exist as a duplicate commit.
	
	The commit sha(commit-id) of CP will be completely different from the commit sha of the CP12.
	
	git log --oneline | head -n 5 => displays top 5 or current 5 commits in the master branch.
	
	
	Command to cherry-pick => git cherry-pick <commit-sha-of-commit-we-want-to-cherry-pick>
	
	
	Few Scenarios where cherry-pick works well - 
	
		Team Collaboration - Cherry picking commits from another developer's work to patch in a code. 
		
		Undoing changes and restoration of stale commits - Cherry picking lost commits and infusing life into stale branches
		
		Bug fixes - Cherry picking bug fixes to prove quick fixes.
	
	
84. Git Cherry pick - a comprehensive walkthrough (Lab)

javac -d build src/sample/java/project/HelloWorld.java		//-d build	=> By -d option we are telling that the compiled .class files should go in build folder.
	
java -classpath build src/sample/java/project/HelloWorld.java  //-classpath points to the fact that the build folder is holding the .class files which will beused to run the program


	git fetch origin feature_branch-2 => will pull the changes from feature_branch-2.
	
	
	git log --oneline origin/feature_branch-2 | head -n 5		//It will fetch the most recent commit history for the remote origin feature_branch-2. This means we don't have to switch to feature_branch-2 to get its commit history. We can do it this way.


	git log --oneline | head -n 5	//most recent form current branch.
	
	
	He used two accounts. Same repository.
	Developer 1 needs changes from developer-2.
	developer-1 has its own brancha and developer-2 has its own.
	developer-2 makes his changes and commit and push it to his own branch.
	developer-1 then fetch from the developer-2 branch	- didn't understand why he did this?
	then developer-1 did cherry-pick of the commit he needed.
	

Section 17: Commit History rewriting in Git

85. Amending Git Commits (Lab)

	We will talk about how to ammend/change commits. 
	
	Git main job is to make sure you never lose a commited change, but git is also designed to give you total control over development workflow. 
	This includes letting you define exactly what your project history looks like.
	Now this also creates a potential to loose commits.
	Git provides its history rewriting commands under the disclaimer that using them may result in lose of content. 
	
		$ ls
			404.html  apple-touch-icon.png  browserconfig.xml  css/  favicon.ico  humans.txt  img/  index.html  js/  robots.txt  tile.png  tile-wide.png

		$ git log --oneline
			0630b69 (HEAD -> master) first commit for all files

		$ vim index.html

		$ git commit -am "master: modified title in index.html"
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			[master 7badc57] master: modified title in index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git log --oneline
			7badc57 (HEAD -> master) master: modified title in index.html
			0630b69 first commit for all files


	Now suppose I want to modify 404.htmlm file, But I want to make it look like this modification was done in 7badc57 commit i.e. no new commit should be seen. It should look like index.html and 404.html both were modified in 7badc57.
	So we will modify the commit 7badc57.
	
	--no-edit option will allow you to amend your commit without changing its commit message. 
	
		
		$ vim 404.html

		$ git add 404.html
			warning: LF will be replaced by CRLF in 404.html.
			The file will have its original line endings in your working directory

		$ git commit --amend --no-edit
			[master 04da1f9] master: modified title in index.html
			 Date: Mon Apr 20 16:34:17 2020 +0530
			 2 files changed, 2 insertions(+), 2 deletions(-)

		$ git log --oneline
			04da1f9 (HEAD -> master) master: modified title in index.html				//we can see that the commit-id has changed.
			0630b69 first commit for all files


	We can see not new third commit was add but the commit id of exiting one is changed. We can say it a brand new commit.
	
	Commit message was not modified, we will see how we can modify that -
	
		$ git log --oneline
			04da1f9 (HEAD -> master) master: modified title in index.html
			0630b69 first commit for all files

		$ vim browserconfig.xml

		$ git add browserconfig.xml
			warning: LF will be replaced by CRLF in browserconfig.xml.
			The file will have its original line endings in your working directory

		$ git commit --amend				//will open up the default editor, where we can add a message
			[master e990975] master: modified title in index.html, 404.html and browserconfig.xml
			 Date: Mon Apr 20 16:34:17 2020 +0530
			 3 files changed, 3 insertions(+), 3 deletions(-)

		$ git log --oneline
			e990975 (HEAD -> master) master: modified title in index.html, 404.html and browserconfig.xml
			0630b69 first commit for all files

	We can see that both commit-id and message has been modified.
	This means we again have a new commit, replacing the earlier one.
	
	So git commit with --amend is a convinent way to fix up the most recent commit. 
	It lets us combine staged changes with the previous commit, instead of commiting it as a entirely new snapshot. 
	It combines the staged changes with the previous commit and replace the previous commit with resulting snapshot. 
	But ammending doesn't just alter the commit, it replaces it entirely. 
	
	Never ammend commits that has been pushed to your public repository. If we amend a commit that other developer has based there work on, it will look like the base of there project vanished from the work history.
	

86. Git rebase Introduction (Lab)

	Rebasing is a process of moving a branch to a new base commit. 
	
	Before Rebasing =>
	
							 Feature
								|
					 --- b1 -- b2
					/
	-- c0 -- c1 -- c2 -- c3 -- c4 
								|
							 Master	

	After Rebasing =>

											 Feature
												|
									  --- k1 -- k2
									/
	-- c0 -- c1 -- c2 -- c3 -- c4 --  
								|
							 Master	


	So the base has changed from c2 to c4

	From the content perspective rebasing is just moving a branch from one commit to another but internally git accomplishes this by creating new commits and applying then to a specified base. 
	So its literally rewiting your project history.
	
	Even though branch looks same, it is composed of entirely new commits. 
	
	git rebase <BASE>
	
	<BASE> can be any type of commit reference - id, a branch name, a tag, or a relative reference to HEAD. 
	
	git rebase master
	
	Once we do a rebase we have a linear path.
	

87. Git rebase implementation setup (Lab)

		$ mkdir demo-rebase

		$ git init
			Initialized empty Git repository in C:/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/.git/

		$ cd demo-rebase/

		$ ls
			404.html  apple-touch-icon.png  browserconfig.xml  css/  favicon.ico  humans.txt  img/  index.html  js/  robots.txt  tile.png  tile-wide.png

		$ git add .
			warning: LF will be replaced by CRLF in demo-rebase/404.html.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in demo-rebase/browserconfig.xml.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in demo-rebase/css/main.css.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in demo-rebase/css/normalize.css.
			The file will have its original line endings in your working directory
			The file will have its original line endings in your working directory

		$ git commit -m "commiting all files"
		[master (root-commit) d7ba2ee] commiting all files
		 16 files changed, 1022 insertions(+)
		 create mode 100644 demo-rebase/404.html
		 create mode 100644 demo-rebase/apple-touch-icon.png
		 create mode 100644 demo-rebase/browserconfig.xml
		 create mode 100644 demo-rebase/css/main.css
		 create mode 100644 demo-rebase/css/normalize.css

		$ git log --oneline
			d7ba2ee (HEAD -> master) commiting all files

	
	So we will make two commits on master branch for same file humans.txt.
	Then we will create a new branch top-feature. We will again make two commits on index.html.
	We will again switch to master branch and then again add two commits for file 404.html 
	
	
		$ vim humans.txt

		$ git commit -am "master: added name - humans.txt"
			warning: LF will be replaced by CRLF in demo-rebase/humans.txt.
			The file will have its original line endings in your working directory
			[master a3e7455] master: added name - humans.txt
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ vim humans.txt

		$ git commit -am "master: added team info - humans.txt"

		$ git checkout -b top-feature
			Switched to a new branch 'top-feature'

		$ vim index.html

		$ git commit -am "top-feature: modified title - index.html"
			warning: LF will be replaced by CRLF in demo-rebase/index.html.
			The file will have its original line endings in your working directory
			[top-feature 663ffe6] top-feature: modified title - index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ vim index.html

		$ git commit -am "top-feature: browser upgrade recommendation - index.html"
			warning: LF will be replaced by CRLF in demo-rebase/index.html.
			The file will have its original line endings in your working directory
			[top-feature e9d11d7] top-feature: browser upgrade recommendation - index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git checkout master
			Switched to branch 'master'
		
		$ vim 404.html

		$ git commit -am "master: modified title - 404.html"
			warning: LF will be replaced by CRLF in demo-rebase/404.html.
			The file will have its original line endings in your working directory
			[master c68eb9b] master: modified title - 404.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ vim 404.html

		$ git commit -am "master: changed font family - 404.html"
			warning: LF will be replaced by CRLF in demo-rebase/404.html.
			The file will have its original line endings in your working directory
			[master 8b831eb] master: changed font family - 404.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

	
		$ git log --oneline --decorate --graph --all
			* 8b831eb (HEAD -> master) master: changed font family - 404.html
			* c68eb9b master: modified title - 404.html
			| * e9d11d7 (top-feature) top-feature: browser upgrade recommendation - index.html
			| * 663ffe6 top-feature: modified title - index.html
			|/
			* d0c9998 master: added team info - humans.txt
			* a3e7455 master: added name - humans.txt
			* d7ba2ee commiting all files


88. Git rebase implementation (Lab)

	Here we will use previously set up things.
	
		$ git log --oneline --decorate --graph --all
			* 8b831eb (HEAD -> master) master: changed font family - 404.html
			* c68eb9b master: modified title - 404.html
			| * e9d11d7 (top-feature) top-feature: browser upgrade recommendation - index.html
			| * 663ffe6 top-feature: modified title - index.html
			|/
			* d0c9998 master: added team info - humans.txt
			* a3e7455 master: added name - humans.txt
			* d7ba2ee commiting all files

	Now we can exactly compare our above commit history with the below diagram =>

		
							 Feature
								|
					 --- b1 -- b2
					/
	-- c0 -- c1 -- c2 -- c3 -- c4 
								|
							 Master	


	Now we will actually do the git rebase.
	Before that we need to switch to top-feature branch.
			
		$ git checkout top-feature
			Switched to branch 'top-feature'

		$ git rebase master
			Successfully rebased and updated refs/heads/top-feature.

		$ git log --oneline --decorate --graph --all
			* 1b76bf5 (HEAD -> top-feature) top-feature: browser upgrade recommendation - index.html
			* 87b1a6b top-feature: modified title - index.html
			* 8b831eb (master) master: changed font family - 404.html
			* c68eb9b master: modified title - 404.html
			* d0c9998 master: added team info - humans.txt
			* a3e7455 master: added name - humans.txt
			* d7ba2ee commiting all files

	We can see that a linear commits are formed after rebase. Compare the above commit history with below diagram => 
	
	We can see that in top-feature branch there are two new commits(new commit-id)
		
												 Feature
												|
									  --- k1 -- k2
									/
	-- c0 -- c1 -- c2 -- c3 -- c4 --  
								|
							 Master	


	Now that the rebasing is done, we are ready for a fast forward merge so that we have a completely flat and linear commit history. 
	
	So after Fast-forward the master and top-feature will both point to k2 and later we will delete top-feature branch. 


										Feature
											|
	-- c0 -- c1 -- c2 -- c3 -- c4 -- k1 -- k2  
											|
										Master	

	



		$ git checkout master
			Switched to branch 'master'

		$ git merge top-feature
			Updating 8b831eb..1b76bf5
			Fast-forward
			 demo-rebase/index.html | 4 ++--
			 1 file changed, 2 insertions(+), 2 deletions(-)

		$ git log --oneline --decorate --graph --all
			* 1b76bf5 (HEAD -> master, top-feature) top-feature: browser upgrade recommendation - index.html
			* 87b1a6b top-feature: modified title - index.html
			* 8b831eb master: changed font family - 404.html
			* c68eb9b master: modified title - 404.html
			* d0c9998 master: added team info - humans.txt
			* a3e7455 master: added name - humans.txt
			* d7ba2ee commiting all files


	Now after fast-forward we can see master and top-feature both points to HEAD.
	
	We will now delete top-feature branch.
	
		$ git branch -d top-feature
			Deleted branch top-feature (was 1b76bf5).

		$ git log --oneline --decorate --graph --all
			* 1b76bf5 (HEAD -> master) top-feature: browser upgrade recommendation - index.html
			* 87b1a6b top-feature: modified title - index.html
			* 8b831eb master: changed font family - 404.html
			* c68eb9b master: modified title - 404.html
			* d0c9998 master: added team info - humans.txt
			* a3e7455 master: added name - humans.txt
			* d7ba2ee commiting all files


89. Resolving Git rebase conflict (Lab)

	So we will now add one commit in master - humans.txt
	Then we will create a new branch rebase-conflict-branch and edit index.html in 3 place.
	We will then switch to master branch and modify index.html at same 3 place so that there will be a conflict.
	
		$ vim humans.txt

		$ git commit -am "master: prior to rebase conflict - humans.txt"
			warning: LF will be replaced by CRLF in demo-rebase/humans.txt.
			The file will have its original line endings in your working directory
			[master 17984e2] master: prior to rebase conflict - humans.txt
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git checkout -b rebase-conflict-branch
			Switched to a new branch 'rebase-conflict-branch'

		$ vim index.html

		$ git commit -am "rebase-conflict-branch: three changes - index.html"
			[rebase-conflict-branch 9f2dd85] rebase-conflict-branch: three changes - index.html
			 1 file changed, 3 insertions(+), 3 deletions(-)

		$ git checkout master
			Switched to branch 'master'

		$ vim index.html

		$ git commit -am "master: three conflicting changes - index.html"
			[master 712e15f] master: three conflicting changes - index.html
			 1 file changed, 3 insertions(+), 3 deletions(-)

		
		$ git log --oneline --decorate --graph --all
			* 712e15f (HEAD -> master) master: three conflicting changes - index.html
			| * 9f2dd85 (rebase-conflict-branch) rebase-conflict-branch: three changes - index.html
			|/
			* 17984e2 master: prior to rebase conflict - humans.txt
			* 1b76bf5 top-feature: browser upgrade recommendation - index.html
			* 87b1a6b top-feature: modified title - index.html
			* 8b831eb master: changed font family - 404.html
			* c68eb9b master: modified title - 404.html
			* d0c9998 master: added team info - humans.txt
			* a3e7455 master: added name - humans.txt
			* d7ba2ee commiting all files

	Now we will switch to rebase-conflict-branch and then rebase =>
	
		$ git checkout rebase-conflict-branch
			Switched to branch 'rebase-conflict-branch'

		$ git checkout rebase-conflict-branch
			Already on 'rebase-conflict-branch'

		$ git rebase master
			error: could not apply 9f2dd85... rebase-conflict-branch: three changes - index.html
			Resolve all conflicts manually, mark them as resolved with
			"git add/rm <conflicted_files>", then run "git rebase --continue".
			You can instead skip this commit: run "git rebase --skip".
			To abort and get back to the state before "git rebase", run "git rebase --abort".
			Could not apply 9f2dd85... rebase-conflict-branch: three changes - index.html
			Auto-merging demo-rebase/index.html
			CONFLICT (content): Merge conflict in demo-rebase/index.html

	
	We can see we are getting conflict as expected.
	
	Git is saying we can execute "git rebase --continue" once we have resolved the conflict.
	Or if we want to stop rebasing we can execute - "git rebase --abort" command.

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-rebase (rebase-conflict-branch|REBASE 1/1)	//check
		$ git rebase --abort

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-rebase (rebase-conflict-branch)			//changed after aborting

	We will again do rebase and resolve conflict => 


		$ git rebase master
			error: could not apply 9f2dd85... rebase-conflict-branch: three changes - index.html
			Resolve all conflicts manually, mark them as resolved with
			"git add/rm <conflicted_files>", then run "git rebase --continue".
			You can instead skip this commit: run "git rebase --skip".
			To abort and get back to the state before "git rebase", run "git rebase --abort".
			Could not apply 9f2dd85... rebase-conflict-branch: three changes - index.html
			Auto-merging demo-rebase/index.html
			CONFLICT (content): Merge conflict in demo-rebase/index.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-rebase (rebase-conflict-branch|REBASE 1/1)
		$ git mergetool
			Merging:
			demo-rebase/index.html

			Normal merge conflict for 'demo-rebase/index.html':
			  {local}: modified file
			  {remote}: modified file

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-rebase (rebase-conflict-branch|REBASE 1/1)
		$ git status
			interactive rebase in progress; onto 712e15f
			Last command done (1 command done):
			   pick 9f2dd85 rebase-conflict-branch: three changes - index.html
			No commands remaining.
			You are currently rebasing branch 'rebase-conflict-branch' on '712e15f'.
			  (all conflicts fixed: run "git rebase --continue")

			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   index.html


	We can see git advises => (all conflicts fixed: run "git rebase --continue")
		
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-rebase (rebase-conflict-branch|REBASE 1/1)
		$ git rebase --continue
			[detached HEAD 3643c29] rebase-conflict-branch: three changes - index.html
			 1 file changed, 2 insertions(+), 2 deletions(-)
			Successfully rebased and updated refs/heads/rebase-conflict-branch.

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-rebase (rebase-conflict-branch)
		$ vim index.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-rebase (rebase-conflict-branch)
		$ git log --oneline --decorate --graph --all
			* 3643c29 (HEAD -> rebase-conflict-branch) rebase-conflict-branch: three changes - index.html
			* 712e15f (master) master: three conflicting changes - index.html
			* 17984e2 master: prior to rebase conflict - humans.txt
			* 1b76bf5 top-feature: browser upgrade recommendation - index.html
			* 87b1a6b top-feature: modified title - index.html
			* 8b831eb master: changed font family - 404.html
			* c68eb9b master: modified title - 404.html
			* d0c9998 master: added team info - humans.txt
			* a3e7455 master: added name - humans.txt
			* d7ba2ee commiting all files
			
	We will now switch back to master and do merge => 

		$ git checkout master
			Switched to branch 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-rebase (master)
		$ git merge rebase-conflict-branch
			Updating 712e15f..3643c29
			Fast-forward
			 demo-rebase/index.html | 4 ++--
			 1 file changed, 2 insertions(+), 2 deletions(-)


		
		$ git log --oneline --decorate --graph --all
			* 3643c29 (HEAD -> master, rebase-conflict-branch) rebase-conflict-branch: three changes - index.html
			* 712e15f master: three conflicting changes - index.html
			* 17984e2 master: prior to rebase conflict - humans.txt
			* 1b76bf5 top-feature: browser upgrade recommendation - index.html
			* 87b1a6b top-feature: modified title - index.html
			* 8b831eb master: changed font family - 404.html
			* c68eb9b master: modified title - 404.html
			* d0c9998 master: added team info - humans.txt
			* a3e7455 master: added name - humans.txt
			* d7ba2ee commiting all files

	
	We can see after merge master also point to top commit.
	
	At last we can delete the branch => 
	
		$ git branch -d rebase-conflict-branch
			Deleted branch rebase-conflict-branch (was 3643c29).

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-rebase (master)
		$ git log --oneline --decorate --graph --all
			* 3643c29 (HEAD -> master) rebase-conflict-branch: three changes - index.html
			* 712e15f master: three conflicting changes - index.html
			* 17984e2 master: prior to rebase conflict - humans.txt
			* 1b76bf5 top-feature: browser upgrade recommendation - index.html
			* 87b1a6b top-feature: modified title - index.html
			* 8b831eb master: changed font family - 404.html
			* c68eb9b master: modified title - 404.html
			* d0c9998 master: added team info - humans.txt
			* a3e7455 master: added name - humans.txt
			* d7ba2ee commiting all files

	
	Mergetool => rebase-conflict-branch 	=  BASE (before any branch changes)	=  Master


	a) Command "git commit --amend" is a convenient way to fix up the most recent commit. It combines the staged changes with previous commit and replace the previous commit with the resulting snapshot.
	
	b) But amending doesn't just alter the most recent commit - it replaces it entirely. To Git, it will look like a brand new commit.
	
	c) Premature commits happen all the time in the course of your everyday development. It's easy to forget to stage a file or to format your commit message the wrong way. The --amend flag is a convenient way to fix these little mistakes.
	
	d) Never amend commits that have been pushed to a public repository.
	
	
	
	a) Rebasing is the process of moving a branch to a new base commit.
	
	b) Rebasing really is just moving a branch from one commit to another. But internally, Git accomplihes this by creating a new commits and applying them to the specified base - it's literally rewiting your project history.
	
	c) Command "git rebase <BASE>" rebases the current branch onto <BASE>, which can be any kind of commit reference - an ID, a branch name, a tag, or a relative reference HEAD.
	
	d) Rebasing is a common way to integrate upstream changes into your local repository. Rebasing is like saying "I want to base my changes on what everybody has already done".
	
	
	
	The correct sequence for a complete rebase operation (no conflict, assumed) of a feature branch, say "X" (on master branch) that involves the following setps =>
		a) Switch to branch "X" 
		b) Stay on branch "X" and execute the rebase command "git rebase master"
		c) Switch to master branch and merge branch "X"			//now master and "X" will point to same last commit.
		d) Delete branch "X"
	
	
	
	The correct sequence for a complete a rebase operation (rebase conflict and resolution, assumed) of a feature branch, say "X" (on master branch) that involves the following steps =>
	a) Switch to branch "X" 
	b) Stay on branch "X" and execute the rebase command "git rebase master"
	c) Stay on branch "X" and resolve conflict manually either using command line or a GUI tool such as p4merge
	d) Stay on branch "X" and execute the rebase command "git rebase --continue"
	e) Switch to the master branch and merge branch "X"
	f) Delete branch "X" 
	

90. An Introduction to git fetch (Lab)

	git fetch command synchronizes orgin/master with whatever is on the remote repository.
	orgin/master is local copy of the remote repository.
	
	If the remote is ahead of commits than our local repository, then we can do fetch to update and sync our local repository, same like remote.
	
	git log --oneline origin/master	=> will give logs of local repository
	
	git log --oneline master		=> 
	
	git fetch origin master	=> origin is our remote reference and master is the branch on our remote repository. Since we have only single remote repository we can simply do => git fetch. If we have more tan one remote repository then we will have to mention name of the remote explicitly.
	
	After git fetch we will get remote commits as well in our local. 
	
	----------------------------------
	
		$ git init
			Initialized empty Git repository in C:/Users/inarajp/Desktop/temp/Udemy-Git/Repositories/demo-fetch/.git/

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git add .
			warning: LF will be replaced by CRLF in 404.html.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in browserconfig.xml.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in css/main.css.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in css/normalize.css.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in humans.txt.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/main.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/plugins.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/vendor/jquery-1.11.2.min.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in js/vendor/modernizr-2.8.3-respond-1.4.2.min.js.
			The file will have its original line endings in your working directory
			warning: LF will be replaced by CRLF in robots.txt.
			The file will have its original line endings in your working directory

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git commit -m "commiting all files"
			[master (root-commit) b9f2168] commiting all files
			 16 files changed, 1022 insertions(+)
			 create mode 100644 404.html
			 create mode 100644 apple-touch-icon.png
			 create mode 100644 browserconfig.xml
			 create mode 100644 css/main.css
			 create mode 100644 css/normalize.css
			 create mode 100644 css/normalize.min.css
			 create mode 100644 favicon.ico
			 create mode 100644 humans.txt
			 create mode 100644 index.html
			 create mode 100644 js/main.js
			 create mode 100644 js/plugins.js
			 create mode 100644 js/vendor/jquery-1.11.2.min.js
			 create mode 100644 js/vendor/modernizr-2.8.3-respond-1.4.2.min.js
			 create mode 100644 robots.txt
			 create mode 100644 tile-wide.png
			 create mode 100644 tile.png

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git remote -v


		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git remote add demo-fetch https://github.com/aniketrajput/demo-fetch.git					//instead of origin we gave name as demo-fetch to remote.

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git remote -v
			demo-fetch      https://github.com/aniketrajput/demo-fetch.git (fetch)
			demo-fetch      https://github.com/aniketrajput/demo-fetch.git (push)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git push origin master
			fatal: 'origin' does not appear to be a git repository
			fatal: Could not read from remote repository.

			Please make sure you have the correct access rights
			and the repository exists.

			inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
			$ git push demo-fetch master
			Enumerating objects: 21, done.
			Counting objects: 100% (21/21), done.
			Delta compression using up to 8 threads
			Compressing objects: 100% (20/20), done.
			Writing objects: 100% (21/21), 58.25 KiB | 1.76 MiB/s, done.
			Total 21 (delta 0), reused 0 (delta 0), pack-reused 0
			To https://github.com/aniketrajput/demo-fetch.git
			 * [new branch]      master -> master

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ vim index.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git add .
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git commit -m "local: added title - index.html"
			[master 8023749] local: added title - index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ vim index.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git add .
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git commit -m "local: modified image - index.html"
			[master 4282256] local: modified image - index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git log --oneline --decorate --graph --all
			* 4282256 (HEAD -> master) local: modified image - index.html
			* 8023749 local: added title - index.html
			* b9f2168 (demo-fetch/master) commiting all files

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git push demo-fetch master
			Enumerating objects: 8, done.
			Counting objects: 100% (8/8), done.
			Delta compression using up to 8 threads
			Compressing objects: 100% (6/6), done.
			Writing objects: 100% (6/6), 625 bytes | 208.00 KiB/s, done.
			Total 6 (delta 4), reused 0 (delta 0), pack-reused 0
			remote: Resolving deltas: 100% (4/4), completed with 2 local objects.
			To https://github.com/aniketrajput/demo-fetch.git
			   b9f2168..4282256  master -> master

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git log --oneline --decorate --graph --all
			* 4282256 (HEAD -> master, demo-fetch/master) local: modified image - index.html
			* 8023749 local: added title - index.html
			* b9f2168 commiting all files
	
		$ git log --oneline master
			4282256 (HEAD -> master, demo-fetch/master) local: modified image - index.html
			8023749 local: added title - index.html
			b9f2168 commiting all files

		$ git log --oneline demo-fetch/master
			4282256 (HEAD -> master, demo-fetch/master) local: modified image - index.html
			8023749 local: added title - index.html
			b9f2168 commiting all files

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git fetch demo-fetch master					//here demo-fetch is our remote reference, in tutorial he has remote reference as origin.
			remote: Enumerating objects: 8, done.
			remote: Counting objects: 100% (8/8), done.
			remote: Compressing objects: 100% (6/6), done.
			remote: Total 6 (delta 4), reused 0 (delta 0), pack-reused 0
			Unpacking objects: 100% (6/6), 1.37 KiB | 25.00 KiB/s, done.
			From https://github.com/aniketrajput/demo-fetch
			 * branch            master     -> FETCH_HEAD
			   4282256..532b43b  master     -> demo-fetch/master

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git log --oneline demo-fetch/master
			532b43b (demo-fetch/master) remote-origin: modified width - 404.html
			0563469 remote-origin: modified title - 404.html
			4282256 (HEAD -> master) local: modified image - index.html
			8023749 local: added title - index.html
			b9f2168 commiting all files

	
	Now demo-fetch/master does't automatically reflect whatever is on remote repository, and hence we need to execute git fetch command.
	Fetch command synchronizes demo-fetch/master with whatever is on remote repository.
	Now we can see that we got all commits from remote as well. 
	
	We can see that when we use fetch command it updates only demo-fetch/master branch (which is local copy of our remote repository)and not the master or any non-remote branch in our local repository. We can see HEAD -> master is still on 3rd commit.
	To get the update we have to manually do a git merge. 
	
	We can do fast-forward merge of demo-fetch/master and master. 
	Now demo-fetch/master is just a branch like any other branch but it is a remote branch.
	
		$ git log --oneline --decorate --graph --all
			* 532b43b (demo-fetch/master) remote-origin: modified width - 404.html
			* 0563469 remote-origin: modified title - 404.html
			* 4282256 (HEAD -> master) local: modified image - index.html
			* 8023749 local: added title - index.html
			* b9f2168 commiting all files

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git branch -r
			demo-fetch/master

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git branch -a
			* master
			remotes/demo-fetch/master

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git merge demo-fetch/master master
			Updating 4282256..532b43b
			Fast-forward
			 404.html | 4 ++--
			 1 file changed, 2 insertions(+), 2 deletions(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-fetch (master)
		$ git log --oneline --decorate --graph --all
			* 532b43b (HEAD -> master, demo-fetch/master) remote-origin: modified width - 404.html
			* 0563469 remote-origin: modified title - 404.html
			* 4282256 local: modified image - index.html
			* 8023749 local: added title - index.html
			* b9f2168 commiting all files

	Now we can see master has been updated. 
	
	1. Do a fetch before you start your days work so that we can see what work our other team members have done.
	2. Fetch before you push to remote repository. There might be some conflicting commits that we are going to push so always do fetch.
	3. Fetch often - stay in sync as much as possible.

	git fetch is a non-destructive command and it updates the references only in origin/master and does not affect any of our non-remote branch in our local repository including the master branch.  


-------------------------------------------------------------------------------------------------

Youbute vedio - Introduction to git remote - youtube.com/watch?v=Gg4bLk8cGNo&list=LLh7ZXtB3MHIv0ODZeeblT5w&index=3&t=0s


	When we are working in a repository, a remote is simply a repository in another location from where we are currently working. 
	
	For example we may be working on a repository on our laptop, the version of same may be on a github. So from perspective of our laptop github is a remote repository.
	
	A remote can be a copy or fork of a repository within github.
	A remote can be a repository on a co-worker's system. 
	It can even be a another directory on our same local system. 
	
	When we fetch or push updates we don't need to remember the full location of our remote (like - git@github.com/aniketrajput/business-venture.git). Instead git can hold a short name or alias to that location. The default first name is "origin". 
	"origin" will point to the repository in github. 
	
	
	What we will do - 
	1. We will create a new repository under Betty's account. (git will add one commit for readme.md by default)
		Then we will clone it to our local system. 
		We will be then able to fetch update and push on it.

	If we check "git remote -v"	we can see we have one remote named "origin"
	
	
	alias graph = 'git log --oneline --decorate --graph --all' => next time we can just use alais "graph" directly for this command.
	
	$ graph
		* f26e9ba (HEAD -> master) orgin/master, origin/HEAD) Initial commit				//master is in blue and other are in red.
		
	So locally we have only one "master" branch. 
	
	orgin/master is a specialized branch. It is called a remote tracking branch. The job of this remote tracking branch is to tell us what the master branch looks like at origin. 
	The orgin/master branch is telling us that our local "master" branch and the "master" branch in the github are pointing to the same commit.
	In other words our local repository is in sync with our remote named "origin"
	
	The remote tracking branch (orgin/master) is not the same as the standard local branch. 
	We can check it out, but we will end up in detached head state.
	
	
	2. We will now add a new commit from github and then fetch and merge it on our local.
	
	
	The commit which we added in github will not be available in our local yet.
	Git doesn't know about the new commit at the origin. 
	It doesn't automatically investigate how things stands at remote.
	So we do git fetch.
	
	"git fetch origin"
	
	If we do git status it will say - your branch is behind 'orgin/master' by 1 commit, and can be fast-forwarded
	
		$ graph
			* f26e9ba (orgin/master, origin/HEAD) Create S1
			* f801828 (HEAD -> master) Initial commit	
	
	We can see that at origin the master branch is at second commit and locally we are still at first commit.
	We will probably like to integrate or merge the changes from origin into our local master branch.
	
	"git merge orgin/master"
		
		$ graph
			* f26e9ba (HEAD -> master, orgin/master, origin/HEAD) Create S1
			* f801828 Initial commit	
	
	After merge we are in sync again.
	
	
	Now we also have a "git pull" command available to us. 
	"git pull" combines "git fetch" and "git merge" into a single command.
	
	
	3. Now we will do some local commit and push it to origin.
	
	After adding a commit locally - 
	
		$ graph
			* a416469 (HEAD -> master) new mngt Ip for S1
			* f26e9ba (orgin/master, origin/HEAD) Create S1
			* f801828 Initial commit	
	
	We see we are now locally one commit ahead from tracking branch orgin/master. 
	git status will reveal the same.
	
	So we will => git push origin master 	//We are push our change to a remote named origin and to a master branch at origin.
	
	After push - 
	
		$ graph
			* a416469 (HEAD -> master, orgin/master, origin/HEAD) new mngt Ip for S1
			* f26e9ba Create S1
			* f801828 Initial commit	
	
	4. Until now we were working with a single remote. Now we will add a second remote.
		We will start the process by creating a fork in github.
		We will now look from a perspective of a second user Bob.
		Bob wants to work on a netAuto repository owned by Betty.
		Bob doesn't have a write access to original netAuto repository. He can't push changes from his local to existing repository. 
		One option Bob has is to fork the repository in github. Fork will create a copy of Betty's Repository in github in Bob's accunt.
		Bob will be owner of this copy. Bob can then do git clone against his fork of netAuto repository.
		Now Bob can work locally on his laptop. He can create new branch, commits and then push that work into the fork of his netAuto repository.
		
		Now after cloning of we do "git remote -v", we can see that the origin is pointing to the fork of netAuto repo in Bob's github. 
		
		Now we would also like to be in sync with original repo as well i.e. the one we forked from i.e the one under Betty's account.
		To do that we will need to add a second git remote. We will call it "upstream".
		
		So from perspective of Bob's local system, origin will point to his fork and upstream will point to Betty's repo.
		
		
		"git remote add upstream git@github.com:betty-remote/netAuto.git"
		
		"git remote - v" => will now show two remotes origin and upstream.
		
		If we want to remove a remote we can => git remote remove <remote-name>
	
	
	5. Now what will happen when there is an update in the upstream repo.
		We will see how to keep Bob's local repo and his fork in sync with upstream.
		
		
		$ graph
			* a416469 (HEAD -> master, orgin/master, origin/HEAD) new mngt Ip for S1
			* f26e9ba Create S1
			* f801828 Initial commit	
	
	Notice we don't have a new remote tracking branch for our new remote upstream. 
	We have to run git fetch for this.
	
		"git fetch upstream"
		
		$ graph
			* a416469 (HEAD -> master, upstream/master, orgin/master, origin/HEAD) new mngt Ip for S1
			* f26e9ba Create S1
			* f801828 Initial commit	
	
	Now graph show a new tracking branch upstream/master, which reflects Betty's master branch in github.
	origin/master reflect the master branch in Bob's fork.
	
	
	6. Now we will add a new commit to Betty's master branch. We will add a new commit and then push it to Betty's remote.
		
		Now if we check in Bob's local, we can see that he doesn't sees the new commit yet in upstream. For that he will have to do fetch.
		
		"git fetch upstream"
		
		$ graph
			* 38c4f6b (upstream/master) add switch S2
			* a416469 (HEAD -> master, orgin/master, origin/HEAD) new mngt Ip for S1
			* f26e9ba Create S1
			* f801828 Initial commit	
	
	We can see upstream/master has moved up. Both Bob's local repo and fork are out of sync from Betty's repo.
	We will sync them up now. 
	
	"git merge upstream/master"		// this will merge the commit from upstream master branch into our local master branch. 
	
		
		$ graph
			* 38c4f6b (HEAD -> master, upstream/master) add switch S2
			* a416469 (orgin/master, origin/HEAD) new mngt Ip for S1
			* f26e9ba Create S1
			* f801828 Initial commit	
	
	We can see that Bob is finally caught up locally. But to get his fork update he will have to push. 
	
	"git push orgin/master"	
	
		
		$ graph
			* 38c4f6b (HEAD -> master, upstream/master, orgin/master, origin/HEAD) add switch S2
			* a416469  new mngt Ip for S1
			* f26e9ba Create S1
			* f801828 Initial commit	
	
	
	7. This whole time we have only been working with the master branch. 
		Now we will have Bob create a new local branch, add a commit to it, push it up to his fork and create a Pull Request in github.
		
		Bob want to contribute in Betty's netAuto repo. He has a small implementation. 
		Locally Bob has only master branch. He wants to keep his master branch clean and in sync with Betty's repo. So for this work we create a new branch called edit-s2. 
		We will make a change on this edit-s2 and commit it. 
		Next we will push to bob fork. 
		The push will create edit-s2 branch in github. 
		Then from Bob's fork in github we will then create a pull request to original netAuto repo. 
		The request is for Betty to merge our new edit-s2 branch into the master branch of her repo.
		We are asking Betty to merge our changes into the main project. 
		
		If Betty does the merge then we can do some clean up work, we can delete the edit-s2 branch locally and in github. 
		We can also re-sync our master branch locally and in github.
		

--------------------------------------------------------------------------------------------------


91. Git pull with rebase - Part 1 (Lab)
92. Git pull with rebase - Part 2 (Lab)

	We will see difference between doing a git pull and git pull with rebase.
	
	Our local git maintains not only our local repository, but it also maintains a local copy of the remote repository. 
	
	git fetch brings the local copy of the remote repository up to date. 
	
	git pull (without rebase) = git fetch + git merge
	
	git pull --rebase <remote-nam> <branch-name>
	
	
	git push -u origin master			//check -u option
	
	
	git pull rebase => will pull all our local commit on the top of all the commits that we pulled in from remote. And we have a flat, linear history.
	
	It up to us, if to use pull or pull rebase. 
	
	It is recommended to do pull rebase if we are pulling in smaller change sets, but for pulling in large change sets git pull is a way to go.
	
	You can watch vedio again. 
	
	
	
Quiz 18: Commit History rewriting in Git - Quiz 2

	Command "git log --oneline master" is equivalent Command"git log --oneline" (assuming "master" is the current branch)	

	Command "git fetch origin master" is Command "git fetch" when we have only one remote repository reference
	
	We need to execute "git fetch" command so that remote repository and the local copy of the remote repository are in sync
	
	Execution of "git fetch" command does not affects the local master and/or other non-remote branches

	Command "git branch -r" displays remote references such as "origin/master" but not local branches such as local "master" branch

	Command "git pull" is equivalent to execution of command "git fetch" followed by "git merge"


	- Following statements are correct
		- command "git fetch" does not updates the local repository directly
		- command "git pull" updates the local copy of the repository
		- For smaller feature upadtes, it is good to do a "git pull" with "rebase" option
		- For longer feature updates, it is good to do a "git pull" only and thus invoking the merge operation.
		
		
	- Which of the following statements are correct when we update our local repo and merge in upstream (remote) by executing "git pull" command
		- local copy of remote repo (such as orgin/master) is updated
		- updates in orgin/master is merged with local repo
		- HEAD is restored to local master
		
	
	- Which of the following statements are correct
		- command "git pull --rebase" does not updates orgin/master and does not merges in the changes with local repo.
		- command "git pull --rebase" does not creates a merge commit just like normal "git pull" command.
		- command "git pull --rebase" is recommended for rebasing small change sets while reserving "git pull" command for large change sets from upstream repo
		- command "git pull --rebase" rebases local changes on top of changes pulled in from upstream.
		

93. Git reflog: Part 1 (Lab)

	One of the thing that git does in background while we are working away is keep reflog i.e the log of where our HEAD and branches/references has been for last few months. 
	
	reflog is acronym of Reference logs. 
	
	The current HEAD can get updated for multiple events such as : 
		- by switching branches
		- pulling in new changes
		- rewriting history
		- simply by adding new commits
		
	For each of the above enents an entry will be added to reflog. 
	
	reflog is git's safety net, it records almost every change in git repository regardless we commited the snapshop or not.


	"git reflog" 
	
		$ git reflog
			532b43b (HEAD -> master, demo-fetch/master) HEAD@{0}: merge demo-fetch/master: Fast-forward
			4282256 HEAD@{1}: commit: local: modified image - index.html
			8023749 HEAD@{2}: commit: local: added title - index.html
			b9f2168 HEAD@{3}: commit (initial): commiting all files

	We can access any reflogs we want.
	
		$ git show HEAD@{2}
			commit 80237497dd2bcc019cf2de34f6776054295177b4
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Tue Apr 21 17:06:59 2020 +0530

				local: added title - index.html

			diff --git a/index.html b/index.html
			index 1bc5016..71fcba9 100644
			--- a/index.html
			+++ b/index.html
			@@ -6,7 +6,7 @@
				 <head>
					 <meta charset="utf-8">
					 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
			-        <title></title>
			+        <title>demo-fetch</title>
					 <meta name="description" content="">
					 <meta name="viewport" content="width=device-width, initial-scale=1">
					 <link rel="apple-touch-icon" href="apple-touch-icon.png">


	Each reflog has implicit time associated with it. We can also filter by time.
	
	Various supported forms includes: 
		- 1.minute.ago
		- 1.hour.ago
		- 1.day.ago
		- yesterday
		- 1.week.ago
		- 1.month.ago
		- 1.year.ago
		- 2011-05-17.09:00:00
		
	The plural forms are also accepted e.g. 2.weeks.ago AND also combinations e.g. 1.day.2.hours.ago

	"git diff @{1.hour.ago}"
	
	"git show master@{5.days.ago}"
	

94. Git reflog: Part 2 (Lab)

	git log -g master 			//will show in a formatted way
	
	reflog is for a repository, so suppose we have clone yesterday, then 2.month.ago will not work.
	
	The reflog data is kept in the .git/logs directory.
	
	Watch vedio, easy to understand.
	
	
	If someone comes to you with an issue to investigate what he had done, we can use reflog... check vedio again for uses.
	
	
Quiz 19: Commit History rewriting in Git - Quiz 3
	
	- Following statements are correct - 
		- "reflog" is an acronym for Reference logs
		- "reflog" can be accessed at a specific point of time
		- "reflog" - is a log of where your HEAD and branch references have been for the last few months.
		- The reflog is Gitâ€™s safety net. It records almost every change you make in your repository, regardless of whether you committed a snapshot or not. You can think of it is a chronological history of everything you've done in your local repo

	
	- Every time your branch tip is updated for any reason, Git stores that information for you in this temporary history. And you can specify older commits with this data, as well. If you want to see the fifth prior value of the HEAD of your repository, you can execute this command - git show HEAD@{5}
	
	- You can also use this syntax to see where a branch was some specific amount of time ago. For instance, to see where your master branch was yesterday. The following command shows you where the branch tip was yesterday (This technique only works for data thatâ€™s still in your reflog, so you canâ€™t use it to look for commits older than a few months) - git show master@{yesterday}
	
	- To see reflog information formatted similar to "git log" output, run the following command - git log -g		//observe its "log" and not "reflog"

	- Following statements are correct
		- It important to note that the reflog information is strictly local - it's a log of what you've done in your repository
		- The reflog entries in your repository won't be the same as in someone else's copy of the repository
		- The reflog data is kept in the .git/logs directory.
		
	
	- The following statements are correct
		- "git reflog" doesn't traverse HEAD's ancestry at all. The reflog is an ordered list of the commits that HEAD has pointed.
		- reflog is "undo history" for your repo.
		- The reflog isn't part of the repo itself (it's stored separately to the commits themselves) and isn't included in pushes, fetches or clones
		
	
	- The following statements are correct
		- Understandinf the reflog means you can't really lose data from your repo once it's been committed.
		- If you accidently reset to an older commit, or rebase wrongly, or any other operation that visually "removes" commits, you can use the reflog to see where you were before and execute command "git reset --hard" back to that reflog entry to restore your previous state.
		- A word of caution: you sometimes can lose data because reflog entires don not persist eternally - they are purged upon certain conditions.
		
	The command "git checkout HEAD@{1}" can put you in a detached HEAD state


Section 18: Git Tagging

95. Git Tagging: Lightweight and Annotated(Lab)

	
	Git has ability to tag specific points in history as being important.
	Tags access bookmarks. 
	Normally people use tag functionality to mark release points such as version 1.0, etc. 
	
	Git uses two main type of tags - light-weight tags and annotated tags. 
	
	We will with light-weight tags first.
	Light-weight tags is very much like a branch that doesn't change. 
	It is just a pointer to specific commit.
	
	We will create a new repo demo-tag and build up some commit history.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-tag (master)
		$ git log --oneline --decorate --graph --all
			* 2f49fbb (HEAD -> master) master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit


	So now we wil create a tag.
	
	Release Candidate (RC) is the build released internally to check if any critical problems have gone undetected into the code during the previous development period.
	Release Candidate are NOT for production deployment, but they are for testing purposes only.
	
		$ git tag v-1.8-rc1

		$ git tag			//lists tag
			v-1.8-rc1

		$ git tag --list	//Also //lists tag
			v-1.8-rc1

		$ git log --oneline --decorate --graph --all
			* 2f49fbb (HEAD -> master, tag: v-1.8-rc1) master: edited text-align and height - 404.html		//we can see tag has been added to this HEAD commit.
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit


	We can see tag has been added to the HEAD commit.
	
	If we execute command git tag <tag-name> it will always tag with the latest commit. 
	
	However we can associate the tag we create with a specific commit as well. We will talk about this later.
	
	"git show v-1.8-rc1" => will show the details of the tag.
	
	
		$ git show v-1.8-rc1
			commit 2f49fbb186216e11a4c42be97c08e2cafb8c64f9 (HEAD -> master, tag: v-1.8-rc1)
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Thu Apr 23 11:13:09 2020 +0530

				master: edited text-align and height - 404.html

			diff --git a/404.html b/404.html
			index 81122d8..15f3ac8 100644
			--- a/404.html
			+++ b/404.html
			@@ -15,8 +15,8 @@
						 color: #888;
						 display: table;
						 font-family: time-new-roman;
			-            height: 100%;
			-            text-align: center;
			+            height: 50%;
			+            text-align: left;
						 width: 100%;
					 }


	
	Now we will see annotated tag. 
	Annotated tags are stored as full objects in the git database. 
	They are checksumed, they contains the tagger name, email, and date. 
	Annotated tag also have a tagging message and can be signed and verified with GPG as well. 
	If we want to temporarily tag and don't want to keep other information, light-weight tag will be good enough.
	However it is recommended to have annotated tag so that we can have all the mentioned information.
	
	We will use same repo. We will add a new commit for index.html. 

		$ vim index.html

		$ git commit -am "master: modified title - index.html"
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			[master 9d52563] master: modified title - index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git log --oneline --decorate --graph --all
			* 9d52563 (HEAD -> master) master: modified title - index.html
			* 2f49fbb (tag: v-1.8-rc1) master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

		$ git tag -a v-1.9-rc2 -m "released version 1.0"		// -a stands for annotated. We can also use --annotated instead of -a
		
		$ git tag
			v-1.8-rc1
			v-1.9-rc2

		$ git log --oneline --decorate --graph --all
			* 9d52563 (HEAD -> master, tag: v-1.9-rc2) master: modified title - index.html		// We can see new annotated tag added here. 
			* 2f49fbb (tag: v-1.8-rc1) master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

	We will now create another commit and then another tag.
	
		$ vim index.html

		$ git commit -am "master: modified css - index.html"
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			[master c44fb18] master: modified css - index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git log --oneline --decorate --graph --all
			* c44fb18 (HEAD -> master) master: modified css - index.html
			* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
			* 2f49fbb (tag: v-1.8-rc1) master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

		$ git tag -a v-1.9.1		//here we didn't specify the -m option so default editor opens up for us to enter the message

		$ git log --oneline --decorate --graph --all
			* c44fb18 (HEAD -> master, tag: v-1.9.1) master: modified css - index.html			//new tag added.
			* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
			* 2f49fbb (tag: v-1.8-rc1) master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

		$ git tag
			v-1.8-rc1
			v-1.9-rc2
			v-1.9.1
	
		$ git show v-1.9.1
			tag v-1.9.1
			Tagger: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Thu Apr 23 11:29:56 2020 +0530

			Release version 1.9.1

			commit c44fb182e3261d863c53610efcbc333f7ad2762f (HEAD -> master, tag: v-1.9.1)
			Author: Aniket Rajput <Aniket.Rajput@vanderlande.com>
			Date:   Thu Apr 23 11:29:23 2020 +0530

				master: modified css - index.html

			diff --git a/index.html b/index.html
			index 85ec9b7..09e418c 100644
			--- a/index.html
			+++ b/index.html
			@@ -11,7 +11,7 @@
					 <meta name="viewport" content="width=device-width, initial-scale=1">
					 <link rel="apple-touch-icon" href="apple-touch-icon.png">

			-        <link rel="stylesheet" href="css/normalize.min.css">
			+        <link rel="stylesheet" href="css/normalize.css">
					 <link rel="stylesheet" href="css/main.css">

					 <script src="js/vendor/modernizr-2.8.3-respond-1.4.2.min.js"></script>

	
	We can see that "git show" information for annotated tag is slightly different from the light-weight tag.
	

96. Git Tagging : Determining Tag Type (Lab)

	We will see ho to determine whether the tag is annotated tag or a light-weight tag. 
	
	There are two ways.
	
	We can simply do "git show <tag-name>" as we did in previous session. If it is annotated tag it will show slightly different information than light-weight tag.
	
	Second ways is we can use command - git cat-file -t <tag-name>	
	"git cat-file" provides content or type and size information for repository objects.
	-t indicated git that we want type info for the git object 
	If it produces an output "tag" then we can be sure that it is an annotated tag.
	And if it produces output as commit then we can be sure that it is a light-weight tag. 
	
		$ git cat-file -t v-1.9-rc2
			tag
		
		$ git cat-file -t v-1.8-rc1
			commit


97. Git Tagging:Tag search (Lab)
	
	We will see how to search tags.
	
	Now lets assume we want to search all the tag which has "v-1.9" in them then - 
	
		$ git tag
			v-1.8-rc1
			v-1.9-rc2
			v-1.9.1

		$ git tag -l "v-1.9*"
			v-1.9-rc2
			v-1.9.1

		$ git tag --list "v-1.9*"			//--list is same as -l
			v-1.9-rc2
			v-1.9.1

	
	
98. Git Tagging: compare, update, delete tags(Lab)

	We will see -
		How to compare compare two tags or diff.
		How to update tags.
		How to delete tag.


	The alpha phase of the release cycle is the first phase to begin software testing (alpha is the first letter of the Greek alphabet, used as the number 1). In this phase, developers generally test the software using white-box testing techniques. Alpha software can be unstable and could cause crashes or data loss. Alpha software may not contain all of the features that are planned for the final version.
	
	Beta, named after the second letter of the Greek alphabet is the software development phase following alpha. Beta phase generally begins when the software is feature complete but likely to contain a number of known or unkown bugs. Software in the beta phase will generally have many more bugs in it than complete software, as well as speed/performance issues and may still cause crashes or data loss.
	
	We added one commit, then we create a annotated tag for latest commit, then we again added a new commit.

		$ vim index.html

		$ git commit -am "master: modified title - index.html"
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			[master be40ca9] master: modified title - index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git log --oneline --decorate --graph --all
			* be40ca9 (HEAD -> master) master: modified title - index.html
			* c44fb18 (tag: v-1.9.1) master: modified css - index.html
			* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
			* 2f49fbb (tag: v-1.8-rc1) master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

		$ git tag -a v-3.1.0 -m "Release 3.1"

		$ vim index.html

		$ git commit -am "master: modified js version - index.html"
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			[master 520d7e3] master: modified js version - index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git log --oneline --decorate --graph --all
		* 520d7e3 (HEAD -> master) master: modified js version - index.html
		* be40ca9 (tag: v-3.1.0) master: modified title - index.html
		* c44fb18 (tag: v-1.9.1) master: modified css - index.html
		* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
		* 2f49fbb (tag: v-1.8-rc1) master: edited text-align and height - 404.html
		* 2210023 master: edited width - 404.html
		* c3d31cb master: edited font-family - 404.html
		* 551c960 master: edited line-height - 404.html
		* 1841047 master: edited title - index.html
		* 2fec32b first commit

	
	Again create a new tag - 
	
		$ git tag -a v-3.1.0-beta -m "Release 3.1 beta"

		$ git log --oneline --decorate --graph --all
			* 520d7e3 (HEAD -> master, tag: v-3.1.0-beta) master: modified js version - index.html
			* be40ca9 (tag: v-3.1.0) master: modified title - index.html
			* c44fb18 (tag: v-1.9.1) master: modified css - index.html
			* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
			* 2f49fbb (tag: v-1.8-rc1) master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

	Now we will compare these two tags i.e v-3.1.0 and v-3.1.0-beta using difftool p4merge.
	
		$ git difftool v-3.1.0 v-3.1.0-beta

	We will now demonstrate how to update a commit, for that we will add two commits for 404.html and index.html -	
	
		$ vim 404.html

		$ git commit -am "master: modified title - 404.html"
			warning: LF will be replaced by CRLF in 404.html.
			The file will have its original line endings in your working directory
			[master eaf2999] master: modified title - 404.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ vim index.html

		$ git commit -am "master: modified title - index.html"
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			[master 4ee49ee] master: modified title - index.html
			 1 file changed, 1 insertion(+), 1 deletion(-)

		$ git log --oneline --decorate --graph --all
			* 4ee49ee (HEAD -> master) master: modified title - index.html
			* eaf2999 master: modified title - 404.html
			* 520d7e3 (tag: v-3.1.0-beta) master: modified js version - index.html
			* be40ca9 (tag: v-3.1.0) master: modified title - index.html
			* c44fb18 (tag: v-1.9.1) master: modified css - index.html
			* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
			* 2f49fbb (tag: v-1.8-rc1) master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

	Now we will associate tag v-3.1.0-beta with latest commit id or HEAD. 
	
		$ git tag -a v-3.1.0-beta --force 4ee49ee
			Updated tag 'v-3.1.0-beta' (was a398dbf)

		$ git log --oneline --decorate --graph --all
			* 4ee49ee (HEAD -> master, tag: v-3.1.0-beta) master: modified title - index.html
			* eaf2999 master: modified title - 404.html
			* 520d7e3 master: modified js version - index.html
			* be40ca9 (tag: v-3.1.0) master: modified title - index.html
			* c44fb18 (tag: v-1.9.1) master: modified css - index.html
			* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
			* 2f49fbb (tag: v-1.8-rc1) master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit


	We can see tag has been updated.
	
	We will see now how to delete a tag. We will delete - v-1.8-rc1
	
		$ git tag v-1.8-rc1 --delete
			Deleted tag 'v-1.8-rc1' (was 2f49fbb)

		$ git log --oneline --decorate --graph --all
			* 4ee49ee (HEAD -> master, tag: v-3.1.0-beta) master: modified title - index.html
			* eaf2999 master: modified title - 404.html
			* 520d7e3 master: modified js version - index.html
			* be40ca9 (tag: v-3.1.0) master: modified title - index.html
			* c44fb18 (tag: v-1.9.1) master: modified css - index.html
			* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
			* 2f49fbb master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

		$ git tag
			v-1.9-rc2
			v-1.9.1
			v-3.1.0
			v-3.1.0-beta

	We can se that tag has been deleted.
	

Quiz 20: Git Tagging: Quiz 1

	- The following statements is correct
		- Git has ability to tag specific points in history as being important.
		- Tags acts as bookmarks.
		- Normally people use the tag functionality to mark release points such as version1.0, version 1.3 and so on.
	
	
	Commands "git diff tag-1 tag-2" and "git diff commit-1 commit-2 yields similar information since a tag is just a pointer to a specific commit 
	(note: tag-1 is associated with commit id commit-1 and  tag-2 is associated with commit id commit-2)
		

99. Git Tagging: Pushing and Sharing all Tags(Lab)	

	We will see how to delete all tags i.e. both annotated and light-weight tag together.
	
	"git push origin :v-3.1.0-beta :v-3.1.0-alpha"				// This command will delete these tags from remote i.e. GitHub.
	
	Now we will push all our existing tags wethere annotated or light-weight to the remote i.e. GitHub.
	
	"git push origin --tags"		//This will push all the tags to remote repo on GitHub
	

100. Git Tagging: Deleting pushed tags (Lab)

	To delete pushed tags on github - "git push origin :<tag-name>" 	//Check previous lecture example
	
	We can delete multiple tags using same command, check previous lecture example.
	

101. Git Tagging: Pushing and Sharing Annotated Tags only (Lab)
	
	We will see how to push and share annotated tag on remote server.
	
	Two ways - 
		- Push annotated tags only
		- Push all tags both annotated and light-weight
		
	"git push origin --follow-tags"		=> pushes only annotated tags.
	
	"git push origin --tags"			=> pushes both annotated and light-weight tags.
	
	
	"git push origin --follow-tags"	 not only pushes annotated tags bu also the commits as well, i.e. if there was some commit which was not pushed then upon execution of this command that commit will get pushed along with annotated tags.
	
	Ideally we should only push annotated tag to remote server like GitHub and keep light-weight tags on local to avoid tag clashes. However we can still push light-weight tag on remote server.
	

102. Git Tagging: Pushing Annotated Tags by default (Lab)

	Now since git push command doesn't trafer tags to remote server such as GitHub by default, and we have to explicitly pushe these tags. 
	However git has provided us an option, which if configure in the .gitconfig file, will allow us automatic pushing of Annotated tags.
	The configuration is push.followTags is set to true.
	
	"git config --global push.followTags true"
	
	"git push -u origin master" 	// I think if the push is first time the we need -u option. check. -u will setup a tracking branching relationship. Subsequent push don't require -u option.
	
	Now when we do push our annotated tags will be pushed automatically.
	
	Now even if we push any tag such as light-weight tag, then also our other annotate tags will get pushed automatically due to followTags true.
	
	
103. Git Tagging: Checking out tags (Lab)

	We can't really checkout tag in git, however you can a new branch at a specific tag.
	
		$ git tag
			v-1.9-rc2
			v-1.9.1
			v-3.1.0
			v-3.1.0-beta

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-tag (master)
		$ git log --oneline --decorate --graph --all
			* 4ee49ee (HEAD -> master, tag: v-3.1.0-beta) master: modified title - index.html
			* eaf2999 master: modified title - 404.html
			* 520d7e3 master: modified js version - index.html
			* be40ca9 (tag: v-3.1.0) master: modified title - index.html
			* c44fb18 (tag: v-1.9.1) master: modified css - index.html
			* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
			* 2f49fbb master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-tag (master)
		$ git checkout v-3.1.0
			Note: switching to 'v-3.1.0'.

			You are in 'detached HEAD' state. You can look around, make experimental
			changes and commit them, and you can discard any commits you make in this
			state without impacting any branches by switching back to a branch.

			If you want to create a new branch to retain commits you create, you may
			do so (now or later) by using -c with the switch command. Example:

			  git switch -c <new-branch-name>

			Or undo this operation with:

			  git switch -

			Turn off this advice by setting config variable advice.detachedHead to false

			HEAD is now at be40ca9 master: modified title - index.html

	
	We can see that checking out a particular tag puts us in a detached head state.
	
	Lets get back to master -
	
		$ git checkout master
			Previous HEAD position was be40ca9 master: modified title - index.html
			Switched to branch 'master'

	So we can always create a branch and checkout at that tag - 

		$ git checkout -b branch-v-3.1.0 v-3.1.0
			Switched to a new branch 'branch-v-3.1.0'

		
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-tag (branch-v-3.1.0)
		$ git log --oneline --decorate --graph --all
			* 4ee49ee (tag: v-3.1.0-beta, master) master: modified title - index.html
			* eaf2999 master: modified title - 404.html
			* 520d7e3 master: modified js version - index.html
			* be40ca9 (HEAD -> branch-v-3.1.0, tag: v-3.1.0) master: modified title - index.html		//we can see new branch at this tag
			* c44fb18 (tag: v-1.9.1) master: modified css - index.html
			* 9d52563 (tag: v-1.9-rc2) master: modified title - index.html
			* 2f49fbb master: edited text-align and height - 404.html
			* 2210023 master: edited width - 404.html
			* c3d31cb master: edited font-family - 404.html
			* 551c960 master: edited line-height - 404.html
			* 1841047 master: edited title - index.html
			* 2fec32b first commit

	
Section 19: Do much more with GitHub

104. Introducing Pull Request in GitHub

	What is a Pull Request - 
		Pull request let you tell others about changes you've pushed to a repo on github. Once a pull request is opened, you can discuss and review the potential changes with collaborators add follow-up commits before the changes are merged into the repo.
		
	Check diagram - PullRequest.JPG

	Pull Request Workflow (may be different, but overall concept is same)
		1. GitHub accounts 
			We will use 2 github accounts, lets say user-1 and user-2
		
		2. Fork it
			user-1 will fork an existing repository (or original repo) whose owner is user-2
			
		3. Clone it
			user-1 will clone the forked remote repo in his local repo and push some changes up to the fork
			
		4. Raise pull request
			user-1 will raise a pull request and make comments as necessary
			
		5. Review request
			user-2 will review the pull request from user-1 and accept it or reject it. He may make comments as well.
			
		6. Merge pull request
			user-2 will accept the pull request resulting in merging of changes from user-1 in the repo owned bu user-2.
			
	
105. Playing with Pull Request in GitHub (Lab)

	Demonstration of pull request.
	
	

106. Git Stash Intro - Part 1: create, save, list & show (Lab)
107. Git Stash Intro - Part 2: apply, drop, pop, clear (Lab)


	git stash command is used to temporarily store uncommited your work in order to clean out your working directory without having to commit unfinished work on a branch. 
	
	Sometimes while working on a part of our project things can be in a messy state.
	And we might want to switch to a different branch to work on something else but before moving on to your other work you don't want to commit your unfinished work, basically you want to return back to your unfinished work later on. 
	So the solution to this problem is the git stash command.
	By executing this command we can save the stack of our unfinished work that includes modified tracked files and staged changes. 
	After we save the state of our working directory we can retrieve it at any point of time. 
		
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ ls
			404.html              browserconfig.xml  favicon.ico  img/        js/         tile.png
			apple-touch-icon.png  css/               humans.txt   index.html  robots.txt  tile-wide.png

		$ git log --oneline --decorate --graph --all
			* c4d5d52 (HEAD -> master) first commit

	
	Now suppose we are working on an index.html file. We have modified it and our boss asks us to work on certain urgent issue. So we need to save our unfinished work. 
	
		$ vim index.html

		$ git stash
			warning: LF will be replaced by CRLF in index.html.
			The file will have its original line endings in your working directory
			Saved working directory and index state WIP on master: c4d5d52 first commit

	WIP stands for Work In Progress.
	
	Whenever we execute the command a stash is created which we can view using - git stash list.
	
		$ git stash list
			stash@{0}: WIP on master: c4d5d52 first commit

	Now we check index.html, we can see that it has returned back to its original state and our changes are not there.
	
	Now we will do our urgent work, we will create a new branch and then update the humans.txt file and commit it and switch back to master branch.
	
		
		$ git checkout -b hotfix
			Switched to a new branch 'hotfix'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ vim humans.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ git commit -am "hotfix: add name - humans.txt"
			warning: LF will be replaced by CRLF in humans.txt.
			The file will have its original line endings in your working directory
			[hotfix 66c3a51] hotfix: add name - humans.txt
			 1 file changed, 1 insertion(+), 1 deletion(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ git checkout master
			Switched to branch 'master'


	Now we will start working on 404.html in master branch and then later lets assume again we need to work on hotfix branch then again we will stash our changes but this time command will be little different => git stash save "modified 404.html"
	
	Message helps us in identifying stash.
	
		$ vim 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash save "modified 404.html"
			warning: LF will be replaced by CRLF in 404.html.
			The file will have its original line endings in your working directory
			Saved working directory and index state On master: modified 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash list
			stash@{0}: On master: modified 404.html
			stash@{1}: WIP on master: c4d5d52 first commit

	
	Now we will switch back to hotfix branch and the modify humans.txt, commit and switch back to master branch. 	

		$ git checkout hotfix
			Switched to branch 'hotfix'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ vim humans.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ git commit -am "hotfix - modified role - humans.txt"
			[hotfix b04e7d9] hotfix - modified role - humans.txt
			 1 file changed, 1 insertion(+), 1 deletion(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ git checkout master
			Switched to branch 'master'


	Now on master we will work on browserconfig.xml, this time we will add our changes in our staging area, and then once again we need to switch back to hotfix, so again we will do stash. And switch back to hotfix.
	In hotfix we will again update humans.txt, commit it, switch back to master branch.
		
		$ vim browserconfig.xml

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git add browserconfig.xml
			warning: LF will be replaced by CRLF in browserconfig.xml.
			The file will have its original line endings in your working directory

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash save "modified browserconfig.xml"
			Saved working directory and index state On master: modified browserconfig.xml

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash list
			stash@{0}: On master: modified browserconfig.xml
			stash@{1}: On master: modified 404.html
			stash@{2}: WIP on master: c4d5d52 first commit

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git checkout hotfix
			Switched to branch 'hotfix'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ vim humans.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ git commit -am "hotfix - modified twitter - humans.txt"
			[hotfix 39eedcb] hotfix - modified twitter - humans.txt
			 1 file changed, 1 insertion(+), 1 deletion(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ git checkout master
			Switched to branch 'master'

		
		$ git stash list
			stash@{0}: On master: modified browserconfig.xml
			stash@{1}: On master: modified 404.html
			stash@{2}: WIP on master: c4d5d52 first commit

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash show stash@{2}
			 index.html | 2 +-
			 1 file changed, 1 insertion(+), 1 deletion(-)


	So far we stashed the file that were tracked, what about untracked file. 
	To see this we will create a new file 

		$ vim new-file.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					new-file.txt

			nothing added to commit but untracked files present (use "git add" to track)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash
			No local changes to save

	
	We can see it says No local changes to save. This is because "git stash" command works by default on tracked files. 
	If we want to save a untracked file then we need to execute "git stash -u", with -u option.
	
		$ git stash -u
			warning: LF will be replaced by CRLF in new-file.txt.
			The file will have its original line endings in your working directory
			Saved working directory and index state WIP on master: c4d5d52 first commit

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash list
			stash@{0}: WIP on master: c4d5d52 first commit
			stash@{1}: On master: modified browserconfig.xml
			stash@{2}: On master: modified 404.html
			stash@{3}: WIP on master: c4d5d52 first commit

	Now again we will switch back to hotfix branch, modify humans.txt and commit it, switch back to master. 
	
		$ git checkout hotfix
			Switched to branch 'hotfix'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ vim humans.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ git commit -am "hotfix - modified java - humans.txt"
			[hotfix 3007c64] hotfix - modified java - humans.txt
			 1 file changed, 1 insertion(+), 1 deletion(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (hotfix)
		$ git checkout master
			Switched to branch 'master'

	
	Now lets assume that we are done with our hotfix work, and we can now continue on our other work.
	So we are back on master branch and we will start working on our four file - index.html, browserconfig.xml, 404.html and new-file.txt
	
	In order to retrieve whatever is on the stash we need to execute a command => git stash apply
	
	Now when we do "git stash apply" without any option then git stash will be applied to the first stash or stash on the top.
	However if we want we can also specify the specific stash => git stash apply stash@{2}
		
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash list
			stash@{0}: WIP on master: c4d5d52 first commit
			stash@{1}: On master: modified browserconfig.xml
			stash@{2}: On master: modified 404.html
			stash@{3}: WIP on master: c4d5d52 first commit

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash apply
			Already up to date!
			On branch master
			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					new-file.txt

			nothing added to commit but untracked files present (use "git add" to track)

	Now we can simply start working on new-file or commit it. 

		$ git add new-file.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git commit -m "new-file.txt commited"
			[master de3412b] new-file.txt commited
			 1 file changed, 2 insertions(+)
			 create mode 100644 new-file.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash list
			stash@{0}: WIP on master: c4d5d52 first commit
			stash@{1}: On master: modified browserconfig.xml
			stash@{2}: On master: modified 404.html
			stash@{3}: WIP on master: c4d5d52 first commit

	Now stash@{0} has been applied and we don't need it any further, so we can remove it using => git stash drop stash@{0}
	
	If we don't provide any argument to "git stash drop", then it will remove the latest stash.
	
	
		$  git stash drop stash@{0}
			Dropped stash@{0} (45ccb0344cb226c08eef2cc11eb5a576860c9bd9)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash list
			stash@{0}: On master: modified browserconfig.xml
			stash@{1}: On master: modified 404.html
			stash@{2}: WIP on master: c4d5d52 first commit
	
	We will now apply another stash.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash list
			stash@{0}: On master: modified browserconfig.xml
			stash@{1}: On master: modified 404.html
			stash@{2}: WIP on master: c4d5d52 first commit

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash apply stash@{1}
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   404.html

			no changes added to commit (use "git add" and/or "git commit -a")

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git commit -am "404.html commited"
			[master a6d619d] 404.html commited
			 1 file changed, 1 insertion(+), 1 deletion(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash drop stash@{1}
			Dropped stash@{1} (46303848da32cfe1f042c67415718eae80fcfc5e)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash list
			stash@{0}: On master: modified browserconfig.xml
			stash@{1}: WIP on master: c4d5d52 first commit

	So far we were applying the stash and then dropping the stash, but there is a more convinient command that will apply and drop the stash at the same time. 

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash list
			stash@{0}: On master: modified browserconfig.xml
			stash@{1}: WIP on master: c4d5d52 first commit

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash pop stash@{1}
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   index.html

			no changes added to commit (use "git add" and/or "git commit -a")
			Dropped stash@{1} (a4a472bdf66ba5f54534860b34b21572c3dc5d2f)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash list
			stash@{0}: On master: modified browserconfig.xml

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git commit -am "index.html commited"
			[master c82f187] index.html commited
			 1 file changed, 1 insertion(+), 1 deletion(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash list
			stash@{0}: On master: modified browserconfig.xml

	We will apply and remove the last remaining stash.

		
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash list
			stash@{0}: On master: modified browserconfig.xml

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash apply
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   browserconfig.xml

			no changes added to commit (use "git add" and/or "git commit -a")

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git commit -am "browerconfig.xml commited"
			[master a886d27] browerconfig.xml commited
			 1 file changed, 1 insertion(+), 1 deletion(-)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash list
			stash@{0}: On master: modified browserconfig.xml

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash drop
			Dropped refs/stash@{0} (32b98f856685a2a646068a369c47f87506c03ac9)

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash list

	
	We will lastly see the clear command which will drop all stash in one go.
	
		"git stash clear"
		
				
	------------------
	
	To understand the need of stash I created a new repo demo-stash2 and then added two files and commited them. Then modified file1 on master and then without stashing this I switched to a new branch hotfix. When I checked the content of file1 on hotfix, it was same as that on master. The content should actually reset back to origin, but it didn't. If we had done stash before switching to hotfix then we would have got origin content in hotfix and not modified.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (master)
		$ ls
			file1  file2

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (master)
		$ git status
			On branch master
			nothing to commit, working tree clean

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (master)
		$ git log --oneline --decorate --graph --all
			* 2f96f88 (HEAD -> master) first commit

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (master)
		$ vim file1

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (master)
		$ cat file1

			This is to understand the need of stash
			Line 2

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (master)
		$ git checkout -b hotfix
			Switched to a new branch 'hotfix'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (hotfix)
		$ ls
		file1  file2

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (hotfix)
		$ cat file1

			This is to understand the need of stash
			Line 2

	Now lets again switch back to master and then stash and then create a new branch and check the content.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (hotfix)
		$ git checkout master
			Switched to branch 'master'
			M       file1

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (master)
		$ cat file1

			This is to understand the need of stash
			Line 2

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (master)
		$ git stash save "modified fiel1"
			warning: LF will be replaced by CRLF in file1.
			The file will have its original line endings in your working directory
			Saved working directory and index state On master: modified fiel1

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (master)
		$ git checkout -b hotfix2
			Switched to a new branch 'hotfix2'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (hotfix2)
		$ cat file1

			This is to understand the need of stash

	We can see the content was set back to original.
	
		$ git checkout hotfix
			Switched to branch 'hotfix'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash2 (hotfix)
		$ cat file1

			This is to understand the need of stash

	All branches changes were set to original old and new.
	
	-------------------------------
	
Quiz 22: Git Stash: Quiz 1

	
	The following statements are correct - 
	- The git stash command is used to temporarily store uncommited work in order to clean out your working directory without having to commit unfinished work on a branch.
	- By executing the "git stash" command, you can save your stack of unfinished work that includes modified tracked files and staged changes.
	- After you save your dirty state of your working directory, you can retrieve it at any point of time.
	

108. Git stash : Creating a Branch from a Stash (Lab)
	
	We will see how to apply stash to a particular branch.
	
	Suppose you have changed a number of files and then you have stashed those changes on the master branch. Now we have decided to move all those changes in the stash to a different branch. 
	So we can do that using "git stash branch" command.
	
	We will use same repo as earlier and currently there are no stash so we will create few.
	
	We modified index.html and also 404.html, but we staged only 404.html.
	We will also create a new-file-2.txt which will be untracked file.
	
	
		$  git stash list

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ vim index.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ vim 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git add 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   404.html

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   index.html


		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status -s
			M  404.html
			 M index.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ vim new-file-2.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   404.html

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   index.html

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					new-file-2.txt
	
		$ git status -s
			M  404.html
			 M index.html
			?? new-file-2.txt

	Now we stash using -u option because we have both tracked and untracked files.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$  git stash -u
		warning: LF will be replaced by CRLF in new-file-2.txt.
		The file will have its original line endings in your working directory
		Saved working directory and index state WIP on master: a886d27 browerconfig.xml commited

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash list
		stash@{0}: WIP on master: a886d27 browerconfig.xml commited


	Now lets consider a senario, that for certain reason we ned these changes on master branch on some another branch.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash branch demobranch
			Switched to a new branch 'demobranch'
			On branch demobranch
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   404.html

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   index.html

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					new-file-2.txt

			Dropped refs/stash@{0} (bc1620e75e579972cdeccb8e3b9b462fc6c2ae1c)


		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (demobranch)

	
	In above command git does is, create a new branch, switches to new branch, applies the stash, after application of stash git will drop the stash as well.

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (demobranch)
		$ git status
			On branch demobranch
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   404.html

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   index.html

			Untracked files:
			  (use "git add <file>..." to include in what will be committed)
					new-file-2.txt


		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (demobranch)
		$ git stash list

	Now we will commit these changes and then switch to master and merge the demobranch.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (demobranch)
		$ git add .

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (demobranch)
		$ git commit -am "three files changed - index.html, 404.html and new-file2.txt"
			[demobranch 8894458] three files changed - index.html, 404.html and new-file2.txt
			 3 files changed, 3 insertions(+), 2 deletions(-)
			 create mode 100644 new-file-2.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (demobranch)
		$ git checkout master
			Switched to branch 'master'

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git merge demobranch
			Updating a886d27..8894458
			Fast-forward
			 404.html       | 2 +-
			 index.html     | 2 +-
			 new-file-2.txt | 1 +
			 3 files changed, 3 insertions(+), 2 deletions(-)
			 create mode 100644 new-file-2.txt


109. Git stash: Creative stashing (Lab)

	We will see how to work with stash and staging area.
	
	WHEN WE DO STASH WE GET A CLEAN WORKING DIRECTORY, WE CAN CHECK USING GIT STATUS
	
		$ git stash list

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ vim index.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ vim 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git add 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   404.html

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   index.html


		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash save "index, 404"
			Saved working directory and index state On master: index, 404

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			nothing to commit, working tree clean


	Now we modified index.html and 404.html and we added only 404.html to staging area and we did stash.

	Now we will apply the stash and we can observe that the staged 404.html file will not be staged any more.
	
				
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash apply
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   404.html
					modified:   index.html

			no changes added to commit (use "git add" and/or "git commit -a")

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   404.html
					modified:   index.html

			no changes added to commit (use "git add" and/or "git commit -a")

	We can see that after we applied stash both our files are in modified state.
	So 404.html which was added in staging area is not staged any more.
	So if we want our exact restoration of our stash then we need to apply --index option. 
	
	In order to see this we undo the changes in these files.
	
		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   404.html
					modified:   index.html

			no changes added to commit (use "git add" and/or "git commit -a")

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git checkout -- 404.html	//this will undo changes.

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git checkout -- index.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			nothing to commit, working tree clean

	We again do the same changes and add it to stash. 
	
		$ vim index.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ vim 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git add 404.html

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   404.html

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   index.html


		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash
		Saved working directory and index state WIP on master: 8894458 three files changed - index.html, 404.html and new-file2.txt

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash list
			stash@{0}: WIP on master: 8894458 three files changed - index.html, 404.html and new-file2.txt
			stash@{1}: On master: index, 404

		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git stash apply --index
			On branch master
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   404.html

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   index.html


		inarajp@VI204875 MINGW64 ~/Desktop/temp/Udemy-Git/Repositories/demo-stash (master)
		$ git status
			On branch master
			Changes to be committed:
			  (use "git restore --staged <file>..." to unstage)
					modified:   404.html

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
					modified:   index.html



	Now we can see we got the exact state of the stash in our working area.
	
	Now if we want to undo the changes then we can do it easily for index.html => "git checkout -- index.html"
	But for 404.html as it is staged first we need to => "git reset HEAD 404.html" and then - "git checkout -- 404.html"

	Now uptil now we were modifying index.html and 404.html and we were staging only 404.html and we were adding both the files in the stash. But now we want to add the file that is not in staging area to the stash i.e. we don't want 404.html which is indexed to the stash, we only want index.html to be stashed. So we want to keep our index or staging area and not stash it => "git stash --keep-index"


Section 21: Making Git bash friendlier and productive	

111. Customize Git bash prompt (Lab)

	$ echo $PS1		//Shows the code which is responsible for what we see on bash
	
	Bash provides special variables - PS1, PS2, PS3, PS4

	We will be working owith PS1
	
	Above code lies in .bachrc file
	
	PS1 = "Hello! \W $ "			//\W represents current working directory

	To make change permanent we need to update.bashrc file.
	
	export PS1="Hello! \u@\h $ "

	source .bashrc
	
	
112. Colorize Git bash prompt (Lab)


113. Git plugin for branch information (Lab)

	
	\[\033]0;$TITLEPREFIX:$PWD\007\]\n\[\033[32m\]\u@\h \[\033[35m\]$MSYSTEM \[\033[33m\]\w\[\033[36m\]`__git_ps1`\[\033[0m\]\n$


114. Git plugin for working directory status information in Windows (Lab)

	Just add - GIT_PS1_SHOWDIRTYSTATE=1 in .bashrc file.
	
	# indicates a fresh git repository - there are untracked files
	* indicates modified tracked file - not staged
	+ indicates staged - not commited
	After commit there is no symbol. It means working directory is clean.
	
	
117. Git plugin for command auto-completion (Lab)

	Auto completion feature is there in Windows by default but not in Linux and Mac. To get it we need to do some extra work.
	
	
118. Command Summary (Making Git bash friendlier and productive)
	
	Command Summary (Making Git bash friendlier and productive)
	Part I: How do I modify or change the prompt?

	Modifying the prompt is easy task. Just assign a new value to PS1 and hit enter key.

	# "\W" is a prompt string and it stands for current working directory
	$ PS1="Hello! \W$ "
	 
	# more examples as below
	$ PS1="Hello! It's \@ $ "
	$ PS1="Hello! \u@\h $ "


	To make the change permanent, enter this one in your .bashrc file. If .bashrc does not exist, you can create it.

	This work for Windows and Linux:

	# "export" command exports variables to the environment of next executed commands 
	export PS1="Hello! \W$ "
	For Mac users:

	# need to make the changes in .bashrc as well as add the following line in .bash_profile
	source ~/.bashrc


	Part II: Colorization of Bash Prompt - fun and useful



	Step-1

	# coloring "Hello" part
	$ cd git-fast
	$ PS1='\[\e[1;32m\]Hello! \W $ '


	Step-2

	# the letters following prompt becomes non-colored
	$ PS1='\[\e[1;32m\]Hello! \W $ \[\e[0m\]'


	Step-3

	# coloring the working directory "\W" and "$"
	$ PS1='\[\e[1;32m\]Hello! \[\e[1;33m\]\W \[\e[1;35m\]$ \[\e[0m\]'


	Step-4

	# adding a new line "\n" (optional)
	$ PS1='\[\e[1;32m\]Hello! \[\e[1;33m\]\W \[\e[1;35m\]$ \[\e[0m\]\n'


	Step-5

	# add this in .bashrc to make the colorization permanent
	export PS1='\[\e[1;32m\]Hello! \[\e[1;33m\]\W \[\e[1;35m\]$ \[\e[0m\]'


	Git plugin for bash shell for current branch and working directory status info

	Windows - .bashrc

	export PS1='\[\e[1;32m\]Hello! \[\e[1;33m\]\W \[\e[1;34m\]$(__git_ps1) \[\e[1;35m\]$ \[\e[0m\]'
	export GIT_PS1_SHOWDIRTYSTATE=1


	Linux - .bashrc (step 1)

	# cd to ~
	$ curl -O https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh


	Linux - .bashrc (step 2)

	source ~/git-prompt.sh
	export GIT_PS1_SHOWDIRTYSTATE=1
	export PS1='\[\e[1;32m\]Hello! \[\e[1;33m\]\W \[\e[1;34m\]$(__git_ps1) \[\e[1;35m\]$ \[\e[0m\]


	Mac

	Here the process is similar to Linux - only thing that needs to be done is to source .bashrc in .bash_profile.



	Part III: Git plugin for bash shell (for auto-completion)



	Windows

	Not required for windows - auto-completion comes by default



	Linux - step 1

	# cd to ~
	$ curl -O https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash


	Linux - step 2 (add the following code in .bashrc file)

	source ~/git-completion.bash



	Mac

	Here the process is similar to Linux - only thing that needs to be done is to source .bashrc in .bash_profile








































	
	
	